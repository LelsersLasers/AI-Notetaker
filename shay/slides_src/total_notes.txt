### **Question 1: Converting `String[]` to `char[][]`**
- **Objective**: Transform a one-dimensional `String[] words` array into a two-dimensional `char[][] letters` array.
- **Approach**:
  - **Determine Maximum String Length**:
    - Iterate through `words` to find the longest `String`.
    - Example:
      ```java
      int maxLength = 0;
      for (String word : words) {
          if (word.length() > maxLength) {
              maxLength = word.length();
          }
      }
      ```
  - **Initialize `char[][] letters`**:
    - Dimensions: `words.length` x `maxLength`
    - Example:
      ```java
      char[][] letters = new char[words.length][maxLength];
      ```
  - **Populate `letters` with Characters**:
    - Nested loops to assign characters from each `String` to corresponding row in `letters`.
    - Pad with `'\0'` for indices beyond the `String` length.
    - Example:
      ```java
      for (int i = 0; i < words.length; i++) {
          for (int j = 0; j < maxLength; j++) {
              if (j < words[i].length()) {
                  letters[i][j] = words[i].charAt(j);
              } else {
                  letters[i][j] = '\0';
              }
          }
      }
      ```
- **Example Outcome**:
  - `words = {"dog", "horse"}` results in:
    ```java
    {
        {'d', 'o', 'g', '\0', '\0'},
        {'h', 'o', 'r', 's', 'e'}
    }
    ```

### **Question 2: Necessity of `'\0'` Characters**
- **Statement**: Null characters `'\0'` are unnecessary because each row could be made the exact size of the given `String` in `words` at that index.
- **Answer**: **FALSE**
- **Explanation**:
  - **Dynamic Sizing**:
    - If each row of `letters` is sized exactly to the corresponding `String` length, `'\0'` padding isn't needed.
  - **Uniform Dimensions**:
    - Using a fixed `maxLength` ensures uniform row sizes, which might simplify certain operations but introduces `'\0'` padding.
  - **Context Dependency**:
    - Depending on further processing requirements, fixed vs. dynamic sizing can have different implications.

### **Question 3: Flattening `double[][]` to `double[]`**
- **Objective**: Convert a two-dimensional `double[][] probabilities` array into a one-dimensional `double[] condensedProbabilities`.
- **Approach**:
  - **Calculate Total Size**:
    - Sum the lengths of all subarrays in `probabilities`.
    - Example:
      ```java
      int size = 0;
      for (int i = 0; i < probabilities.length; i++) {
          size += probabilities[i].length;
      }
      ```
  - **Initialize `condensedProbabilities`**:
    - Size determined by the total count from above.
    - Example:
      ```java
      double[] condensedProbabilities = new double[size];
      ```
  - **Populate `condensedProbabilities`**:
    - Iterate through each element in `probabilities` and assign sequentially.
    - Example:
      ```java
      int k = 0;
      for (int i = 0; i < probabilities.length; i++) {
          for (int j = 0; j < probabilities[i].length; j++) {
              condensedProbabilities[k] = probabilities[i][j];
              k++;
          }
      }
      ```

### **Question 4: Accessing Original Element After Flattening**
- **Statement**: Using only `condensedProbabilities` from Question 3, the value that existed at row 1, column 6 in `probabilities` can be located in `condensedProbabilities`. Assume you can no longer reference `probabilities`.
- **Answer**: **FALSE**
- **Explanation**:
  - **Loss of Two-Dimensional Structure**:
    - Flattening loses the original row and column mappings.
  - **No Direct Mapping**:
    - Without knowing the original dimensions or row lengths, determining the exact index in `condensedProbabilities` is not feasible.

### **Question 5: Implementing `move` Method for `Tile[][] board`**
- **Objective**: Create a `public static boolean move(int row, int column, int direction)` method to move a `Player` on the `board`.
- **Classes Involved**:
  - **Tile**:
    - `boolean hasPlayer()`
    - `Player deletePlayer()`
    - `boolean setPlayer(Player)`
  - **Player**:
    - `boolean equals(Object)`
    - `Player challenge(Player)`
- **Directions Mapping**:
  - `0` = Up
  - `1` = Right
  - `2` = Down
  - `3` = Left
- **Method Logic**:
  1. **Validate Input Indices**:
     - Check if `row` and `column` are within bounds of `board`.
     - Return `false` if out of bounds.
  2. **Access Current Tile**:
     - Retrieve `Tile` at `board[row][column]`.
  3. **Check for Player**:
     - If `hasPlayer()` is `true`, remove the `Player` using `deletePlayer()`.
     - If no `Player`, return `false`.
  4. **Determine Destination Tile Based on Direction**:
     - Calculate new `row` and `column` based on `direction`.
     - Validate new indices; return `false` if out of bounds.
  5. **Handle Destination Tile**:
     - If destination `Tile` has no `Player`, set the moving `Player` there using `setPlayer(Player)` and return `true`.
     - If destination `Tile` has another `Player`:
       - Invoke `challenge(Player)` between moving `Player` and existing `Player`.
       - If challenger wins (`challenge` returns moving `Player`):
         - Replace existing `Player` with moving `Player` using `setPlayer(Player)`.
         - Return `true`.
       - If challenger loses:
         - Existing `Player` remains; return `false`.
  6. **Successful Move Check**:
     - If moving `Player` is placed successfully on the destination `Tile`, return `true`.
     - Otherwise, return `false`.
- **Exception Handling**:
  - Ensure no exceptions are thrown.
  - Handle invalid directions and indices gracefully.

### **Question 6: Creating `Decrementor` Class Subclassing `Thread`**
- **Objective**: Implement a `Decrementor` class that extends `Thread` with a `private static ArrayList<String> trades`.
- **Requirements**:
  - **Constructor**:
    - No-argument constructor.
    - Initializes `trades` only if `trades` is `null`.
    - Include necessary import statements.
- **Implementation Details**:
  ```java
  import java.lang.Thread;
  import java.util.ArrayList;

  public class Decrementor extends Thread {
      private static ArrayList<String> trades;
      private static final Object mainLock = new Object();
      private static ArrayList<Boolean> locks;

      public Decrementor() {
          synchronized (mainLock) {
              if (trades == null) {
                  trades = new ArrayList<String>();
                  locks = new ArrayList<Boolean>();
              }
          }
      }

      // Additional methods for threading will follow
  }
  ```
- **Notes**:
  - **Thread Safety**: Use synchronization to prevent race conditions when initializing `trades`.
  - **Shared Resources**: `trades` and `locks` are shared across all instances due to `static` declaration.

### **Question 7: Implementing `addTrade` Method**
- **Objective**: Create a thread-safe `addTrade` method to append a `String trade` to `trades`.
- **Requirements**:
  - Public method.
  - Handles concurrent access from multiple `Decrementor` threads.
- **Implementation Details**:
  ```java
  public void addTrade(String trade) {
      synchronized (mainLock) {
          trades.add(trade);
          locks.add(false);
      }
  }
  ```
- **Explanation**:
  - **Synchronization**: Ensures that only one thread can modify `trades` and `locks` at a time.
  - **Locks Tracking**: Maintains an accompanying `locks` list to track access by threads.

### **Question 8: Implementing `run` Method for `Decrementor`**
- **Objective**: Process each `String trade` in `trades` concurrently, updating values based on `duration`.
- **Trade Format**: `date,value,cost,rate,duration`
  - `date`: `DD/MM/YY`
  - `value`, `cost`, `rate`: `double` (can be positive or negative)
  - `duration`: `int`
- **Method Requirements**:
  - **Thread Safety**: Multiple threads should process trades without conflict.
  - **Modify Trades**:
    - If `duration > 0`:
      - `value = rate * value`
      - `duration = duration - 1`
    - If `duration == 0`:
      - Print the updated `trade` once.
  - **Termination**: Thread terminates after processing the last accessible trade.
  - **Index Tracking**: Ensure threads start from the lowest unaccessed index.
- **Implementation Steps**:
  1. **Iterate Through Trades**:
     ```java
     public void run() {
         for (int i = 0; i < trades.size(); i++) {
             synchronized (mainLock) {
                 if (locks.get(i)) {
                     continue;
                 } else {
                     locks.set(i, true);
                 }
             }

             String[] tradeComps = trades.get(i).split(",");
             double value = Double.parseDouble(tradeComps[1]);
             double rate = Double.parseDouble(tradeComps[3]);
             int duration = Integer.parseInt(tradeComps[4]);

             if (duration > 0) {
                 value = rate * value;
                 duration -= 1;
                 String newTrade = String.format("%s,%.2f,%s,%.2f,%d",
                     tradeComps[0], value, tradeComps[2], rate, duration);

                 if (duration == 0) {
                     System.out.println(newTrade);
                 }

                 trades.set(i, newTrade);
             }

             synchronized (mainLock) {
                 locks.set(i, false);
             }
         }
     }
     ```
  2. **Detailed Explanation**:
     - **Lock Acquisition**:
       - Before processing a trade, check if it's already being processed (`locks.get(i)`).
       - If not, set `locks.set(i, true)` to mark it as being accessed.
     - **Trade Processing**:
       - Split the `trade` string into components.
       - Parse necessary fields (`value`, `rate`, `duration`).
       - Update `value` and decrement `duration` if applicable.
       - Format the updated trade string.
       - Print once if `duration` reaches `0`.
       - Update the `trades` list with the new trade.
     - **Lock Release**:
       - After processing, set `locks.set(i, false)` to allow other threads to access.
- **Thread Safety Considerations**:
  - **Granular Locking**: Only lock when checking and setting `locks`, minimizing the locked section.
  - **Avoid Full List Locking**: Allows multiple threads to process different trades concurrently.
  - **Single Print per Trade**: Ensures `System.out.println` is called only once per completed trade.

### **Question 9: Consistency of Final Trade Values Across Executions**
- **Statement**: Assuming a `main` method with multiple `Decrementor` threads executed twice with identical inputs and thread-safe implementation, the final value of a given input trade will have the same output after each execution.
- **Answer**: **TRUE**
- **Explanation**:
  - **Deterministic Processing**:
    - Given the same initial state and thread-safe operations, the outcome should be consistent.
  - **Thread Safety Assurance**:
    - Ensures that concurrent modifications do not introduce variability.
  - **Idempotent Operations**:
    - Operations on trades are deterministic based on input values.

### **Question 10: Order Consistency of Printed Outputs Across Executions**
- **Statement**: Under the same conditions as Question 9, the outputs printed to the terminal will be in the same order after each execution.
- **Answer**: **FALSE**
- **Explanation**:
  - **Concurrent Printing**:
    - Multiple threads may print in different orders due to scheduling by the JVM.
  - **Lack of Synchronization on Printing**:
    - Without explicit ordering mechanisms, print statements can interleave differently across runs.

### **Question 11: Methods of the `Thread` Class**
- **List of Four Methods**:
  1. `start()`: Initiates the thread’s execution, calling the `run()` method.
  2. `run()`: Contains the code that the thread executes.
  3. `join()`: Waits for the thread to finish its execution.
  4. `yield()`: Suggests to the thread scheduler that the thread is willing to yield its current use of a processor.
- **Additional Methods**:
  - `sleep(long millis)`: Pauses the thread for a specified duration.
  - `wait()`: Causes the current thread to wait until another thread invokes `notify()` or `notifyAll()` on the same object.

### **Question 12: `BufferedReader` Constructor Argument**
- **Question**: The constructor for `BufferedReader` requires an object of what class as an argument?
- **Answer**: **`Reader`**
- **Explanation**:
  - **Syntax Example**:
    ```java
    BufferedReader br = new BufferedReader(new FileReader("file.txt"));
    ```
  - **`Reader` Hierarchy**:
    - `FileReader` is a subclass of `Reader`, which is required by `BufferedReader`.

### **Question 13: Unchecked Exceptions Subclass**
- **Question**: All unchecked exceptions extend this subclass of `Exception`.
- **Answer**: **`RuntimeException`**
- **Explanation**:
  - **Unchecked Exceptions**:
    - Not required to be declared or caught.
    - Examples: `NullPointerException`, `IndexOutOfBoundsException`.
  - **Hierarchy**:
    - `RuntimeException` extends `Exception`.
    - All unchecked exceptions are subclasses of `RuntimeException`.

### **Question 14: Subclasses of `IOException`**
- **List of Two Subclasses**:
  1. **`FileNotFoundException`**:
     - Thrown when an attempt to open the file denoted by a specified pathname has failed.
  2. **`EOFException`**:
     - Signals that the end of a file or stream has been reached unexpectedly during input.
- **Additional Examples**:
  - `UnknownHostException`
  - `SocketException`

### **Question 15: Keyword to Differentiate Class Fields and Constructor Parameters**
- **Question**: What keyword can be used in a constructor to differentiate between fields of a class and those passed to the constructor as parameters?
- **Answer**: **`this`**
- **Usage Example**:
  ```java
  public class Example {
      private int value;

      public Example(int value) {
          this.value = value; // 'this.value' refers to the class field, 'value' is the parameter
      }
  }
  ```

### **Question 16: Package Import for File I/O Operations**
- **Question**: What package import is required for file reading and writing operations?
- **Answer**: **`java.io.*`**
- **Explanation**:
  - **Common Classes**:
    - `FileReader`, `FileWriter`, `BufferedReader`, `BufferedWriter`, `PrintWriter`, etc.
  - **Import Statement**:
    ```java
    import java.io.*;
    ```

### **Question 17: Keyword to Access Parent’s Constructor in Subclass**
- **Question**: What keyword can be used in a subclass’s constructor to access the parent’s constructor?
- **Answer**: **`super`**
- **Usage Example**:
  ```java
  public class Subclass extends Superclass {
      public Subclass(String param) {
          super(param); // Calls the superclass constructor with 'param'
      }
  }
  ```

### **Question 18: Implementing `printAll` Method for File Outputs**
- **Objective**: Create a `public static void printAll()` method that writes `outputs` to designated files based on `fileNames`.
- **Trade Format in `outputs`**:
  - `"fileName,contentToWrite"`
- **Approach**:
  1. **Initialize `PrintWriter` Objects for Each File**:
     - Create a `PrintWriter` for each `fileName` in `fileNames`.
     - Use `FileWriter` with `autoFlush` enabled.
     - Example:
       ```java
       ArrayList<PrintWriter> writers = new ArrayList<>();
       for (String fileName : fileNames) {
           writers.add(new PrintWriter(new FileWriter(fileName), true));
       }
       ```
  2. **Write Contents to Corresponding Files**:
     - Iterate through each `String` in `outputs`.
     - Split each `String` by comma to separate `fileName` and `content`.
     - Find the index of `fileName` in `fileNames`.
     - Use the corresponding `PrintWriter` to write `content`.
     - Example:
       ```java
       for (String output : outputs) {
           String[] parts = output.split(",");
           String targetFile = parts[0];
           String content = parts[1];
           int index = fileNames.indexOf(targetFile);
           if (index != -1) {
               writers.get(index).println(content);
           }
       }
       ```
  3. **Close All `PrintWriter` Objects**:
     - Ensure all streams are properly closed to free resources.
     - Example:
       ```java
       for (PrintWriter writer : writers) {
           writer.close();
       }
       ```
- **Full Implementation Example**:
  ```java
  import java.io.*;
  import java.util.ArrayList;

  public class FileOutputHandler {
      public static ArrayList<String> fileNames;
      public static ArrayList<String> outputs;

      public static void printAll() throws IOException {
          ArrayList<PrintWriter> writers = new ArrayList<>();
          for (String fileName : fileNames) {
              writers.add(new PrintWriter(new FileWriter(fileName), true)); // Auto-flush
          }

          for (String output : outputs) {
              String[] parts = output.split(",");
              String targetFile = parts[0];
              String content = parts[1];
              int index = fileNames.indexOf(targetFile);
              if (index != -1) {
                  writers.get(index).println(content);
              }
          }

          for (PrintWriter writer : writers) {
              writer.close();
          }
      }
  }
  ```

### **Question 19: Difference Between `try-with-resources` and `try-catch-finally`**
- **`try-with-resources`**:
  - **Purpose**: Automatically manages resource closure, ensuring resources are closed after use.
  - **Usage**:
    - Declare resources within the `try` statement.
    - Resources must implement `AutoCloseable`.
    - Example:
      ```java
      try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {
          // Use br
      } catch (IOException e) {
          // Handle exception
      }
      ```
  - **Advantages**:
    - Simplifies code by removing the need for explicit `finally` blocks.
    - Reduces boilerplate and potential for resource leaks.
- **`try-catch-finally`**:
  - **Purpose**: Provides a structured way to handle exceptions and ensure cleanup actions.
  - **Usage**:
    - `try`: Block containing code that may throw exceptions.
    - `catch`: Block to handle specific exceptions.
    - `finally`: Block that executes regardless of whether an exception occurred.
    - Example:
      ```java
      BufferedReader br = null;
      try {
          br = new BufferedReader(new FileReader("file.txt"));
          // Use br
      } catch (IOException e) {
          // Handle exception
      } finally {
          if (br != null) {
              try {
                  br.close();
              } catch (IOException ex) {
                  // Handle exception during close
              }
          }
      }
      ```
  - **Advantages**:
    - Explicit control over exception handling and resource management.
    - Flexibility to perform additional cleanup or logging in `finally`.

### **Question 20: Multiple `catch` Blocks in `try-catch-finally`**
- **Reason for Multiple `catch` Blocks**:
  - **Specific Exception Handling**:
    - Allows handling different exceptions in tailored ways.
    - Example:
      ```java
      try {
          // Code that may throw exceptions
      } catch (FileNotFoundException e) {
          // Handle file not found
      } catch (IOException e) {
          // Handle other I/O errors
      }
      ```
  - **Granular Control**:
    - Different actions or responses based on the type of exception.
  - **Avoiding Generic Handling**:
    - Prevents catching broad exceptions when specific handling is needed.

### **Question 21: Method Declarations in Interfaces**
- **Complete Statement**: Methods in interfaces can be declared as **`default, static, or public`**.
- **Details**:
  - **`public`**:
    - All interface methods are implicitly `public`.
  - **`default`**:
    - Provides a default implementation within the interface.
    - Example:
      ```java
      default void defaultMethod() {
          // Implementation
      }
      ```
  - **`static`**:
    - Belongs to the interface itself, not to instances.
    - Example:
      ```java
      static void staticMethod() {
          // Implementation
      }
      ```
  - **`abstract`**:
    - All non-default and non-static methods are implicitly `abstract`.

### **Question 22: Overridden Method Signature in Subclass**
- **Statement**: In a subclass, an overridden method has the same signature as a method in its parent class.
- **Answer**: **TRUE**
- **Explanation**:
  - **Method Signature**:
    - Must match in name, return type, and parameters.
  - **Purpose of Overriding**:
    - To provide specific implementation while retaining the method's contract.

### **Question 23: Overriding vs. Overloading**
- **Statement**: Overriding and overloading are synonymous.
- **Answer**: **FALSE**
- **Explanation**:
  - **Overriding**:
    - Subclass provides a specific implementation of a method declared in its superclass.
    - Requires same method signature.
    - Example:
      ```java
      @Override
      public void display() {
          // New implementation
      }
      ```
  - **Overloading**:
    - Multiple methods with the same name but different parameters within the same class.
    - Example:
      ```java
      public void display(int num) { }
      public void display(String msg) { }
      ```

### **Question 24: Hierarchy in Inheritance**
- **Statement**: In object-oriented programming, there is a distinct hierarchy to inheritance.
- **Answer**: **TRUE**
- **Explanation**:
  - **Inheritance Hierarchy**:
    - Classes can extend other classes, forming a parent-child hierarchy.
    - **Single Inheritance** (Java): A class can inherit from one superclass.
    - **Hierarchy Levels**:
      - Base Class → Intermediate Class → Derived Class.
  - **Benefits**:
    - Promotes code reuse.
    - Establishes relationships between classes.

### **Question 25: Method Overloading with Access Modifiers**
- **Statement**: A class can have two otherwise identical methods assuming one is `public` and the other is `private`.
- **Answer**: **FALSE**
- **Explanation**:
  - **Method Signatures**:
    - Methods must differ in name or parameter list.
    - Access modifiers alone do not create distinct signatures.
  - **Compilation Error**:
    - Defining two methods with the same name and parameters, differing only by access modifier, results in a compilation error.

### **Question 26: Accessing Protected Fields in Subclass**
- **Statement**: Subclasses can access `protected` fields in their parent class.
- **Answer**: **TRUE**
- **Explanation**:
  - **Protected Access Modifier**:
    - Accessible within the same package and by subclasses, even if they are in different packages.
  - **Usage Example**:
    ```java
    public class Parent {
        protected int protectedField;
    }

    public class Child extends Parent {
        public void accessField() {
            this.protectedField = 10; // Allowed
        }
    }
    ```

### **Question 27: Handling Unchecked Exceptions with `try-catch-finally`**
- **Statement**: A `try-catch-finally` block can be used to handle any type of `Exception` including unchecked exceptions.
- **Answer**: **TRUE**
- **Explanation**:
  - **Exception Types**:
    - **Checked Exceptions**: Must be declared or handled (e.g., `IOException`).
    - **Unchecked Exceptions**: Subclasses of `RuntimeException` (e.g., `NullPointerException`).
  - **Handling**:
    - Both types can be caught using `catch` blocks.
    - Example:
      ```java
      try {
          // Code that may throw exceptions
      } catch (RuntimeException e) {
          // Handle unchecked exceptions
      } catch (Exception e) {
          // Handle other exceptions
      } finally {
          // Cleanup code
      }
      ```

### **Question 28: Defining `ExamInterface` Based on `ExamUser` Class**
- **Objective**: Create an `ExamInterface` that `ExamUser` implements, containing as much of `ExamUser` as possible.
- **Given `ExamUser` Class**:
  ```java
  public class ExamUser implements ExamInterface {
      private String userName;
      private String password;

      public ExamUser(String userName) {
          this.userName = userName;
      }

      public ExamUser(String userName, String password) {
          this.userName = userName;
          this.password = password;
      }

      public String getUserName() {
          return userName;
      }

      public String getPassword() {
          return password;
      }

      public void setPassword(String password) {
          this.password = password;
      }

      public static void main(String[] args) {
          Scanner scan = new Scanner(System.in);
          System.out.println(MENU_1);
          ExamUser user = new ExamUser(scan.nextLine());
          System.out.println(MENU_2);
          user.setPassword(scan.nextLine());
          System.out.println(String.format(EXIT_MESSAGE, user.getUserName()));
      }
  }
  ```
- **Expected Interface Members**:
  - **Constants**:
    - `MENU_1`, `MENU_2`, `EXIT_MESSAGE` as `public static final` (implicitly in interface).
  - **Method Signatures**:
    - `getUserName()`
    - `getPassword()`
    - `setPassword(String password)`
- **Implementing `ExamInterface`**:
  ```java
  public interface ExamInterface {
      // Constants
      String MENU_1 = "Please enter your username:";
      String MENU_2 = "Please enter your password:";
      String EXIT_MESSAGE = "Thank you, %s!\n";

      // Method Signatures
      String getUserName();
      String getPassword();
      void setPassword(String password);
  }
  ```
- **Explanation**:
  - **Constants in Interface**:
    - Automatically `public static final`.
    - Provide consistent messages used in `ExamUser`.
  - **Method Declarations**:
    - Match the public methods in `ExamUser`.
    - Ensure `ExamUser` fulfills the interface contract.

### **Additional Java Concepts Covered**
- **Threads and Synchronization**:
  - Managing shared resources with synchronization blocks.
  - Avoiding race conditions using locks.
  - Implementing thread-safe methods.
- **Exception Handling**:
  - Differentiating between checked and unchecked exceptions.
  - Utilizing multiple `catch` blocks for specific handling.
- **Object-Oriented Principles**:
  - Inheritance hierarchy and access modifiers (`protected`, `public`, `private`).
  - Method overriding vs. overloading.
  - Interface implementation and method declarations.
- **File I/O Operations**:
  - Using `BufferedReader`, `FileReader`, `PrintWriter`, and `FileWriter`.
  - Managing resources with `try-with-resources` vs. `try-catch-finally`.
- **Data Structures**:
  - Manipulating arrays and ArrayLists.
  - Converting between different dimensional arrays.

## Java Classes
- **Components**:
  - **Fields**: Attributes of an object or class
  - **Methods**: Operations on an object or class
- **Access**:
  - Fields accessible to methods within the class
- **Types**:
  - **Static**: Belong to the class
  - **Non-Static**: Belong to individual objects

## Static vs. Non-Static Fields
- **Static Field**:
  - Single memory location shared by all class instances
  - Same value accessible by all methods
  - Useful for shared data (e.g., counters, constants)
- **Non-Static Field**:
  - Each object has its own memory location
  - Values can differ between objects

## Java Variable Terminology
- **Instance Variables**: Non-static fields declared in a class
- **Class Variables**: Static fields declared in a class
- **Local Variables**: Variables declared within methods or blocks
- **Parameters**: Variables declared in method headers

## Example: Student Class
- **Fields**:
  - **Non-Static**: Attributes unique to each student (e.g., name, ID)
  - **Static**: Attributes shared across all students (e.g., school name)
- **Methods**:
  - **Non-Static**: Operations specific to a student object
  - **Static**: Operations common to all student objects

## Problem: Counter
- **Tasks**:
  - Create a class with both static and non-static counters
  - Instantiate objects
  - Increment counters
  - Print values before and after increments

## Solution 1: Counter Class
- **Fields**:
  - `int x;` (non-static)
  - `static int y;` (static)
- **Main Method**:
  - Create objects `alice` and `bob`
  - Assign values to `x` and `y` for both objects
  - Print `alice.x`, `alice.y`, `bob.x`, `bob.y`
  - Increment `alice.y` and print `alice.y`, `bob.y`
  - Increment `Counter.y` and print `alice.y`, `bob.y`
- **Summary**:
  - Each `Counter` object has its own `x`
  - Only one shared `y` exists for all instances

## Methods in Java
- **Definition**: A block of code with parameters that may return a value
- **Existence**: Must be inside a class
- **Benefits**:
  - **Reusability**: Avoid redundant code
  - **Readability**: Logical operations identifiable by name
  - **Modularity**: Independent coding and testing

## Basic Method Syntax
```
return_type methodName(param_list) {
    statements;
    return_if_needed;
}
```
- **return_type**: Type of value returned (`void` if none)
- **methodName**: Identifier for the method
- **param_list**: Zero or more parameters with types and names

## Parameters and Arguments
- **Parameters**: Variables in method declarations, local to the method
- **Arguments**: Values passed to methods during calls
- **Rules**:
  - Argument values are copied into parameter variables
  - Must match in number and type

### Example:
```java
int calc(double x, int y) { ... return z; }
sum = calc(r, s);
```

## Flow of Control for Method Calls
1. **Before Call**:
   - Arguments copied to parameters in the called method
2. **During Call**:
   - Calling method is suspended
   - Called method executes from top to return/end
3. **After Call**:
   - Return value is passed back to the caller

## Call by Value
- **Behavior**:
  - Parameter variables are separate from argument variables
- **Example**:
  ```java
  void changer(int x) { x = 12; }
  int y = 5;
  changer(y);
  System.out.println(y); // Outputs 5
  ```

## Solution 2: Counter2 Class
- **Fields**:
  - `int x;` (non-static)
  - `static int y = 42;` (static)
- **Constructor**:
  - Initializes `x` using `this.x = x;`
- **Main Method**:
  - Create `alice` and `jimmy` with initial `x` values
  - Print initial `x` and `y` using `printf`
  - Increment `alice.x`, `alice.y`, `jimmy.x`, `jimmy.y`
  - Print updated values

## Solution 3: Counter3 Class
- **Fields and Constructor**: Omitted for brevity
- **Static Method `display`**:
  - Takes `String name` and `Counter3 c` object
  - Prints `name`, `c.x`, `c.y`
- **Main Method**:
  - Create `alice` and `jimmy`
  - Display initial values
  - Increment `x` and `y` for both objects
  - Display updated values

## Static vs. Non-Static Methods
- **Static Method**:
  - Can only access static fields and call other static methods
  - Called using class name (e.g., `Math.pow(2, 5)`)
- **Non-Static Method**:
  - Can access non-static fields and other methods of the object
  - Must be called on an instance (e.g., `object.describe()`)
  - `this.method()` is equivalent to `describe()`

## Extended Method Syntax
```
[static] return_type methodName(param_list) {
    statements;
    return_if_needed;
}
```
- **static**: Optional keyword indicating the method is static
- **Instance Method**: Lacks `static`, associated with objects

## Constructors in Java
- **Usage**: Instantiate objects using `new` keyword
  - Example: `Counter c1 = new Counter(500);`
- **Characteristics**:
  - Similar to methods but not exactly methods
  - May take parameters
  - Can access all class fields (including static)
  - Initialize new objects
  - Do not return values explicitly; `new` returns a reference to the object

## Variable Scope
- **Definition**: Region of code where a variable is accessible
- **Basic Rule**: From declaration to end of the enclosing block
- **Special Cases**:
  - **Parameters**: Accessible within the entire method
  - **For Loop Variables**: Accessible within loop header and body

## Example: Scope1a
```java
public class Scope1 {
    int x;

    void one(int x) { // Parameter x hides field x
        // int x; // Error: Duplicate variable in the same scope
    }

    void two() {
        int x = 10; // Local x hides field x

        while (true) {
            // int x; // Error: Duplicate variable in the same scope
        }
    }

    public static void main(String[] args) {
    }
}
```

## Example: Scope1b
```java
public class Scope1 {
    public static void main(String[] args) {
        { // Block 1
            int x = 12;
        }

        { // Block 2
            int x = 15;
        }

        for (int i = 0; i < 10; i++) // i accessible in loop
            System.out.println(i);

        // System.out.println(i); // Error: i is out of scope
    }
}
```

## Scope Limitations
- **Duplicate Names**: Cannot have two variables with the same name in the same scope
- **Shadowing**:
  - Parameters and local variables can hide class fields with the same name
  - Use `this.field` to access hidden class fields

## Example: Scope2
```java
public class Scope2 {
    int x;
    String name;

    Scope2(int x, String aName) {
        this.x = x;    // Initializes class field x
        name = aName;  // Initializes class field name
    }

    void doit() {
        int x = 10;    // Local x hides class field x
        this.x = x;    // Assigns local x to class field x
    }

    public static void main(String[] args) {
        Scope2 sc1 = new Scope2(12, "Fred");
        Scope2 sc2 = new Scope2(25, "Ralph");
    }
}
```

## The `this` Keyword
- **Reserved Word**: Cannot be used as a variable name
- **Usage Context**: Only within non-static methods or constructors
- **Reference**: Points to the current object
- **Purpose**: Access fields and methods of the current object
- **Examples**:
  - `this.x = x;` assigns parameter `x` to class field `x`
  - `this.methodName()` calls a method of the current object
### Constructing Graphical User Interfaces
- **Frames**
  - **JFrame Class**
    - Basic top-level window interacting with OS window manager.
    - Houses and lays out interactive controls.
    - Usage Approaches:
      - Create a raw `JFrame` object.
      - Extend `JFrame` and then create an object.
    - **Operations:**
      - `setDefaultCloseOperation`:
        - `DISPOSE_ON_CLOSE` for graceful shutdown.
        - Avoid `EXIT_ON_CLOSE` as it equates to `System.exit()`.
      - `setSize(width, height)`: Defines window dimensions.
      - `setResizable(boolean)`: Allows or restricts window resizing.
      - `setVisible(boolean)`: Makes the frame visible; `true` also validates the frame.
      - `setTitle(String)`: Sets the title displayed in the title bar.
      - `add(Component)`: Adds components to the content pane.

- **Panels**
  - **JPanel Class**
    - Java panel class used to group widgets for layout.
    - Hierarchical structure; can contain sub-panels.
    - Special Features in `JFrame`:
      - `jf.getContentPane()` returns a `JPanel`.
      - `jf.add(...)` automatically adds components to the content pane.
      - Default layout manager is `BorderLayout`.

- **Widgets**
  - **Common Widgets:**
    - `JLabel`: Displays unselectable text and images; supports HTML. Methods include `setFont()`, `setForeground()`, etc.
    - `JButton`: Interactive button for user actions.
    - `JTextField`: Single-line text input.
    - `JTextArea`: Multi-line text input.
    - Additional widgets: Radio buttons, scroll bars, toggles, canvases, etc.

### Review from Earlier Lecture on GUIs
- **JOptionPane**
  - Used for creating standard dialog boxes like message, input, and confirm dialogs.

- **JFileChooser**
  - Component that provides a simple mechanism for the user to choose a file.

- **One-shot, pop-up dialogs**
  - Dialogs that appear temporarily for user interaction and then disappear.

### Paradigm Shift: From Command-Line Interface to GUI
- **Command-Line Interface (CLI)**
  - Interaction through text prompts and responses.
  - Requires screening for malformed or malicious input.

- **Graphical User Interface (GUI)**
  - Interaction through graphical elements like text boxes, buttons, sliders.
  - Responses are constrained to specific formats (e.g., keystrokes, mouse clicks).

### Model-View-Controller (MVC) Paradigm
- **Model**
  - Represents the underlying data or database of the application.

- **View**
  - Consists of GUI components visible to the user.

- **Controller**
  - Acts as the intermediary implementing business rules.
  - Responsibilities:
    - Updates the view when the model changes.
    - Updates the model based on user interactions from the view.

- **Benefits**
  - Separates responsibilities to manage system complexity.
  - Allows specialization in model, view, and controller components.

### GUI Concept: Interface Hierarchy
- **Hierarchy Structure**
  - **Frame (`JFrame`)**
    - Top-level window interacting with the desktop environment.
    - Contains:
      - **Menu Bar (`JMenuBar`)**
      - **Panel (`JPanel`)**: Manages layout of top-level components.
  - **Widgets within Panels**
    - Includes labels, buttons, text fields, scroll bars, canvases.
    - Panels can contain sub-panels for complex layouts.

### Layout Managers
- **Purpose**
  - Define rules for positioning and sizing child components within containers.

- **Common Layout Managers:**
  - **BorderLayout**
    - Divides container into five regions: North, South, East, West, Center.
    - Only one component per region.
    - Example: `jf.add(component, BorderLayout.CENTER);`

  - **FlowLayout**
    - Default for `JPanel`.
    - Arranges components left to right, top to bottom.
    - Centers each line; components retain their preferred size.

  - **GridLayout**
    - Arranges components in a grid of specified rows and columns.
    - All cells are the same size; components fill all available space within cells.
    - Example: `new GridLayout(3, 4)` creates 3 rows and 4 columns.

  - **Other Layouts**
    - `BoxLayout`: Arranges components either vertically or horizontally.
    - `GridBagLayout`: Offers more flexibility for complex layouts.

- **Changing Layout Managers**
  - Example of setting `FlowLayout`:
    ```java
    JPanel jp = jf.getContentPane();
    jp.setLayout(new FlowLayout());
    jp.add(...);
    ```

### Swing Packages in Java
- **java.awt (Abstract Window Toolkit)**
  - Original set of classes for building GUIs.

- **javax.swing**
  - Built on top of AWT.
  - Provides "J" classes which are more versatile and feature-rich.
  - Preferred for modern Java GUI development.

### Event Handling
- **Concept**
  - Connects user actions to program responses.

- **Components:**
  - **Event Sources**
    - User interactions like keystrokes, mouse clicks, mouse movements.

  - **Event Listeners**
    - Methods in the code that process events.
    - Linked to widgets to handle specific types of events.
    - Run on the Event Dispatch Thread (EDT) to avoid blocking.

- **Event Dispatch Thread (EDT)**
  - Dedicated thread managing GUI events and rendering.
  - GUI creation and updates should occur on the EDT using `SwingUtilities.invokeLater(Runnable)` to prevent thread safety issues and deadlocks.

### Observer (“Listener”) Interfaces in Java
- **ActionListener**
  - Used for buttons and other actionable components.
  - Must implement `public void actionPerformed(ActionEvent e)`.

- **MouseListener**
  - Handles component entry/exit events.

- **MouseMotionListener**
  - Handles mouse movement events within components.

- **ItemListener**
  - Monitors changes in item states, such as check boxes.

- **DocumentListener**
  - Observes changes in text components like `JTextField`.

- **KeyListener**
  - Detects key presses and releases in text boxes.

### Implementing ActionListener
- **Techniques:**
  1. **Named Class**
     - Create a separate class that implements `ActionListener`.
     - Attach an instance to one or more buttons.
     ```java
     public class ListenerTechnique1 implements ActionListener {
         public void actionPerformed(ActionEvent ae) {
             System.out.printf("Button pressed: %s\n", ae.getActionCommand());
         }
     }
     // Attaching to a button
     button.addActionListener(new ListenerTechnique1());
     ```

  2. **Nested Class**
     - Define a class within a method.
     ```java
     class OneShot implements ActionListener {
         public void actionPerformed(ActionEvent ae) {
             System.out.printf("Button pressed: %s\n", ae.getActionCommand());
         }
     }
     button.addActionListener(new OneShot());
     ```

  3. **Anonymous Inner Class**
     - Implement listener without a named class for one-time use.
     ```java
     button.addActionListener(new ActionListener() {
         public void actionPerformed(ActionEvent ae) {
             // Handle event
         }
     });
     ```

- **Source to Listener Relationships:**
  - **One-to-One**
    - Single event source to single listener.

  - **Many-to-One**
    - Multiple event sources share a single listener.
    - Efficient for handling similar actions across multiple components.

  - **One-to-Many**
    - Single event source notifies multiple listeners.
    - Allows different responses to the same event.

### Adapter Classes
- **Problem**
  - Interfaces with multiple methods can be cumbersome to implement if only a few methods are needed.

- **Solution**
  - Use adapter classes that provide default (empty) implementations.
  - Subclass the adapter and override only necessary methods.

- **Example: MouseAdapter**
  - Implements `MouseListener` and `MouseMotionListener` with empty methods:
    - `mouseEntered(...)`
    - `mouseClicked(...)`
    - `mouseExited(...)`
    - `mousePressed(...)`
    - `mouseReleased(...)`
  - Override only methods relevant to the application.

### Graphics and Custom Painting in Swing
- **JComponent Class**
  - Parent of all Swing classes except `JFrame`.
  - Represents a blank rectangular area for custom drawing.
  - Custom painting by overriding `paintComponent(Graphics g)`.

- **Graphics and Graphics2D Classes**
  - **Graphics**
    - Passed to `paintComponent`.
    - Provides basic drawing capabilities.

  - **Graphics2D**
    - Subclass of `Graphics` with enhanced features.
    - Commonly cast from `Graphics` in `paintComponent`.
    ```java
    public void paintComponent(Graphics g) {
        Graphics2D g2 = (Graphics2D) g;
        // Drawing operations
    }
    ```
  - **Coordinate System**
    - Origin (0,0) at upper left.
    - X-axis increases to the right.
    - Y-axis increases downward.

  - **Graphics Context**
    - Current color, font, and other properties.

- **Drawing Operations Examples**
  - `g2.drawLine(x1, y1, x2, y2)`
  - `g2.drawRect(x, y, width, height)`
  - `g2.fillOval(x, y, width, height)`
  - `g2.drawString(s, x, y)`

- **Repainting**
  - Call `repaint()` to trigger `paintComponent`.
  - Can be invoked from non-EDT threads; `paintComponent` runs on EDT.

### Factory Pattern in GUI Construction
- **Definition**
  - Design pattern for creating objects using static methods.

- **Benefits**
  - Simplifies object creation without using `new`.
  - Enables reuse of read-only or shared objects.

- **Example: BorderFactory**
  - Methods like `createLineBorder(Color.RED)` and `createTitledBorder("Sub Panel")`.
  - Returns configured border objects for use in components.

### Example Implementations
- **EmptyFrame Example**
  ```java
  import javax.swing.SwingUtilities;
  import javax.swing.JFrame;

  public class EmptyFrame {
      public static void main(String[] args) {
          SwingUtilities.invokeLater(new Runnable() {
              public void run() {
                  createGUI();
              }
          });
      }

      public static void createGUI() {
          JFrame jf = new JFrame("Empty Frame");
          jf.setSize(640, 480);
          jf.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
          jf.setVisible(true);
      }
  }
  ```
  - Launches `JFrame` on the EDT to avoid thread safety issues.

- **PushMe Example**
  ```java
  import javax.swing.SwingUtilities;
  import javax.swing.JFrame;
  import javax.swing.JButton;
  import java.awt.BorderLayout;
  import java.awt.event.ActionListener;
  import java.awt.event.ActionEvent;

  public class PushMe implements ActionListener {
      static JFrame frame;

      public static void main(String[] args) {
          SwingUtilities.invokeLater(new Runnable() {
              public void run() {
                  createGUI();
              }
          });
      }

      public static void createGUI() {
          frame = new JFrame("Push Me");
          frame.setSize(200, 100);
          frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

          JButton button = centeredButton();
          button.addActionListener(new PushMe());
          frame.setVisible(true);
          frame.setLocationRelativeTo(null);
      }

      public void actionPerformed(ActionEvent e) {
          JButton b = (JButton) e.getSource();
          if (b.getActionCommand().equals("last time"))
              frame.dispose();
          if (b.getActionCommand().equals("push")) {
              b.setActionCommand("last time");
              b.setText("Push Again");
          }
      }

      static JButton centeredButton() {
          String[] locations = { BorderLayout.NORTH, BorderLayout.EAST, BorderLayout.SOUTH, BorderLayout.WEST };
          for (String loc : locations) {
              frame.add(new JLabel("     "), loc);
          }
          JButton jb = new JButton("Push Me");
          jb.setActionCommand("push");
          frame.add(jb, BorderLayout.CENTER);
          return jb;
      }
  }
  ```
  - Demonstrates button event handling with action commands and dynamic text updates.

- **FlowLayout Example**
  ```java
  import javax.swing.SwingUtilities;
  import javax.swing.JFrame;
  import javax.swing.JPanel;
  import javax.swing.JButton;

  public class FlowLayoutExample {
      public static void main(String[] args) {
          SwingUtilities.invokeLater(new Runnable() {
              public void run() {
                  createGUI();
              }
          });
      }

      public static void createGUI() {
          JFrame frame = new JFrame("FlowLayout Example");
          frame.setSize(500, 300);
          frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

          JPanel panel = new JPanel(); // Uses FlowLayout by default
          for (int i = 1; i <= 10; i++) {
              JButton button = new JButton("Button " + i);
              panel.add(button);
          }

          frame.add(panel);
          frame.setVisible(true);
      }
  }
  ```
  - Creates a window with buttons flowing left to right, wrapping as needed.

- **GridLayout Example**
  ```java
  import javax.swing.SwingUtilities;
  import javax.swing.JFrame;
  import javax.swing.JPanel;
  import javax.swing.JButton;
  import java.awt.GridLayout;

  public class GridLayoutExample {
      public static void main(String[] args) {
          SwingUtilities.invokeLater(new Runnable() {
              public void run() {
                  createGUI();
              }
          });
      }

      public static void createGUI() {
          JFrame frame = new JFrame("GridLayout Example");
          frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
          JPanel panel = new JPanel(new GridLayout(3, 4)); // 3 rows, 4 columns

          for (int i = 1; i <= 12; i++) {
              JButton button = new JButton("Button " + i);
              panel.add(button);
          }

          frame.add(panel);
          frame.pack(); // Adjusts frame to fit contents
          frame.setVisible(true);
      }
  }
  ```
  - Arranges 12 buttons in a 3x4 grid, ensuring uniform sizing.

- **SubPanelExample with Borders**
  ```java
  import javax.swing.SwingUtilities;
  import javax.swing.JFrame;
  import javax.swing.JPanel;
  import javax.swing.JButton;
  import javax.swing.BorderFactory;
  import javax.swing.border.Border;
  import java.awt.Color;
  import java.awt.GridLayout;

  public class SubPanelExample {
      public static void main(String[] args) {
          SwingUtilities.invokeLater(new Runnable() {
              public void run() {
                  createGUI();
              }
          });
      }

      public static void createGUI() {
          JFrame frame = new JFrame("SubPanel Example");
          frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

          JPanel pane1 = new JPanel();
          JPanel pane2 = new JPanel(new GridLayout(0, 2));

          Border b1 = BorderFactory.createLineBorder(Color.RED);
          Border b2 = BorderFactory.createTitledBorder("Sub Panel");
          pane1.setBorder(b1);
          pane2.setBorder(b2);

          addButtons(pane2, 5);
          addButtons(pane1, 2);
          pane1.add(pane2);
          addButtons(pane1, 3);

          frame.add(pane1);
          frame.setVisible(true);
      }

      static int counter = 0;

      static void addButtons(JPanel pane, int count) {
          for (int i = 1; i <= count; i++)
              pane.add(new JButton("Button " + ++counter));
      }
  }
  ```
  - Demonstrates use of sub-panels with different borders and nested layouts for organized component grouping.

### Evolution of User Interfaces (UIs)
- **Front Panel Switches Interface**
  - Simpler and cheaper alternative to keyboard interfaces.

- **50 Years of WIMPs**
  - **WIMP Definition**: Window, Icons, Menus, Pointer.
  - **Examples:**
    - **Xerox Star (1981)**
      - Early WIMP system with multiple windows and graphical elements.
    - **Windows 2.0 (1987)**
      - Commercial adoption of WIMP, featuring overlapping windows and enhanced GUI elements.

- **Key Concepts about GUIs**
  - **Visual Language**
    - GUIs serve as a medium for user interaction through visual elements.
  - **Skeuomorphism**
    - Design principle where interface objects mimic real-world counterparts.
  - **Desktop Metaphor**
    - Traditional desktop interfaces with icons representing files and applications.
    - Evolving beyond desktop metaphor in modern interfaces.
  - **Post-WIMP Interfaces**
    - Examples include Android and iOS smartphone interfaces.
    - Utilizes touch and multi-touch gestures.
    - Typically 2-dimensional but moving towards 3D UIs.

### Worker Threads
- **Overview**
  - Separate from EDT to handle long-running tasks.
  - Prevents blocking the EDT, ensuring the GUI remains responsive.

- **Usage**
  - Implement using `SwingWorker` or standard Java threading mechanisms.
  - Example Workflow:
    - Initiate worker thread for task.
    - Update GUI upon task completion using EDT.

### JComponent Class
- **Definition**
  - Generic Swing class, ancestor to all Swing components except `JFrame`.
  - Serves as a canvas for custom drawing.

- **Custom Painting**
  - Subclass `JComponent` and override `paintComponent(Graphics g)`.
  - Utilize `Graphics2D` for advanced rendering.

- **Example: ViewSwing**
  ```java
  import javax.swing.SwingUtilities;
  import javax.swing.JFrame;
  import javax.swing.JComponent;
  import java.awt.Color;
  import java.awt.Graphics;
  import java.awt.Graphics2D;

  public class ViewSwing extends JComponent {
      Model model;

      ViewSwing(Model model) {
          this.model = model;
          SwingUtilities.invokeLater(new Runnable() {
              public void run() {
                  createGUI();
              }
          });
      }

      public static void createGUI() {
          JFrame frame = new JFrame();
          frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
          frame.setSize(640, 480);
          frame.add(this);
          repaint();
          frame.setVisible(true);
      }

      /**
       * The paintComponent method is called on the EDT in response
       * to a call to repaint().
       */
      public void paintComponent(Graphics g) {
          Graphics2D g2 = (Graphics2D) g;
          int x = model.getX();
          int y = model.getY();
          int width = model.getWidth();
          int height = model.getHeight();

          g2.drawRect(x, y, width, height);
          g2.setColor(Color.RED);
          g2.fillOval(x, y, width, height);
      }
  }
  ```
  - **Functionality:**
    - Draws a rectangle and a filled red oval based on model data.
    - Ensures custom painting adheres to MVC paradigm.

### Graphics2D Class
- **Features**
  - Enhanced API for sophisticated graphics operations.
  - Methods for drawing shapes, text, and images.

- **Coordinate System**
  - Origin at top-left corner (0,0).
  - X-axis extends rightwards; Y-axis extends downwards.

- **Graphics Context**
  - Current color, font, and other drawing properties.

- **Operations**
  - Execute within `paintComponent()` on EDT.
  - Examples:
    - `g2.drawLine(x1, y1, x2, y2)`
    - `g2.drawRect(x, y, width, height)`
    - `g2.fillOval(x, y, width, height)`
    - `g2.drawString(String s, int x, int y)`
  - Model updates trigger `repaint()`, invoking `paintComponent()` subsequently.

### Factory Pattern in GUI Design
- **Purpose**
  - Streamlines object creation through static methods.

- **Advantages**
  - Reduces complexity by avoiding direct instantiation with `new`.
  - Facilitates object reuse and shared instances.

- **Example Usage:**
  ```java
  Border b1 = BorderFactory.createLineBorder(Color.RED);
  Border b2 = BorderFactory.createTitledBorder("Sub Panel");
  pane1.setBorder(b1);
  pane2.setBorder(b2);
  ```
  - Creates and assigns various borders to panels using `BorderFactory`.

### Evolution of GUIs Beyond WIMPs
- **Post-WIMP Interfaces**
  - Transition to touch-based interactions in mobile devices.
  - Introduction of multi-touch gestures for enhanced user experience.
  - Exploration of 3D user interfaces for more immersive interactions.

- **Future Directions**
  - Development of more intuitive and natural interaction methods.
  - Integration of augmented reality (AR) and virtual reality (VR) in GUIs.
  - Continuous refinement of visual languages to improve usability and accessibility.
### Array Initialization
- **Default Values:**
  - **Integer types:** `0`
  - **Real types:** `0.0`
  - **Reference types:** `null`
- **Compile-time Initialization:**
  - Must occur at the time of declaration.
- **Syntax Examples:**
  - `char[] vowels = { 'a', 'e', 'i', 'o', 'u' };`
  - `int[] days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};`

### TreeTracker Problem
- **Objective:**
  - Create a `TreeTracker` class to generate and manage random `Tree` objects.
- **Requirements:**
  - Generate random species and circumferences.
  - Store `Tree` objects in an array.
  - Print descriptions using the `describe` method.
- **Concepts Illustrated:**
  - Array initialization
  - Pseudo-random number generation
  - Utilizing the `length` field in arrays

### Tree Class
- **Attributes:**
  - `private int serial;`
  - `private double circumference;`
  - `private String species;`
- **Constructor:**
  ```java
  public Tree(int serial, double circumference, String species) {
      this.serial = serial;
      this.circumference = circumference;
      this.species = species;
  }
  ```
- **Methods:**
  - `describe()`: Returns a formatted string describing the tree.
    ```java
    public String describe() {
        return String.format("Tree number %d has a circumference of %.2f and is of species %s.", serial, circumference, species);
    }
    ```
  - `getDiameter()`: Calculates diameter.
    ```java
    public double getDiameter() {
        return circumference / Math.PI;
    }
    ```
  - `getCircumference()`: Returns circumference.
    ```java
    public double getCircumference() {
        return circumference;
    }
    ```

### Random Class
- **Import Statement:**
  ```java
  import java.util.Random;
  ```
- **Declaration:**
  ```java
  Random r = new Random();
  ```
- **Methods:**
  - `r.nextDouble()`: Returns a value in `[0.0, 1.0)`.
  - `r.nextInt(int n)`: Returns a value in `[0, n)`.
  - `r.nextInt()`: Returns any possible integer.

### Solution: TreeTracker
- **Code Structure:**
  ```java
  import java.util.Random;

  public class TreeTracker {
      final static int NUMTREES = 100;

      public static void main(String[] args) {
          Random r = new Random();
          String[] species = { "pine", "elm", "spruce", "oak", "walnut" };

          var trees = new Tree[NUMTREES];

          for (int i = 0; i < trees.length; i++) {
              String specie = species[r.nextInt(species.length)];
              trees[i] = new Tree(i, r.nextDouble() * 100, specie);
          }

          for (int i = 0; i < trees.length; i++) {
              System.out.println(trees[i].describe());
          }
      }
  }
  ```

### Generalizations
- **Methods with Array Parameters:**
  - Example: `int computeSum(int[] a)`
  - Example: `public static void main(String[] args)`
- **Methods Returning Arrays:**
  - Example: `int[] sortIntegers(int[] a)`
  - Example: `int[] computeHistogram()`
- **Array Type Consistency:**
  - An array of type `T[]` contains elements of type `T`.

### Multidimensional Arrays
- **Declaration:**
  ```java
  int[][] matrix = new int[5][10];
  ```
- **Characteristics:**
  - 2D matrix with 5 rows and 10 columns.
  - Elements accessed via `matrix[i][j]`.
  - `matrix.length` is `5`.
  - `matrix[i].length` is `10` for all `i`.

### Ragged Arrays
- **Definition:**
  - 2D arrays where rows can have different lengths.
- **Declaration and Initialization:**
  ```java
  int[][] matrix = new int[5][];
  matrix[0] = new int[7];
  matrix[1] = new int[10];
  matrix[2] = new int[4];
  matrix[3] = new int[6];
  matrix[4] = new int[9];
  ```
- **Characteristics:**
  - `matrix.length` is `5`.
  - `matrix[i].length` varies for each `i`.

### Sum Matrix Problem
- **Objective:**
  - Compute the sum of all elements in a 2D array.
- **Method:**
  ```java
  int computeSum(int[][] matrix) {
      int sum = 0;
      for (int i = 0; i < matrix.length; i++) {
          for (int j = 0; j < matrix[i].length; j++) {
              sum += matrix[i][j];
          }
      }
      return sum;
  }
  ```
- **Note:**
  - Works with ragged arrays.

### The for-each Loop
- **Purpose:**
  - Simplified iteration through arrays and other data structures.
- **Syntax:**
  ```java
  for (int value : bloodPressure) {
      sum += value;
  }
  ```
- **Comparison to Traditional For Loop:**
  ```java
  for (int i = 0; i < bloodPressure.length; i++) {
      sum += bloodPressure[i];
  }
  ```
- **Limitation:**
  - Only allows read-access to each element.

### Varargs
- **Definition:**
  - Variable-length arguments allowing methods to accept zero or more arguments.
- **Syntax:**
  ```java
  public static void func(int... a) {
      // method body
  }
  ```
- **Usage Examples:**
  ```java
  func(100);          // {100}
  func(1, 2, 3, 4);   // {1, 2, 3, 4}
  func();             // {}
  ```
- **Characteristics:**
  - `a` is treated as an `int[]`.
  - Can be combined with other parameters, but varargs must be last.
  - Example:
    ```java
    int nums(int a, float b, double... c)
    ```

### Generic Classes
- **Definition:**
  - Classes parameterized with another class/type.
- **Example:**
  - `ArrayList<E>`
    - Holds elements of type `E`.
- **Constraints:**
  - `E` must be a reference type.
  - Primitive types are not supported.

### ArrayList Class
- **Import Statement:**
  ```java
  import java.util.ArrayList;
  ```
- **Characteristics:**
  - Dynamic array that automatically resizes.
  - Requires type specification upon creation.
- **Initialization Examples:**
  ```java
  ArrayList<String> list = new ArrayList<String>();
  var list = new ArrayList<String>();
  ArrayList<String> list = new ArrayList<>();
  ```

### ArrayList and Wrapper Classes
- **Limitation:**
  - Cannot use primitive types directly (e.g., `ArrayList<int>` is invalid).
- **Solution:**
  - Use wrapper classes (e.g., `ArrayList<Integer>`).
- **Java Handling:**
  - Automatic conversion between wrapper classes and primitives.

### Useful ArrayList Methods
- `add(e)`: Adds `e` to the end of the list.
- `add(i, e)`: Adds `e` at index `i`, shifting elements.
- `contains(e)`: Returns `true` if `e` is in the list.
- `get(i)`: Retrieves the value at index `i`.
- `remove(e)`: Removes `e` from the list.
- `set(i, e)`: Replaces element at index `i` with `e`.
- `size()`: Returns the current number of elements.

### When to Use an ArrayList
- **Use Instead of Arrays When:**
  - The number of elements is unknown.
  - Need dynamic resizing.
  - Utilize methods like `add(i, e)` for inserting elements at specific positions.

### WordList Using ArrayList
- **Class Structure:**
  ```java
  import java.util.Scanner;
  import java.util.ArrayList;

  public class WordList {
      final static int MAXHIST = 50;
      private ArrayList<String> words = new ArrayList<String>();

      public WordList(Scanner in) {
          while (in.hasNext()) {
              words.add(in.next());
          }
      }

      public int getSize() {
          return words.size();
      }

      public int[] computeHistogram() {
          var histogram = new int[MAXHIST];
          for (int i = 0; i < words.size(); i++) {
              histogram[words.get(i).length()]++;
          }
          return histogram;
      }
  }
  ```

### TreeList Class
- **Class Structure:**
  ```java
  import java.util.ArrayList;

  public class TreeList {
      public static void main(String[] args) {
          var forest = new ArrayList<Tree>();

          while (Math.random() < 0.9) {
              Tree t = new Tree((int)(Math.random() * 100), Math.random() * 100, "species"); // Adjust constructor as needed
              System.out.printf("tree has radius %.3f\n", t.getCircumference());
              forest.add(t);
          }

          System.out.printf("list has %d trees:\n", forest.size());
          for (Tree t : forest) {
              System.out.printf("tree with circumference %.3f\n", t.getCircumference());
          }
      }
  }
  ```

### Arrays Class
- **Import Statement:**
  ```java
  import java.util.Arrays;
  ```
- **Utility Methods:**
  - `Arrays.binarySearch(int[] array, int value)`
  - `Arrays.copyOf(double[] array, int length)`
  - `Arrays.copyOfRange(double[] array, int from, int to)`
  - `Arrays.equals(int[] array1, int[] array2)`
  - `Arrays.fill(double[] array, double value)`
  - `Arrays.sort(int[] array)`
  - `Arrays.toString(double[] array)`

### Model Playing Cards Problem
- **Objective:**
  - Create a class to model a deck of playing cards.
- **Features Required:**
  - Draw cards at random.
  - Shuffle the deck.
  - Convert card representations to suit and value strings.

### Representing Cards
- **Suits:**
  - Represented as integers `0-3`.
  - Mappings:
    - `0` - Hearts (H)
    - `1` - Spades (S)
    - `2` - Diamonds (D)
    - `3` - Clubs (C)
- **Values:**
  - Represented as integers `0-12`.
  - Mappings:
    - `0` - Ace (A)
    - `1-9` - Numbers 2-10
    - `10` - Jack (J)
    - `11` - Queen (Q)
    - `12` - King (K)
- **Single Integer Representation:**
  - Formula: `suit * 13 + value`
  - Range: `0-51`
  - Extraction:
    - `suit = card / 13`
    - `value = card % 13`

### Example: Representing a Card
- **Six of Diamonds:**
  - Suit: `2` (Diamonds)
  - Value: `5` (Six)
  - Representation: `2 * 13 + 5 = 31`
  - Extraction:
    - `suit = 31 / 13 = 2 (Diamonds)`
    - `value = 31 % 13 = 5 (Six)`

### Representing a Deck of Cards
- **Initialization:**
  - Use an `int` array with 52 elements.
  - Initial state: `deck[i] = i` for all `i`.
  - Sorted by suits then by value.
- **Drawing a Card:**
  - Generate a random index within the available range.
  - Swap the chosen card with the last available card in the deck.
  - Decrement the count of available cards.
- **Shuffling:**
  - Reset the count of available cards to `52`.

### Initial Deck Representation
- **Array Structure:**
  - `int[] deck = {0, 1, 2, ..., 51};`
- **State:**
  - Each index corresponds to a unique card.
  - `size = 52` indicating all cards are available.

### Drawing a Card at Random
- **Process:**
  1. Generate a random index: `int index = r.nextInt(size);`
  2. Swap `deck[index]` with `deck[size - 1]`.
  3. Decrement `size` by `1`.
- **Example:**
  - Before draw: `size = 52`
  - `r.nextInt(52) -> 5`
  - Swap card at index `5` with card at index `51`.
  - New `size = 51`
### Progression through CS18000
- **Core Background Abstraction Multi-threading**
  1. **Basics** (Ch 1,2)
  2. **Primitives** (Ch 3)
  3. **Selection** (Ch 4)
  4. **Repetition** (Ch 5)
  5. **Methods/Classes** (Ch 8,9)
  6. **Arrays, File I/O, Exceptions** (Ch 6, 20, 12)
  7. **Interfaces, Inheritance** (Ch 10,11)
  8. **Polymorphism** (Ch 17)
  9. **Concurrency** (Ch 13,14)
  10. **Networking I/O** (Ch 21)
  11. **Simple GUI** (Ch 7)
  12. **Complex GUI** (Ch 15)
  13. **Dynamic Data Structures** (Ch 18)
  14. **Recursion** (Ch 19)

### Dynamic Data Structures
- **Dynamic Arrays**
  - **ArrayList**
    - Similar to arrays but can grow dynamically as elements are added.
    - **Implementation Basics**
      - Uses a fixed-size underlying array.
      - Keeps track of the actual number of elements (`size`) vs. array capacity.
      - Provides accessor (`get`) and mutator (`set`) methods to enforce abstraction.
    - **Adding Elements**
      - If `size` exceeds current capacity:
        1. Allocate a new array twice the current size.
        2. Copy existing elements to the new array.
        3. Replace the old array with the new one.
      - Doubling strategy reduces the frequency of resizing operations, optimizing performance.
    - **Methods**
      - `add(String element)`: Adds an element to the end.
      - `set(int index, String element)`: Replaces element at specified index.
      - `get(int index)`: Retrieves element at specified index.
      - `toArray()`: Converts ArrayList to a standard array.
      - `getSize()`: Returns the number of elements.
    - **Limitations**
      - Holds only a single data type (e.g., Strings).
      - Inefficient memory usage due to potential over-allocation.
      - Time-consuming reallocation when resizing.

- **Linked Lists**
  - **Singly-Linked List**
    - Consists of nodes where each node contains a value and a reference (`link`) to the next node.
    - Nodes can be located anywhere in memory; order is maintained through links.
    - **Structure**
      - `head`: Points to the first node.
      - `tail`: Points to the last node (optional for efficient tail operations).
      - `size`: Tracks the number of nodes.
    - **Operations**
      - **Insertion**
        - **At Head**
          1. Create a new node.
          2. Set `newNode.link` to current `head`.
          3. Update `head` to `newNode`.
        - **At Tail**
          1. Create a new node.
          2. If list is empty, set `head` and `tail` to `newNode`.
          3. Else, set `tail.link` to `newNode` and update `tail`.
      - **Deletion**
        - Locate the node to delete, keeping track of the previous node.
        - Update `previous.link` to `current.link`.
        - Reclaim memory of the deleted node.
      - **Searching**
        - Start at `head` and traverse using `link`.
        - Compare each node's value to the search key.
        - Can only traverse in one direction from `head`.
    - **Example Implementation**
      ```java
      public class LinkedList {
          private Node head;
          private Node tail;
          private int size;

          private class Node {
              String value;
              Node link;

              Node(String value) {
                  this.value = value;
                  size++;
              }
          }

          public LinkedList() {
              head = tail = null;
              size = 0;
          }

          public void add(String s) {
              Node n = new Node(s);
              if (head == null) {
                  head = n;
              }
              if (tail != null) {
                  tail.link = n;
              }
              tail = n;
          }

          public int getSize() {
              return size;
          }

          public String[] toArray() {
              String[] array = new String[size];
              int i = 0;
              Node node = head;
              while(node != null) {
                  array[i++] = node.value;
                  node = node.link;
              }
              return array;
          }
      }
      ```
    - **Issues with Version 1**
      - Elements added at `head`, resulting in reverse order in `toArray()`.
      - **Solution**: Introduce `tail` pointer to allow appending at the end.

### Abstract Data Type (ADT)
- **Definition**
  - Describes behavior without specifying implementation.
  - Users interact with methods without knowing underlying details.
  - Enhances flexibility for implementers.

- **Common ADTs**
  - **Stack**
    - **Behavior**: Last In, First Out (LIFO).
    - **Operations**:
      - `push(element)`: Add to top.
      - `pop()`: Remove from top.
      - `isEmpty()`: Check if stack is empty.
    - **Uses**:
      - RPN expression evaluation.
      - JVM's stack for method execution.
      - Undo functionality in applications.
  - **Queue**
    - **Behavior**: First In, First Out (FIFO).
    - **Operations**:
      - `add(element)` or `enqueue(element)`: Add to end.
      - `remove()` or `dequeue()`: Remove from front.
      - `peek()`: View front element.
      - `isEmpty()`: Check if queue is empty.
    - **Uses**:
      - Print job scheduling.
      - CPU task management.
      - Network packet handling.
      - Producer/consumer scenarios.

### Implementing ADTs
- **Stack Implementation**
  - **Using Linked List**
    ```java
    public interface Stack {
        boolean isEmpty();
        void push(int value);
        int pop();
    }

    public class LinkedListStack implements Stack {
        private class Node {
            int value;
            Node link;
        }
        private Node head = null;

        public void push(int x) {
            Node n = new Node();
            n.value = x;
            n.link = head;
            head = n;
        }

        public int pop() {
            if (isEmpty())
                throw new RuntimeException("Can't pop empty stack");
            int value = head.value;
            head = head.link;
            return value;
        }

        public boolean isEmpty() {
            return head == null;
        }
    }
    ```
  - **Using Array**
    - Static array or dynamic array (e.g., ArrayList).
    - Maintain `size` variable.
    - `isEmpty`: `size == 0`
    - `push`: `array[size++] = value`
    - `pop`: `return array[--size]`
    - Include error checks for overflow and underflow.

- **Queue Implementation**
  - **Using Linked List**
    ```java
    public interface Queue {
        boolean isEmpty();
        void add(int value);
        int remove();
        int peek();
    }

    public class LinkedListQueue implements Queue {
        private class Node {
            int value;
            Node link;

            Node(int value) {
                this.value = value;
            }
        }
        private Node head = null;
        private Node tail = null;

        public boolean isEmpty() {
            return head == null;
        }

        public void add(int value) {
            Node node = new Node(value);
            if (isEmpty()) {
                head = tail = node;
            } else {
                tail.link = node;
                tail = node;
            }
        }

        public int remove() {
            if (isEmpty())
                throw new RuntimeException("Can't remove from empty queue");
            int value = head.value;
            head = head.link;
            if (head == null)
                tail = null;
            return value;
        }

        public int peek() {
            if (isEmpty())
                throw new RuntimeException("Can't peek empty queue");
            return head.value;
        }
    }
    ```
  - **Using Array**
    - Utilize circular array or dynamic array.
    - Maintain pointers for front and end.
    - `isEmpty`: Check if front and end pointers indicate empty state.
    - `add`: Insert at end, handle wrap-around.
    - `remove`: Remove from front, handle wrap-around.
    - `peek`: Access front element without removing.

### Reverse Polish Notation (RPN) Evaluation
- **Concept**
  - Expression format where operators follow their operands.
  - Example: `3 5 * 5 - 3 5 + * 2 /` equals `40`.
  - Utilizes stack for computation.

- **Evaluator Implementation**
  ```java
  public class Evaluator {
      public static int evaluate(String s) {
          Stack stack = new LinkedListStack();
          String[] tokens = s.split(" ");
          for (String token : tokens) {
              if (token.matches("\\d+"))
                  stack.push(Integer.parseInt(token));
              else {
                  int op2 = stack.pop();
                  int op1 = stack.pop();
                  switch(token) {
                      case "+": stack.push(op1 + op2); break;
                      case "-": stack.push(op1 - op2); break;
                      case "*": stack.push(op1 * op2); break;
                      case "/": stack.push(op1 / op2); break;
                      default: throw new RuntimeException("unknown operator");
                  }
              }
          }
          return stack.pop();
      }

      public static void main(String[] args) {
          String s = "3 5 * 5 - 3 5 + * 2 /";
          System.out.printf("%s = %d\n", s, evaluate(s));
      }
  }
  ```

### Generic Classes
- **Purpose**
  - Support multiple data types without duplicating code.
  - Use type parameters (`<T>`) to define generic behavior.

- **Implementation Example**
  ```java
  public class ArrayList<T> {
      private T[] values;
      private int size;

      public ArrayList() {
          values = (T[]) new Object[10];
          size = 0;
      }

      public T get(int i) {
          return values[i];
      }

      public void set(int i, T s) {
          values[i] = s;
      }

      public void add(T item) {
          if (size >= values.length)
              reallocate();
          values[size++] = item;
      }

      private void reallocate() {
          T[] newValues = (T[]) new Object[values.length * 2];
          for (int i = 0; i < size; i++)
              newValues[i] = values[i];
          values = newValues;
      }
  }
  ```
- **Usage Examples**
  ```java
  ArrayList<String> list = new ArrayList<String>();
  ArrayList<Integer> numbers = new ArrayList<Integer>();
  ```

### Java Library Examples
- **ArrayList**: Dynamic array implementation.
- **Stack, Queue (interface), Deque (interface)**: Interfaces defining stack and queue behaviors.
- **LinkedList**: Implements `Stack`, `Queue`, and `Deque`.
- **HashMap**: Key-value storage, associative array.

### HashMap
- **Definition**
  - Stores values referenced by keys, similar to a dictionary.
  - **Generic Types**: `HashMap<K, V>`
    - `K`: Type of keys.
    - `V`: Type of values.
- **Usage Example**
  ```java
  HashMap<String, Tree> map = new HashMap<String, Tree>();
  map.put("elm", new Tree("elm", 34.5));
  map.put("maple", new Tree("maple", 14.2));
  Tree t = map.get("elm");
  ```
- **Characteristics**
  - Maps unique keys to corresponding values.
  - Allows efficient retrieval based on keys.

### Summary of Concepts
- **Data Structures**
  - **ArrayList**: Dynamic resizing, array-based storage.
  - **LinkedList**: Node-based, efficient insertions/deletions.
  - **Stack**: LIFO operations, implemented via linked lists or arrays.
  - **Queue**: FIFO operations, implemented via linked lists or arrays.
  - **HashMap**: Key-value associations for efficient data retrieval.
- **Generics**
  - Enable reusable and type-safe data structures.
  - Implemented using type parameters to handle multiple data types.
- **ADTs and Interfaces**
  - Define behaviors without specifying implementations.
  - Provide abstraction, allowing flexibility in underlying implementations.
### Recursion and Recursive Data Structures

#### What is Recursion?
- **Self-reference**: Recursion involves self-referential definitions.
- **Methods**:
  - A method can call itself.
  - *Example*: Fibonacci method.
- **Data Structures**:
  - A data structure can reference itself.
  - *Example*: `LinkedList` Node class.
    ```java
    private class Node {
        String value;
        Node link;
    }
    ```

#### Recursive Problem Solving
- **Approach**:
  - Partially solve a problem and delegate the rest.
  - *Example*: Computing `Fibonacci(n)`:
    - If `n == 0`, return `0`.
    - If `n == 1`, return `1`.
    - Else, compute `Fibonacci(n-1) + Fibonacci(n-2)` by delegating to recursive calls.

#### When Recursion Works for Applications
- **Conditions**:
  - Method calls itself with smaller parameters.
  - Recursive data structures have finite growth.
  - Existence of a base case to ensure finite recursive calls.
- **Suitable Problems**:
  - Can be split into a base case and a recursive case.

### Example Recursive Definitions
- **Fibonacci(n)**
  ```java
  if (n == 0) return 0;
  if (n == 1) return 1;
  else return Fibonacci(n-1) + Fibonacci(n-2);
  ```
- **Factorial(n)**
  ```java
  if (n == 0) return 1;
  else return n * Factorial(n-1);
  ```
- **Power(a, n) for a ≠ 0**
  ```java
  if (a != 0 && n == 0) return 1;
  if (a != 0 && n != 0) return a * Power(a, n-1);

  // Faster algorithm (recursive squaring)
  if (a != 0 && n is even) return Power(a, n/2) * Power(a, n/2);
  if (a != 0 && n is odd) return a * Power(a, (n-1)/2) * Power(a, (n-1)/2);
  ```

### Key Task When Programming Recursion
- **Problem Decomposition**:
  - **Base Case**: Action without further recursion.
  - **Recursive Case**: Same problem with smaller instances.
- **Parameter Reduction**:
  - Recursive calls must use parameters closer to the base case.

### How Recursion is Implemented
- **Call Stack**:
  - Uses a stack to manage nested method calls.
  - Parameters and local variables are pushed onto the stack with each call.
- **Isolation of Calls**:
  - Each recursive call has its own copy of parameters and variables.
- **Method Return**:
  - Upon return, stack content is popped, and control returns to the previous method call.

### Example: Factorial
```java
public class Factorial {
    public static long factorial(long n) {
        if (n == 0)
            return 1;
        else
            return n * factorial(n - 1);
    }

    public static void main(String[] args) {
        for (int n = 0; n <= 20; n++)
            System.out.printf("%3d! = %d \n", n, factorial(n));
    }
}
```
- **Execution Flow**:
  - `factorial(4)` calls `factorial(3)`, which calls `factorial(2)`, and so on until `factorial(0)` returns `1`.
  - The stack unwinds as each call returns its computed value.

### Example: isPalindrome
```java
public static boolean isPalindrome(String s) {
    if (s == null || s.length() <= 1)
        return true;
    char first = s.charAt(0);
    char last = s.charAt(s.length() - 1);
    if (first != last)
        return false;
    String middle = s.substring(1, s.length() - 1);
    return isPalindrome(middle);
}
```
- **Process**:
  - Base case: `s` is `null` or has length ≤ 1.
  - Compare first and last characters.
  - Recursively check the substring excluding first and last characters.

### Example: pow2n
```java
public static long pow2n(long n) {
    if (n == 0)
        return 1;
    else if (n == 1)
        return 2;
    else {
        long t = pow2n(n / 2);
        if (n % 2 == 0)
            return t * t;
        else
            return 2 * t * t;
    }
}
```
- **Optimization**:
  - Uses recursive squaring to reduce the number of multiplications.

### Tower of Hanoi
- **Description**:
  - Three pegs and a tower of `n` disks.
  - Disks are stacked in decreasing size order.
  - Goal: Move all disks from one peg to another.
- **Rules**:
  - Move one disk at a time.
  - No disk can be placed on top of a smaller disk.
- **Recursive Solution**:
  - Move `n-1` disks to auxiliary peg.
  - Move the largest disk to target peg.
  - Move `n-1` disks from auxiliary to target peg.

#### Example: Tower of Hanoi
```java
public class TowerOfHanoi {
    public static void moveDisks(int n, char from, char using, char to) {
        if (n == 1) {
            System.out.printf("move disk from peg %s to peg %s \n", from, to);
        } else {
            moveDisks(n-1, from, to, using);
            moveDisks(1, from, using, to);
            moveDisks(n-1, using, from, to);
        }
    }

    public static void main(String[] args) {
        moveDisks(4, 'A', 'B', 'C');
    }
}
```
- **Execution Steps**:
  - `moveDisks(4, 'A', 'B', 'C')` breaks down into moving 3 disks (`'A'` to `'B'` using `'C'`), moving 1 disk to `'C'`, then moving 3 disks from `'B'` to `'C'` using `'A'`.

### Recursive vs Iterative
- **Advantages of Recursion**:
  - Simpler and more elegant.
- **Disadvantages of Recursion**:
  - Slower due to overhead of multiple calls.
- **Optimization**:
  - **Memoization**: Store results of expensive function calls using structures like `HashMap` to avoid redundant computations.
- **Iterative Solutions**:
  - Always possible but may require managing an explicit stack.
  - Can be more complex and harder to implement.

### Linked List Reminder
- **Structure**:
  - Outer class contains `head` and `tail` nodes.
  - Private nested `Node` class:
    - `String value`
    - `Node link`
- **Empty List**:
  - `head == tail == null`
- **Methods**:
  - `add`: Appends to the end (tail) of the list.

### Linked List Example
```java
public class LinkedList {
    private Node head;
    private Node tail;
    private int size;

    private class Node {
        String value;
        Node link;
    }

    //...
    public String[] toArray() {  // convert list to array
        String[] array = new String[size];
        Node current = head;
        int i = 0;
        while (current != null) {  // iterate through the list
            array[i++] = current.value;
            current = current.link;
        }
        return array;
    }
}
```
- **toArray Method**:
  - Initializes a `String` array of size `size`.
  - Iterates through the linked list, populating the array with node values.

### Think Recursively with Linked Lists
- **Definition**:
  - A linked list is either:
    - Empty (`head` is null).
    - A node with a link to another linked list.
- **Recursive Processing**:
  - If `head` is null, processing is complete.
  - Else, process `head` and recursively call with `head.link`.

### Recursive toArray Implementation
```java
public String[] toArray() {
    String[] array = new String[size];
    fillArray(array, head, 0);
    return array;
}

private void fillArray(String[] array, Node current, int i) {
    if (current == null)
        return;
    array[i++] = current.value;
    fillArray(array, current.link, i);
}
```
- **fillArray Method**:
  - Base case: If `current` is null, return.
  - Assign `current.value` to `array[i]` and increment `i`.
  - Recursively call `fillArray` with `current.link` and updated index `i`.

### Counting Nodes in a Linked List
```java
public int count() {                     // public method
    return count(head);
}

private int count(Node current) {        // internal helper routine
    if (current == null)                 // is this a “real” node?
        return 0;                        // no, then length is 0
    else                                 // yes, +1 for current node
        return 1 + count(current.link);  // recurse on link
}
```
- **count Method**:
  - **Public**: Initiates count with `head`.
  - **Private**:
    - Base case: `current == null` returns `0`.
    - Recursive case: `1 + count(current.link)`.

### Trees
- **Comparison with Linked Lists**:
  - **Linked List**: Linear with one-to-one links.
  - **Tree**: Hierarchical with one-to-many links.
    - Examples: Parent to children, Boss to employees, Directory to files.
- **Uses**:
  - Model hierarchically structured data.
  - Enable efficient searching and sorting.

### Tree Example
- **Structure**:
  - **Root Node**: "on"
  - **Interior Nodes**: "do", "threads"
  - **Leaf Nodes**: "and", "hang", "slender", "what", "fortune", "life"

### Tree Terminology
- **Root Node**: A node with no parents.
- **Leaf Node**: A node with no children.
- **Interior Node**: A node that is neither a root nor a leaf.

### Think Recursively with Trees
- **Definition**:
  - A tree is either:
    - Empty (`root` is null).
    - A node with links to one or more trees.
- **Special Case**:
  - **Binary Tree**: Each node references at most two other trees.

### Binary Search Tree (BST)
- **Definition**: A binary tree with a "key" at each node.
- **Properties**:
  1. Key in left child of root is smaller than key in root.
  2. Key in right child of root is larger than key in root.
  3. Each child is also a binary search tree.
- **Example Structure**:
  - Root: "on"
  - Left Subtree: "do"
    - Left Child: "and"
    - Right Child: "hang"
      - Left: "fortune"
      - Right: "life"
  - Right Subtree: "threads"
    - Left: "slender"
    - Right: "what"
  - **Alphabetical Order**:
    - Lowest: "and"
    - Highest: "what"

### Searching a Binary Search Tree
- **Problem**: Determine if a value exists in the tree.
- **Algorithm**:
  1. **Check Root**:
     - If `null`, return `false`.
     - If equal to target, return `true`.
  2. **Compare Values**:
     - If target < root.key, search left subtree.
     - If target > root.key, search right subtree.
- **Performance**:
  - O(log₂ n) comparisons for balanced BST.
  - Compared to O(n) for linear search in linked lists.

### Adding to a Binary Search Tree
- **Problem**: Insert a new value while maintaining BST properties.
- **Algorithm**:
  1. **Base Case**: If tree is empty, add new `Node`.
  2. **Recursive Insertion**:
     - If value < tree.key, recurse on left subtree.
     - If value > tree.key, recurse on right subtree.
- **Proxy Method**:
  - Handle initial empty tree scenario by updating `root`.

#### Example: Tree Implementation
```java
public class Tree {
    private static class Node {
        String value;
        Node left = null;
        Node right = null;
    }
    private Node root = null;

    // Proxy add
    public void add(String value) {
        root = add(value, root);
    }

    private static Node add(String value, Node tree) {
        if (tree == null) { // base case
            tree = new Node();
            tree.value = value;
        }
        else if (value.compareTo(tree.value) < 0)
            tree.left = add(value, tree.left);
        else if (value.compareTo(tree.value) > 0)
            tree.right = add(value, tree.right);
        return tree;
    }

    // Proxy print
    public void print() {
        print(root);
    }

    private static void print(Node tree) {
        if (tree != null) {
            print(tree.left);
            System.out.println(tree.value);
            print(tree.right);
        }
    }
}
```
- **add Method**:
  - Inserts in the correct subtree based on comparison.
- **print Method**:
  - In-order traversal: left subtree, root, right subtree.

### Traversing a Tree
- **Traversal Orders**:
  1. **In-order**:
     - Visit left subtree.
     - Visit root.
     - Visit right subtree.
  2. **Pre-order**:
     - Visit root.
     - Visit left subtree.
     - Visit right subtree.
  3. **Post-order**:
     - Visit left subtree.
     - Visit right subtree.
     - Visit root.
- **In-order Traversal**:
  - Often used to retrieve BST elements in sorted order.

### Another Use of Recursion: Backtracking
- **Definition**: Solving problems by trial and error, undoing steps upon failure.
- **Requirements**:
  - Problem can be decomposed into a series of steps.
- **Process**:
  1. Try a step.
  2. If successful, move on recursively.
  3. If failure occurs, backtrack and undo the step.
- **Characteristics**:
  - Each recursive call remembers the steps taken to enable undoing if necessary.

### Example: MazeSolver
- **Objective**: Find a path through a maze by exhaustively trying all routes.
- **Valid Path**:
  - Sequence of unit steps (up, down, left, right).
  - Connects entrance to exit via open locations (no walls).

#### Maze Representation
- **Storage**: Plain-text file with rows and columns.
- **Characters**:
  - `Space`: Open space.
  - `Non-space`: Wall.
- **Points**:
  - Start and end locations are predefined.
  - Goal: Mark path with `*` to form a loop-free solution.

#### Example Maze File
```
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         |     |   |   |       |   |
+-+ +-+-+-+-+ + +-+ + + +-+ + +-+-+ +-+
| |     | |     |   | | |   |     |   |
|+ + +-+ + + +-+-+ + + + + + -+ +-+ + |
| | | | | | | |   | | | | |+ + + + + -+
| | | | | | | |   | | | | |+ + + + + +
|   | | |   | | |   | |     |   |     |
+-+-+ + + + + + -+-+ +-+-+ +-+-+ +-+ +
|   | | |       |   |   |   | | |     |
+-+ + + + + + + + + -+ + + +-+-+-+ + +
|   | |       |   |     | | |   |   |
```
- **Coordinates**:
  - Start: `(1, 0)`
  - End: `(rows-2, cols-1)`

#### Solved Maze
```
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+****
|         |     |***|   |*******|   |
+-+*+-+-+-+-+ + +-+ +*+*+-+ +*+-+-+*+-+
| |*****| |     |   |*|*|   |*****|***|
|+ + +-+*+ + +-+-+ + +*+*+ + -+ +-+*+-+*
| | | |*| | | |   | |*|*|       |*|*| |
...
```
- **Marking**: `*` indicates the path from start to end.

### Solution Approach for MazeSolver
1. **Read Maze**:
   - Store as a `char[][]` matrix.
2. **Identify Locations**:
   - Determine start and end coordinates.
3. **Recursive Solve**:
   - Initiate `solve(startRow, startCol)` method.

### Possible Actions to Solve the Maze
- **Directions**:
  - Go left, right, up, down from current position.

### Solve Method Implementation
```java
private boolean solve(int row, int col) {
    // Base case: check if at exit
    if (row == endRow && col == endCol)
        return true;

    // Failure cases: out of bounds, wall, or already part of path
    if (row < 0 || col < 0 || row >= rows || col >= cols || maze[row][col] != ' ')
        return false;

    // Mark the current position
    maze[row][col] = '*';

    // Recursive case: explore adjacent positions
    if (solve(row - 1, col) || solve(row + 1, col) || solve(row, col - 1) || solve(row, col + 1))
        return true;

    // Backtrack: unmark the position
    maze[row][col] = ' ';
    return false;
}
```
- **Steps**:
  1. **Check Exit**: If current `(row, col)` is the end, return `true`.
  2. **Check Validity**: Ensure `(row, col)` is within maze bounds, not a wall, and not already marked.
  3. **Mark Path**: Assign `'*'` to current position.
  4. **Explore Adjacent**: Recursively call `solve` on up, down, left, right positions.
  5. **Backtrack**: If no path found, unmark and return `false`.

### Discuss solve(int row, int col)
- **Multiple Solution Paths**:
  - If multiple paths exist, the method returns on the first successful path found.
- **Optimization Considerations**:
  - Entrance at upper left, exit at lower right could allow ordering recursive calls for efficiency.
- **Multithreading**:
  - Potential to parallelize search.
  - `synchronized` keyword may be required to protect shared resources if using threads.
### Concurrency

#### Time Slicing
- **Early Computing:**
  - Single program execution at a time.
  - Switching programs required manually terminating the current program and starting the next.

- **Multi-tasking Operating Systems (OS):**
  - Create the illusion of multiple programs running simultaneously (e.g., email app, browser, text editor).
  - Achieved through **time slicing**.

- **Time Slicing Mechanics:**
  - **Time Measurement:**
    - 1 second = 1000 milliseconds.
    - Minimum human discernible interval ≈ 100 milliseconds.
  - **Execution Process:**
    - Each program runs for a few tens of milliseconds.
    - OS switches to another task after each time slice.
  - **Perception:**
    - Rapid switching makes multiple programs appear to run concurrently due to human perception limitations.

#### Maintaining the Illusion
- **Impact of Moore’s Law:**
  - **Moore’s Law:** Logic circuit area halves every 18 months.
  - **CMOS Technology:**
    - Smaller circuits operate faster.

- **CPU Speed:**
  - Increased CPU speed maintains the multi-tasking illusion as programs become more complex.

- **Challenges:**
  - **Power Consumption:**
    - Increases with circuit speed.
  - **Heat Generation:**
    - Smaller circuit areas concentrate heat, leading to thermal management issues.

#### Physical Limitations
- **Microprocessor Trends (48 Years Data):**
  - **Transistors:** Continuous increase in number (thousands to billions).
  - **Single-Thread Performance:** Steady growth (SpecINT x 10³).
  - **Frequency (MHz):** Fluctuates with advancements.
  - **Typical Power Consumption (Watts):** Generally increases.
  - **Number of Logical Cores:** Steady rise over years.

- **Current Constraints:**
  - Power and energy limitations are critical in device design, affecting everything from servers to smartphones.

#### Multiple Cores
- **Integration:**
  - Incorporate 2 or more CPU cores on the same chip area, facilitated by Moore’s Law.

- **Performance and Efficiency:**
  - **Computational Capability:**
    - 2 cores at half speed ≈ 1 core at full speed (theoretical; requires software to utilize both cores).
  - **Energy Consumption:**
    - Slower cores use less energy and generate less heat.

- **Modern Devices:**
  - Most laptops and smartphones now feature 4+ cores.

- **Application Management:**
  - Up to the number of available cores (e.g., 4 cores) can run applications simultaneously.
  - Additional applications enter a queue managed by the OS, utilizing time slicing.

#### Threads
- **Utilizing Multiple Cores:**
  - Speed up a single program by dividing it into multiple threads.

- **Thread Definition:**
  - Part of a program that runs concurrently with other threads.

- **Example Scenario:**
  - **Database Search:**
    - Database spread over 3 files.
    - Run 3 threads on 3 cores, each searching a different file.
    - Results in approximately 3x faster execution.

#### Sequential vs. Concurrent
- **Sequential Execution:**
  - Single thread of execution.
  - Single Program Counter (PC) tracks the current instruction.

- **Concurrent Execution:**
  - Multiple threads of execution running simultaneously.
  - Multiple PCs active, each tracking its respective thread.

#### Models of Concurrency
- **Two Primary Models:**
  1. **Shared Memory Architecture (e.g., Java):**
     - Single program with multiple threads.
     - Threads share the same memory space (variables).

  2. **Message Passing:**
     - Communication via messages between separate processes.
     - Typically one process per program.
     - Processes may run on different physical machines.

### Java Threads

#### Thread Class and Runnable Interface
- **Thread Class:**
  - Contains the `run()` method.
  - Allows creation and manipulation of threads.

- **Import Statement:**
  ```java
  import java.lang.*;
  ```

- **Creating Threads:**
  ```java
  Thread t = new Thread();
  Thread t = new Thread(task);
  ```

- **Runnable Interface:**
  ```java
  public interface Runnable {
      void run();
  }
  ```

#### Important Methods
- **t.start():**
  - Starts the thread referenced by `t`.

- **t.join():**
  - Waits for the thread `t` to finish execution.

- **t.run():**
  - Called by `start()` to execute in a new thread.

- **Key Notes:**
  - Do not call `run()` directly; use `start()` to initiate the thread sequence.
  - User defines the `run()` method; `Thread` class invokes it during execution.

#### Three Steps to Create Threads
1. **Implement Runnable Interface:**
   ```java
   public class MyTask implements Runnable {
       public void run() {
           // Task code
       }
   }
   ```

2. **Construct Thread Object:**
   ```java
   Thread t = new Thread(new MyTask());
   ```

3. **Start the Thread:**
   ```java
   t.start();
   ```

#### Example: MyTask
```java
public class MyTask implements Runnable {
    public static void main(String[] args) {
        MyTask m = new MyTask();
        Thread t = new Thread(m);
        t.start();
    }

    public void run() {
        System.out.printf("now in %s\n", Thread.currentThread());
    }
}
```
- **Functionality:**
  - Creates and starts a thread.
  - Prints the current thread’s information.

#### Example: MainThread
```java
public class MainThread {
    public static void main(String[] args) {
        Thread t = Thread.currentThread();
        System.out.printf("main thread = %s\n", t);

        System.out.printf("going to sleep...\n");
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.printf("ah, that was nice\n");
        System.out.printf("letting someone else run\n");
        Thread.yield();
        System.out.printf("back\n");
    }
}
```
- **Functionality:**
  - Retrieves and prints the main thread.
  - Puts the thread to sleep for 5 seconds.
  - After waking, yields execution to allow other threads to run.
  - Resumes execution and prints a message.

### Concurrent Programming and Synchronization

#### Task and Domain Decomposition

##### Using Concurrent Processing
- **Problem Breakdown:**
  - Decompose large problems into smaller, manageable pieces.

- **Decomposition Approaches:**
  1. **Task Decomposition:** Based on the tasks to be performed.
  2. **Domain Decomposition:** Based on the data to be processed.

##### Task Decomposition
- **Process:**
  - Split the main task into multiple subtasks.
  - Each subtask runs different code on its own processor core.

- **Benefits:**
  - **Responsiveness:** Improves system responsiveness by handling different tasks independently.

- **Example:**
  - **GUI and Background Computation:**
    - GUI runs on one core, ensuring it remains responsive.
    - Background computations run on separate cores.

##### Domain Decomposition
- **Process:**
  - Define the domain as the input to be processed.
  - Divide the domain into subdomains.
  - Each subdomain is processed by a separate task on different cores.
  - All tasks run the same code but on different inputs.

- **Benefits:**
  - **Raw Speed:** Enhances processing speed by parallelizing data processing.

##### Examples of Task Decomposition
1. **Updating a Video Game Screen:**
   - Task 1: Process player moves.
   - Task 2: Update the display.
   - Tasks communicate as needed during game execution.

2. **Student Class Registration:**
   - Task 1: Check if the student meets prerequisites.
   - Task 2: Check if the student has an open schedule during class time.
   - Task 3: Check if the class has available seats.
   - Combine results after all tasks complete.

##### Examples of Domain Decomposition
1. **Factoring a Large Number:**
   - Perform trial division up to the square root of the number.
   - Assign different ranges of trial divisors to separate tasks.
   - The first task to find a divisor with zero remainder stops the process.

2. **Finding Words in a Word Search Puzzle:**
   - Divide the word list into subsets.
   - Assign each subset to a separate task.
   - Each task searches the puzzle grid and records any found words.

##### Domain Decomposition Example: Matrix Multiplication
- **Approach:**
  - Compute the matrix product \( A \times B \).
  - Divide the resultant matrix \( C \) into two halves.
  - Assign the top half of \( C \) to Core 1 and the bottom half to Core 2 for parallel computation.

##### Task Decomposition Code Example
```java
public class Model implements Runnable {
    // Keeps track of characters' positions, direction, and speed
    public void run() {
        // Model logic
    }
}

public class View implements Runnable {
    // Updates the GUI with the current positions of characters
    public void run() {
        // View logic
    }
}
```

##### Task Decomposition Example: Game
```java
public class Game {
    public static void main(String[] args) {
        // Thread to track characters' positions, direction, and speed
        Thread data = new Thread(new Model(...));

        // Thread to update the GUI with characters' positions
        Thread gui = new Thread(new View(...));

        // Start the data thread to handle game logic and user input
        data.start();

        // Start the GUI thread to handle visual updates
        gui.start();

        // Additional game logic...
    }
}
```
- **Functionality:**
  - Separates game logic (Model) and GUI updates (View) into distinct threads.
  - Ensures that processing and rendering are handled concurrently for better performance and responsiveness.

### Summary
- **Concurrency** enhances performance and responsiveness by allowing multiple threads or processes to execute simultaneously.
- **Time Slicing** enables multi-tasking by rapidly switching between tasks, creating an illusion of simultaneous execution.
- **Multiple Cores** provide hardware support for concurrency, allowing true parallel execution of threads.
- **Threads** in Java are managed using the `Thread` class and `Runnable` interface, with key methods like `start()`, `join()`, and `run()`.
- **Task Decomposition** and **Domain Decomposition** are two strategies for breaking down problems to leverage concurrent processing effectively.
- **Synchronization** ensures that concurrent threads or processes operate without conflicts, maintaining data integrity and system stability.
### CS18000: Problem Solving and Object-Oriented Programming
#### File I/O and Exception Handling

---

#### Persistence of File Storage
- **RAM Characteristics:**
  - Volatile memory; data is lost when programs crash or systems reboot.
- **File Storage:**
  - Non-volatile; data persists beyond program execution and system reboots.
  - Used to:
    - Recover data after crashes or reboots.
    - Provide input for other programs.
- **File I/O Operations:**
  - Facilitate communication between programs by reading from and writing to files.

---

#### Input and Output Pipes
- **Concept:**
  - Data flows between processes via input and output streams, similar to file I/O.
- **Usage:**
  - Enables chaining of program executions where the output of one program serves as the input to another.

---

#### Files and Java
- **Java Platform Independence:**
  - Java strives to be platform-independent, providing abstractions for files and file systems.
- **File Class:**
  - Represents files and directories.
  - **Limitations:**
    - File names and directory conventions are OS-dependent (e.g., user home directory paths).
    - Complete OS independence is not achievable due to these dependencies.
- **Java File I/O Abstraction Layers:**
  1. **Low-Level I/O:**
     - Byte-oriented data transfer.
     - **Classes:** `FileOutputStream`, `FileInputStream`.
  2. **High-Level I/O:**
     - Handles Java primitive data types.
     - **Classes:** `DataOutputStream`, `DataInputStream`.
  3. **Object I/O:**
     - Manages Java object serialization.
     - **Classes:** `ObjectOutputStream`, `ObjectInputStream`.
- **Data Storage:**
  - All data is ultimately stored as a stream of bytes or bits.

---

#### The Importance of Buffering
- **Purpose:**
  - Enhances I/O efficiency by minimizing physical disk access.
- **Without Buffering:**
  - Every read/write operation may result in a disk access, leading to significant slowdowns with large data volumes.
- **Buffering Mechanism:**
  - OS creates internal arrays in working memory (DRAM) to store data temporarily.
  - **Input Buffering:**
    - Reads more data than immediately needed and retains excess for future read operations.
  - **Output Buffering:**
    - Delays sending data to the disk, allowing multiple writes to be consolidated.
- **Best Practices:**
  - Always close files or flush buffers after operations to ensure data integrity and release system resources.

---

#### The Implementation of Buffering
- **Input Buffer:**
  - Temporarily holds data read from the file, reducing the number of read operations.
- **Output Buffer:**
  - Accumulates data to be written, minimizing write operations to the disk.
- **Resource Management:**
  - Properly managing buffers ensures efficient data processing and system performance.

---

#### Generic File Operations (1)

##### Open
- **Requirement:**
  - Files must be opened before any read or write operations.
- **Modes:**
  - **Reading:** Access file data.
  - **Writing:** Create or overwrite file data.
  - **Both:** Enable reading and writing.
  - **Append:** Add data to the end of the file without overwriting existing content.
- **Functionality:**
  - Establishes buffers and maintains state information for the file within the OS.

##### Read
- **Operation:**
  - Transfers data from the file or input stream to the user process.
- **Method Signatures:**
  - Defined to handle various data types (e.g., `byte`, `int`, `String`, custom objects like `Tree`).

##### Write
- **Operation:**
  - Transfers data from the user process to the file or output stream.
- **Method Signatures:**
  - Defined to handle various data types (e.g., `byte`, `int`, `String`, custom objects like `Tree`).

---

#### Generic File Operations (2)

##### File Position
- **Function:**
  - Sets the current read/write position within the file to a specific byte address.
- **Uses:**
  - **Skipping Data:** Move past unwanted data sections.
  - **Re-reading Data:** Go back to previously read data for additional processing.
  - **Rewinding:** Reset the read/write position to the beginning of the file to start operations anew.

##### Close
- **Purpose:**
  - Flushes any buffered data from the OS to the file, ensuring all data is written.
  - Releases OS resources allocated for managing the file, allowing other processes to access it.

---

#### File I/O Layers in Java
1. **Low-Level I/O:**
   - **Description:** Handles raw byte-oriented data transfer.
   - **Classes:** `FileOutputStream`, `FileInputStream`.
2. **High-Level I/O:**
   - **Description:** Manages Java primitive data types.
   - **Classes:** `DataOutputStream`, `DataInputStream`.
3. **Object I/O:**
   - **Description:** Facilitates serialization and deserialization of Java objects.
   - **Classes:** `ObjectOutputStream`, `ObjectInputStream`.
- **Data Representation:**
  - All data, regardless of type, is stored as a sequence of bytes.

---

#### Example: Low-Level I/O
```java
import java.io.*;

public class LowLevelIO {
    public static void main(String[] args) throws IOException {
        File f = new File("lowlevel");
        FileOutputStream fos = new FileOutputStream(f);
        fos.write(42);
        fos.close();

        FileInputStream fis = new FileInputStream(f);
        int i = fis.read();
        System.out.printf("Read %d \n", i);
        fis.close();
    }
}
```
- **Process:**
  - Creates a file named "lowlevel".
  - Writes the byte value `42` to the file using `FileOutputStream`.
  - Reads the byte value from the file using `FileInputStream`.
  - Outputs the read value to the console.

---

#### Example: High-Level I/O
```java
import java.io.*;

public class HighLevelIO {
    public static void main(String[] args) throws IOException {
        File f = new File("highlevel");
        FileOutputStream fos = new FileOutputStream(f);
        DataOutputStream dos = new DataOutputStream(fos);
        dos.writeInt(1000);
        dos.close();

        FileInputStream fis = new FileInputStream(f);
        DataInputStream dis = new DataInputStream(fis);
        int i = dis.readInt();
        System.out.printf("Read %d \n", i);
        dis.close();
    }
}
```
- **Process:**
  - Creates a file named "highlevel".
  - Writes the integer `1000` to the file using `DataOutputStream` wrapped around `FileOutputStream`.
  - Reads the integer from the file using `DataInputStream` wrapped around `FileInputStream`.
  - Outputs the read value to the console.
- **Notes:**
  - `DataOutputStream` builds upon `FileOutputStream`.
  - `DataInputStream` builds upon `FileInputStream`.

---

#### Tricky Bits
- **Data Tracking:**
  - Maintain careful tracking of the order and types of data written to and read from files.
- **Consistency:**
  - **Write Order Example:** `int`, `long`, `long`, `boolean`, `double`, `float`, `char`.
  - **Read Order Example:** Must follow the same sequence as writing.
- **Potential Issues:**
  - Mismatched data types during read/write operations can lead to unexpected behavior or errors.
  - Example: Reading an `int` when a `double` was written next results in incorrect data interpretation.

---

#### Example: Object I/O (1)
```java
import java.io.*;

public class ObjectIO {
    public static void main(String[] args) throws Exception {
        File f = new File("object");

        FileOutputStream fos = new FileOutputStream(f);
        ObjectOutputStream oos = new ObjectOutputStream(fos);

        Tree tree1 = new Tree(42, "elm");
        oos.writeObject(tree1); // write the object out
        oos.close();

        FileInputStream fis = new FileInputStream(f);
        ObjectInputStream ois = new ObjectInputStream(fis);

        Tree tree2 = (Tree) ois.readObject(); // read the object back
        ois.close();

        System.out.printf("tree1 = %s \n", tree1);
        System.out.printf("tree2 = %s \n", tree2);
    }
}
```
- **Process:**
  - Creates a file named "object".
  - Serializes a `Tree` object (`tree1`) and writes it to the file using `ObjectOutputStream`.
  - Deserializes the `Tree` object (`tree2`) from the file using `ObjectInputStream`.
  - Prints both `tree1` and `tree2` to verify successful serialization and deserialization.
- **Notes:**
  - `ObjectOutputStream` builds upon `FileOutputStream`.
  - `ObjectInputStream` builds upon `FileInputStream`.

---

#### Example: Object I/O (2)
```java
class Tree implements Serializable {
    long circumference;
    String species;

    Tree(long circumference, String species) {
        this.circumference = circumference;
        this.species = species;
    }

    public String toString() {
        return String.format("%x: circumference = %d, species = %s",
                             hashCode(), circumference, species);
    }
}
```
- **Class Details:**
  - **Class Name:** `Tree`.
  - **Implements:** `Serializable` interface to allow object serialization.
- **Fields:**
  - `long circumference;` — Represents the circumference of the tree.
  - `String species;` — Represents the species of the tree.
- **Constructor:**
  - Initializes `circumference` and `species` with provided values.
- **Methods:**
  - `toString()` — Overrides the default method to provide a formatted string containing the object's hash code, circumference, and species.

---

#### Serializable
- **Purpose:**
  - Allows Java objects to be converted into a byte stream for storage or transmission.
- **Requirements:**
  - A class must implement the `Serializable` interface to enable its objects to be serialized.
  - All fields within the class must also be serializable or marked as `transient` to be excluded from serialization.

---

#### File Content Types
- **Categories:**
  1. **Text Files (e.g., `.java`, `.txt`):**
     - Store human-readable, character-based data.
     - Generally platform-independent except for End Of Line (EOL) characters differences.
  2. **Binary Files (e.g., `.class`, `.exe`):**
     - Contain non-human-readable data.
     - Can store any type of data, including media, executables, and serialized objects.
     - Require specific programs or applications to interpret and manipulate the data effectively.

---

#### Writing and Reading Text in Java

##### Writing Text
- **Preferred Class:** `PrintWriter`
  - More platform-independent.
  - Provides convenient methods for writing formatted text.
- **Alternative Class:** `PrintStream`
  - Commonly used for `System.out`.
  - Less favored for file operations compared to `PrintWriter`.

##### Reading Text
- **Classes:**
  - `FileReader` — Reads character files.
  - `BufferedReader` — Buffers characters for efficient reading of text data.
  - `Scanner` — Parses primitive types and strings using regular expressions.
- **Efficiency Note:**
  - `BufferedReader` is more efficient than `FileReader` or `Scanner`, especially when handling large volumes of I/O operations.

---

#### Example: Text I/O (1)
```java
import java.io.*;

public class TextIO {
    public static void main(String[] args) throws IOException {
        File f = new File("textio.txt");

        // Open FileOutputStream in append mode (true)
        FileOutputStream fos = new FileOutputStream(f, true);

        // Use PrintWriter -- similar to PrintStream (like System.out)
        PrintWriter pw = new PrintWriter(fos);

        pw.println("our old friend");
        pw.close();

        // continued...
    }
}
```
- **Process:**
  - Creates or opens `textio.txt` in append mode.
  - Initializes a `PrintWriter` using `FileOutputStream` to write text.
  - Writes the string "our old friend" to the file.
  - Closes the `PrintWriter` to flush and release resources.
- **Notes:**
  - `PrintWriter` provides methods like `println` for writing formatted text easily.

---

#### Example: Text I/O (2)
```java
// ... continued

// Read what we just wrote...
FileReader fr = new FileReader(f);
BufferedReader bfr = new BufferedReader(fr);
while (true) {
    String s = bfr.readLine();
    if (s == null)
        break;
    System.out.println(s);
}
bfr.close();
```
- **Process:**
  - Initializes a `FileReader` and wraps it with a `BufferedReader` for efficient text reading.
  - Continuously reads lines from `textio.txt` until the end of the file (`null`).
  - Prints each read line to the console.
  - Closes the `BufferedReader` to release resources.
- **Notes:**
  - Using `BufferedReader` enhances reading efficiency, especially for large files.

---

### Key Takeaways
- **File I/O in Java:**
  - Structured through different abstraction layers to handle various data types and use cases.
  - Proper management of streams and buffers is crucial for efficient and error-free operations.
- **Serialization:**
  - Enables storing and retrieving complete objects, facilitating data persistence and communication between programs.
- **Text vs. Binary Files:**
  - Understanding the differences is essential for selecting appropriate file handling methods and classes.
- **Best Practices:**
  - Always close streams after operations to ensure data integrity and free system resources.
  - Maintain consistent read/write order and data types to prevent data corruption and runtime errors.

---
### Concurrency and Synchronization
- **Task and Domain Decomposition**
  - **Decomposing Large Problems:**
    - Break down into manageable pieces.
    - Approaches:
      - **Task Decomposition:** Split tasks into multiple subtasks.
      - **Domain Decomposition:** Divide the data domain into subdomains.

### Sequential vs. Concurrent Execution
- **Sequential Execution:**
  - Single thread of execution processing instructions one after another.
  - Single Program Counter (PC) tracking current instruction.
- **Concurrent Execution:**
  - Multiple threads running simultaneously.
  - Multiple PCs, each managing a different thread.

### Threads in Java
- **Thread Class and Runnable Interface:**
  - **Thread Class:**
    - Contains the `run()` method.
    - Allows creation and manipulation of threads.
    - Example:
      ```java
      Thread t = new Thread();
      Thread t = new Thread(task);
      ```
  - **Runnable Interface:**
    - Requires implementing the `run()` method.
      ```java
      public interface Runnable {
          void run();
      }
      ```
- **Important Thread Methods:**
  - `t.start()`: Initiates the thread, causing the `run()` method to execute in a new thread.
  - `t.join()`: Blocks the current thread until thread `t` completes.
  - `t.run()`: Defines the thread's task; internally called by `start()`.

### Creating Threads in Java
**Three Steps to Create Threads:**
1. **Implement Runnable Interface:**
    ```java
    public class MyTask implements Runnable {
        public void run() {
            // Task code
        }
    }
    ```
2. **Instantiate Thread with Runnable Task:**
    ```java
    Thread t = new Thread(new MyTask());
    ```
3. **Start the Thread:**
    ```java
    t.start();
    ```

**Example: MyTask**
```java
public class MyTask implements Runnable {
    public static void main(String[] args) {
        MyTask m = new MyTask();
        Thread t = new Thread(m);
        t.start();
    }

    public void run() {
        System.out.printf("now in %s\n", Thread.currentThread());
    }
}
```

**Example: MainThread**
```java
public class MainThread {
    public static void main(String[] args) {
        Thread t = Thread.currentThread();
        System.out.printf("main thread = %s\n", t);
        System.out.printf("going to sleep...\n");
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.printf("ah, that was nice\n");
        System.out.printf("letting someone else run\n");
        Thread.yield();
        System.out.printf("back\n");
    }
}
```

### Models of Concurrency
- **Shared Memory Architecture (Java):**
  - Single program with multiple threads.
  - Threads share the same memory space, allowing access to shared variables.
- **Message Passing:**
  - Communication between separate processes via messages.
  - Typically one process per program.
  - Processes may run on different physical machines.

### Task and Domain Decomposition
- **Task Decomposition:**
  - Split a task into multiple subtasks, each running different code on separate cores.
  - **Primary Benefit:** Enhanced responsiveness.
    - Example:
      - GUI processing on one thread/core.
      - Background computations on another thread/core.
- **Domain Decomposition:**
  - Divide the input domain into subdomains.
  - Each subdomain is processed by the same code but on different input data across multiple cores.
  - **Primary Benefit:** Increased raw processing speed.

**Examples of Task Decomposition:**
- **Video Game Screen Updates:**
  - One thread handles player movements.
  - Another thread updates the display.
  - Threads communicate as needed.
- **Student Registration:**
  - One thread checks prerequisites.
  - Another thread verifies schedule availability.
  - A third thread checks seat availability.
  - Results are combined after all threads complete.

**Examples of Domain Decomposition:**
- **Factoring a Large Number:**
  - Divide trial divisors into blocks assigned to separate threads.
  - First thread to find a divisor stops the process.
- **Word Search Puzzle:**
  - Split the word list into subsets, each processed by a different thread searching the grid.
- **Matrix Multiplication:**
  - Divide matrix rows or columns across multiple threads to compute different segments simultaneously.

### Synchronization and Race Conditions
- **Unpredictability in Thread Execution:**
  - Threads can be interrupted due to time slicing or higher priority tasks.
  - Threads may execute at different rates, making coordination challenging.
  - Java provides synchronization tools to manage thread coordination.

- **Race Conditions:**
  - Occur when threads interleave execution unpredictably, leading to inconsistent shared data states.
  - Example:
    ```java
    public class RaceCondition implements Runnable {
        private static int counter;

        public static void main(String[] args) {
            counter = 0;
            Thread t1 = new Thread(new RaceCondition());
            Thread t2 = new Thread(new RaceCondition());
            t1.start();
            t2.start();
            try {
                t1.join();
                t2.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.printf("counter = %d\n", counter);
        }

        public void run() {
            for (int i = 0; i < 10000; i++) {
                counter++;
            }
        }
    }
    ```
  - **Issue:** Both threads read, increment, and write back `counter` without synchronization, causing inaccurate final value.

- **Synchronizing Threads:**
  - **Keyword:** `synchronized`
  - **Purpose:** Prevent race conditions by ensuring only one thread accesses the synchronized block at a time.
  - **Syntax:**
    ```java
    synchronized (object) {
        // Modify shared data
    }
    ```
  - **Best Practices:**
    - Use dedicated objects for synchronization (e.g., `private static Object gateKeeper = new Object();`).
    - Avoid using string literals or boxed primitives to prevent unintended locks due to string interning or object pooling.

**Example: NoRaceCondition**
```java
public class NoRaceCondition implements Runnable {
    private static int counter = 0;
    private static Object gateKeeper = new Object();

    public static void main(String[] args) {
        Thread t1 = new Thread(new NoRaceCondition());
        Thread t2 = new Thread(new NoRaceCondition());
        t1.start();
        t2.start();
        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.printf("counter = %d\n", counter);
    }

    public void run() {
        for (int i = 0; i < 10000; i++) {
            synchronized (gateKeeper) {
                counter++;
            }
        }
    }
}
```
- **Solution:** Encapsulate `counter++` within a `synchronized` block using a dedicated `gateKeeper` object to ensure atomicity.

### Advanced Synchronization Techniques
- **Interrupting Threads:**
  - **Method:** `t.interrupt()`
  - **Purpose:** Signals a thread to stop its current operation.
  - **Behavior:**
    - If the thread is waiting (e.g., `sleep()` or `join()`), an `InterruptedException` is thrown.
    - Otherwise, a flag is set, which the thread can check using `Thread.interrupted()` to decide whether to terminate.
  - **Usage Example:**
    ```java
    try {
        t.join();
    } catch (InterruptedException e) {
        // Handle interruption, possibly terminate the thread
    }
    ```

### Thread States
- **Lifecycle of a Java Thread:**
  - **New:** Thread instance created but not started.
  - **Runnable:** Thread started and eligible to run.
  - **Not Runnable:** Thread is blocked, sleeping, or waiting for I/O.
  - **Terminated:** Thread has completed execution and exited the `run()` method.

- **Thread Methods Affecting States:**
  - `t.sleep(n)`: Puts the current thread to sleep for `n` milliseconds, transitioning to Not Runnable.
  - `t.yield()`: Current thread relinquishes the CPU, allowing another thread to run.
  - `t.start()`: Moves the thread from New to Runnable.

- **State Transitions Visualization:**
  - **Start Thread:**
    - **New → Runnable**
  - **Execution:**
    - **Runnable → Running → Not Runnable (e.g., `sleep()`, `wait()`) → Runnable**
  - **Completion:**
    - **Runnable → Terminated**

**Example: Interleave**
```java
public class Interleave implements Runnable {
    private char c;

    public Interleave(char c) {
        this.c = c;
    }

    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.printf("%c", c);
            for (int j = 0; j < 1000; j++)
                Math.hypot(i, j);
        }
        System.out.printf("%c", Character.toUpperCase(c));
    }

    public static void main(String[] args) {
        while (true) {
            Thread t1 = new Thread(new Interleave('a'));
            Thread t2 = new Thread(new Interleave('b'));
            t1.start();
            t2.start();
            try {
                t1.join();
                t2.join();
            } catch (InterruptedException e) { /* Handle exception */ }
            System.out.println();
        }
    }
}
```
- **Behavior:**
  - Continuously creates and starts two threads that interleave 'a' and 'b' characters.
  - Uses `join()` to wait for both threads to finish before repeating.

**Example: FindStudent Using Threads**
```java
public class FindStudent implements Runnable {
    private static Student stu = null;
    private static boolean found = false;
    private static int student;
    private Fileserver fileserver;
    private Student maybe = null;

    public FindStudent(Fileserver f) {
        fileserver = f;
    }

    public Student search(int student) throws StudentNotFoundException {
        this.student = student;
        Thread t1 = new Thread(new FindStudent(fileserver1));
        Thread t2 = new Thread(new FindStudent(fileserver2));
        Thread t3 = new Thread(new FindStudent(fileserver3));
        t1.start();
        t2.start();
        t3.start();
        try {
            t1.join();
            t2.join();
            t3.join();
        } catch (InterruptedException e) { /* Handle exception */ }
        if (found)
            return stu;
        else
            throw new StudentNotFoundException(Integer.toString(student));
    }

    public void run() {
        while (moreToRead(fileserver)) {
            if (found) return;
            // Read next Student object
            maybe = readNextStudent(fileserver);
            if (maybe.getID() == student) {
                stu = maybe;
                found = true;
            }
        }
    }
}
```
- **Functionality:**
  - Searches for a student across multiple file servers using separate threads.
  - Utilizes shared static variables (`stu`, `found`) to manage search state.
  - Threads terminate early if the student is found by any thread.

### Shared Memory Architecture
- **Concurrency Paradigms:**
  - **Message Passing:**
    - Communicate via messages between separate processes.
    - Typically one process per program.
    - Suitable for distributed systems across different machines.
  - **Shared Memory:**
    - Multiple threads within a single program share the same memory space.
    - Allows direct access to shared variables and data structures.
    - Employed in Java's threading model.

### Best Practices for Synchronization
- **Synchronization Block Syntax:**
  ```java
  synchronized (object) {
      // Modify shared data
  }
  ```
- **Choosing Synchronization Objects:**
  - Use a dedicated non-primitive, non-string object.
    - Example:
      ```java
      private static final Object lock = new Object();
      ```
  - Avoid using string literals or boxed primitives (e.g., `Integer.valueOf(42)`) to prevent unintended locking due to object interning or pooling.

### Summary of Key Concepts
- **Threads:** Fundamental units of execution within a program, managed using the `Thread` class and `Runnable` interface.
- **Concurrency Models:** Shared memory (threads within a program) vs. message passing (inter-process communication).
- **Decomposition Strategies:** Task decomposition for responsiveness; domain decomposition for speed.
- **Synchronization:** Prevents race conditions using `synchronized` blocks; crucial for thread-safe operations on shared data.
- **Thread Lifecycle:** Understanding thread states (New, Runnable, Not Runnable, Terminated) aids in effective thread management and synchronization.
- **Race Conditions:** Arise from unsynchronized access to shared variables; resolved by ensuring atomic operations through synchronization mechanisms.
### Exam Instructions
- **Exam Structure**
  - Total Points: 75
  - Question Types: Fill in the blank, short answer, multiple choice, coding
- **Exam Conduct**
  - No looking at others' work
  - No electronic devices allowed
  - Remove hats, jackets, hoodies
  - No notes allowed
  - Write neatly; illegible handwriting results in zero for that question
  - Answers must be within designated boxes
- **Integrity Pledge**
  - Commit to academic honesty
  - Violations lead to academic penalties

---

### Question 1: `printf` with Format Specifiers
- **Variables:**
  - `double x = 3.13301`
  - `int y = 24`
  - `String fun = "This course is fun"`
- **Task:** Print `"This course is fun 3.1 - 24"` using `printf` with format specifiers.
- **Solution:**
  ```java
  System.out.printf("%s %.1f - %d", fun, x, y);
  ```
- **Key Points:**
  - `%s` for String
  - `%.1f` for floating-point with one decimal
  - `%d` for integer

---

### Question 2: `for` Loop with Fibonacci Increments
- **Variable:**
  - `int x`
- **Task:** Write a `for` loop that iterates from `i = 0` to `i <= x` in increments of Fibonacci numbers.
- **Fibonacci Sequence:** 1, 1, 2, 3, 5, 8, …
- **Solution Concept:**
  - Use two variables to track the last two Fibonacci numbers.
  - Update `i` by the next Fibonacci number each iteration.
- **Sample Code:**
  ```java
  for (int i = 0, a = 1, b = 1; i <= x; i += a) {
      // Loop body
      int next = a + b;
      a = b;
      b = next;
  }
  ```

---

### Question 3: String Concatenation with Integers
- **Variables:**
  - `int x`
  - `int y`
- **Task:** Declare and initialize `String values` in the format `x-y` without spaces.
- **Solution:**
  ```java
  String values = x + "-" + y;
  ```

---

### Question 4: Using `substring` to Modify Strings
- **Variables:**
  - `String sOne = "I like coding."`
  - `String sTwo = "Math is easy."`
- **Task:** Print `"Coding is easy."` using `substring`.
- **Solution:**
  ```java
  System.out.println(sOne.substring(7, 13) + " " + sTwo.substring(5));
  ```
- **Explanation:**
  - `sOne.substring(7, 13)` extracts `"coding"`
  - `sTwo.substring(5)` extracts `"is easy."`
  - Concatenate with a space to form `"Coding is easy."`

---

### Question 5: Boolean Initialization Based on Even/Odd
- **Variable:**
  - `int myVar`
- **Task:** Initialize `boolean isEven` to `true` if `myVar` is even, else `false`.
- **Solution:**
  ```java
  boolean isEven = (myVar % 2 == 0);
  ```

---

### Question 6: Type Casting from `double` to `int`
- **Variables:**
  - `double x = 6.25`
  - `double y = 5.81`
- **Task:** Initialize `int myVal` as the sum of `x` and `y`.
- **Solution:**
  ```java
  int myVal = (int) (x + y);
  ```
- **Note:** Casting from `double` to `int` truncates the decimal.

---

### Question 7: `while` Loop with `Scanner`
- **Variable:**
  - `Scanner scan = new Scanner(System.in);`
- **Task:** Declare a `while` loop that continues while `scan` has an integer.
- **Solution:**
  ```java
  while (scan.hasNextInt()) {
      // Loop body
  }
  ```

---

### Question 8: `printf` with Multiple Strings and Newline
- **Variables:**
  - `String one;`
  - `String two;`
  - `String three;`
- **Task:** Print `one`, `two`, `three` separated by spaces and ending with a newline.
- **Solution:**
  ```java
  System.out.printf("%s %s %s%n", one, two, three);
  ```
- **Alternative:** Use `\n` for newline.
  ```java
  System.out.printf("%s %s %s\n", one, two, three);
  ```

---

### Question 9: Constructor for `AccountManager` Class
- **Class Structure:**
  ```java
  public class AccountManager {
      private String userName;
      private double balanceChecking;
      private double balanceSavings;
      private double balanceLoan;
      private boolean checking;
      private boolean savings;
      private boolean loan;
      private static final double LOAN_APR = 10.6;
      private static final double SAVINGS_APY = 2.2;
      // Constructor to be implemented
  }
  ```
- **Task:**
  - Create a public constructor taking `String userName` and `String type`.
  - Set booleans `checking`, `savings`, `loan` based on `type` containing 'C', 'S', 'L'.
  - Initialize all balances to `0.0`.
- **Solution:**
  ```java
  public AccountManager(String userName, String type) {
      this.userName = userName;
      this.balanceChecking = 0.0;
      this.balanceSavings = 0.0;
      this.balanceLoan = 0.0;

      this.checking = type.contains("C");
      this.savings = type.contains("S");
      this.loan = type.contains("L");
  }
  ```
- **Alternative Using `indexOf`:**
  ```java
  public AccountManager(String userName, String type) {
      this.userName = userName;
      this.balanceChecking = 0.0;
      this.balanceSavings = 0.0;
      this.balanceLoan = 0.0;

      this.checking = (type.indexOf('C') != -1);
      this.savings = (type.indexOf('S') != -1);
      this.loan = (type.indexOf('L') != -1);
  }
  ```
- **Examples:**
  - `"CS"` → `checking = true`, `savings = true`, `loan = false`
  - `"CL"` → `checking = true`, `savings = false`, `loan = true`
  - `"CLS"` or `"SLC"` → All booleans `true`

---

### Question 10: `deposit` Method in `AccountManager`
- **Task:**
  - Create `public boolean deposit(double amount, String type)`
  - Check if `type` is valid for the account (`"C"`, `"S"`, `"L"`)
  - If invalid, return `false`
  - For `"C"` or `"S"`, add `amount` to respective balance
  - For `"L"`, subtract `amount` from `balanceLoan` (payment)
  - If resulting balance negative, return `false` and revert
  - Return `true` if balance changed
- **Solution:**
  ```java
  public boolean deposit(double amount, String type) {
      switch (type) {
          case "C":
              if (!checking) return false;
              balanceChecking += amount;
              return true;
          case "S":
              if (!savings) return false;
              balanceSavings += amount;
              return true;
          case "L":
              if (!loan) return false;
              if (balanceLoan - amount < 0) return false;
              balanceLoan -= amount;
              return true;
          default:
              return false;
      }
  }
  ```
- **Key Points:**
  - Validate account type before operation
  - Handle loan payments by decreasing balance
  - Prevent negative balances

---

### Question 11: Main Method for Infinite Scrolling Menu
- **Class Variables:**
  ```java
  private final static String USERNAME_PROMPT = "Enter your username";
  private final static String POST_PROMPT = "Number of posts to view";
  private final static String ERROR_MESSAGE = "Invalid entry";

  private final static String FUNNY_MEME = "Funny meme detected! LOL";
  private final static String SPONSORED_CONTENT = "Sponsored content :(";
  private final static String FRIEND_POST = "Your friend just posted!";
  private final static String OLD_POST = "Oldie but a goodie!";

  private final static String EXIT_MESSAGE = "The end, goodbye!";

  private static int checkPostBrowsed(String username) { /* ... */ }
  private static boolean validateUsername(String username) { /* ... */ }
  ```
- **Task:**
  - Prompt for valid username using `validateUsername()`
  - Prompt for number of posts to view; must be integer > 0
  - Loop to display posts based on `checkPostBrowsed(username)`:
    - Divisible by 3: `FUNNY_MEME`
    - Divisible by 5: `SPONSORED_CONTENT`
    - Not divisible by 2 or 7: `FRIEND_POST`
    - Else: `OLD_POST`
  - Print `EXIT_MESSAGE` after all posts
- **Solution Overview:**
  ```java
  public static void main(String[] args) {
      Scanner scanner = new Scanner(System.in);

      // Get valid username
      String username;
      while (true) {
          System.out.print(USERNAME_PROMPT + ": ");
          username = scanner.nextLine();
          if (validateUsername(username)) break;
          System.out.println(ERROR_MESSAGE);
      }

      // Get valid post count
      int postCount;
      while (true) {
          System.out.print(POST_PROMPT + ": ");
          if (scanner.hasNextInt()) {
              postCount = scanner.nextInt();
              if (postCount > 0) break;
          }
          System.out.println(ERROR_MESSAGE);
          scanner.next(); // Clear invalid input
      }

      // Display posts
      for (int i = 0; i < postCount; i++) {
          int postType = checkPostBrowsed(username);
          if (postType % 3 == 0) {
              System.out.println(FUNNY_MEME);
          } else if (postType % 5 == 0) {
              System.out.println(SPONSORED_CONTENT);
          } else if (postType % 2 != 0 && postType % 7 != 0) {
              System.out.println(FRIEND_POST);
          } else {
              System.out.println(OLD_POST);
          }
      }

      System.out.println(EXIT_MESSAGE);
  }
  ```
- **Key Points:**
  - Input validation loops for username and post count
  - Use of modulus operator to determine post type
  - Ensuring infinite scrolling logic via loops

---

### Question 12: `primeFactorization` Method
- **Task:**
  - Create `public static String primeFactorization(int val)`
  - Return prime factors separated by 'x' without spaces
  - Example: `12` → `"2x2x3"`
- **Solution:**
  ```java
  public static String primeFactorization(int val) {
      StringBuilder result = new StringBuilder();

      // Factor out 2s
      while (val % 2 == 0) {
          result.append("2x");
          val /= 2;
      }

      // Factor out odd primes
      for (int i = 3; i <= Math.sqrt(val); i += 2) {
          while (val % i == 0) {
              result.append(i).append("x");
              val /= i;
          }
      }

      // If remaining val is a prime
      if (val > 2) {
          result.append(val);
      } else {
          // Remove trailing 'x'
          if (result.length() > 0 && result.charAt(result.length() - 1) == 'x') {
              result.setLength(result.length() - 1);
          }
      }

      return result.toString();
  }
  ```
- **Key Points:**
  - Use `StringBuilder` for efficient string concatenation
  - Handle multiple factors of the same prime
  - Check up to `sqrt(val)` for factors
  - Ensure no trailing 'x' in the result

---

### Question 13: Main Method to Find Numbers Equal to Sum of Factorials of Digits
- **Task:**
  - Find and print all numbers < 10,000 where the number equals the sum of the factorials of its digits
  - Example: `145` because `1! + 4! + 5! = 145`
- **Solution Overview:**
  ```java
  public static void main(String[] args) {
      for (int i = 1; i < 10000; i++) {
          int sumOfFactorials = 0;
          int number = i;

          while (number > 0) {
              int digit = number % 10;
              int factorial = 1;
              for (int j = 1; j <= digit; j++) {
                  factorial *= j;
              }
              sumOfFactorials += factorial;
              number /= 10;
          }

          if (sumOfFactorials == i) {
              System.out.println(i);
          }
      }
  }
  ```
- **Known Numbers:**
  - `1, 2, 145, 40585` (within the range < 10,000 only `1, 2, 145`)
- **Optimization Tips:**
  - Precompute factorials of digits `0-9`
  - Reduce repeated factorial calculations

---

### Question 14: Maximum Size of Signed Binary Value
- **Question:** The maximum size of any signed binary value of length `n` can be expressed in terms of `n` as?
- **Answer:** \( 2^{n-1} - 1 \)
- **Explanation:**
  - In two's complement, one bit is for sign.
  - Maximum positive value: \( 2^{n-1} - 1 \)

---

### Question 15: Minimum Size of Signed Binary Value
- **Question:** The minimum size of any signed binary value of length `n` can be expressed in terms of `n` as?
- **Answer:** \( -2^{n-1} \)
- **Explanation:**
  - In two's complement, minimum negative value: \( -2^{n-1} \)

---

### Question 16: Choosing `do-while` Loop Over `for` or `while`
- **Question:** In what instance might you choose to use a `do-while` loop over a `for` or a `while` loop?
- **Answer:** When you need the loop to execute at least once regardless of the condition.

---

### Question 17: Compile and Run Java Program Using Command Line
- **Task:** Using only command line inputs, compile and run `MyFile.java`
- **Steps:**
  1. **Compile:**
     ```bash
     javac MyFile.java
     ```
  2. **Run:**
     ```bash
     java MyFile
     ```

---

### Question 18: Convert Integer `22` to Binary (Two's Complement)
- **Question:** Convert `22` to binary using Two's Complement Representation.
- **Answer:** `00010110`
- **Explanation:**
  - `22` in binary: `10110`
  - As 8 bits: `00010110`

---

### Question 19: Convert Integer `-29` to Binary (Two's Complement)
- **Question:** Convert `-29` to binary using Two's Complement Representation (8 bits).
- **Answer:** `11100011`
- **Steps:**
  1. **Positive `29`:** `00011101`
  2. **Invert Bits:** `11100010`
  3. **Add 1:** `11100011`

---

### Question 20: `for` Loops Termination
- **Question:** True or False: `for` loops will always terminate.
- **Answer:** **False**
- **Explanation:**
  - Example of non-terminating `for` loop:
    ```java
    for(;;) { }
    ```
  - Equivalent to `while(true)`

---

### Additional Notes
- **Two's Complement:**
  - Most common method for representing signed integers in binary
  - Positive numbers: Regular binary
  - Negative numbers: Invert bits and add 1
- **Loop Constructs:**
  - `for` loops: Best when number of iterations is known
  - `while` loops: Best when the condition is checked before the loop
  - `do-while` loops: Ensure the loop runs at least once
- **String Formatting:**
  - Use `printf` for formatted output
  - Understand format specifiers for different data types
- **Prime Factorization:**
  - Efficiently factorizing by checking up to √n
  - Handling multiple occurrences of prime factors
- **Account Management Logic:**
  - Constructors should initialize all relevant fields
  - Methods should include validation and error handling

---
**Repetition**

- **Concepts**
  - Decision-making: Execute one statement or another based on conditions.
  - Previous problems used fixed inputs or a small number of values.
  - Next step: Perform repetitive actions.
  - **Two approaches to repetition:**
    - Perform the same operation on different data.
    - Accumulate information over a set of data.

- **Repetition Concept**
  - **Components:**
    - **Body:** Code that is repeatedly executed.
    - **Condition:** Boolean expression that determines when to stop the loop.
  - **Requirements:**
    - The state of the computation must change with each iteration to ensure meaningful repetition and avoid wasting time.

**Forms of Iteration**

- **Indefinite Iteration**
  - Example: `while (notDone == TRUE)`
  - No advance knowledge of the number of iterations.

- **Definite Iteration**
  - Example: Loop a specific number of times using a counter.
  - Controlled by a counter, size, or limit.

**The `while` Loop**

```java
while (boolean-expression) {
    statements; // while body
} // end of while body
next_statement; // first statement after while body
```

- **Execution Steps:**
  1. Evaluate `boolean-expression`.
  2. If `TRUE`, execute `statements`; else, skip to `next_statement`.
  3. After executing the body, return to evaluate `boolean-expression` again.

**Problem: Summer**

- **Task:** Read a sequence of integers from standard input and compute their sum.
- **Challenges:**
  - Determine when to stop reading input.
  - Accumulate the sum.
  - Count the number of values read.

**Solution: Summer**

```java
import java.util.Scanner;

public class Summer {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int number;  // Number that is input
        int sum = 0; // Sum of values
        int c = 0;   // Count of values read

        while (in.hasNextInt()) {
            number = in.nextInt();
            c = c + 1;
            sum = sum + number;
        }

        System.out.printf("Sum of %d values is %d\n", c, sum);
    }
}
```

**Problem: Palindrome**

- **Objective:** Implement `boolean isPalindrome(String s)` in class `Palindrome` to check if a string is a palindrome (reads the same backward as forward).
- **Approach:** Use a `while` loop.

**Strategy: Palindrome**

1. **Initial Check:**
   - If `s` is `null` or `s.length() <= 1`, return `TRUE`.

2. **Main Loop:**
   - While `s.length() > 1`:
     - Compare the first and last characters.
     - If they differ, return `FALSE`.
     - Strip off the first and last characters from `s`.
     - Continue the loop to check the next pair of characters.

3. **Conclusion:**
   - If the loop completes without finding mismatched characters, return `TRUE`.

- **Test Inputs:**
  - `"level"` → `true`
  - `"henway"` → `false`
  - `"henweh"` → `false`
  - `"x"`, `"aba"`, `"abba"` → `true`
  - `""` (empty string) → `true`
  - `null` → `true`

**Solution: Palindrome**

```java
public class Palindrome {
    boolean isPalindrome(String s) {
        if (s == null || s.length() <= 1)
            return true;

        while (s.length() > 1) {
            char first = s.charAt(0);
            char last = s.charAt(s.length() - 1);
            if (first != last)
                return false;
            s = s.substring(1, s.length() - 1);
        }
        return true;
    }
}
```

**Solution: PalindromeTest**

```java
import junit.framework.TestCase;

public class PalindromeTest extends TestCase {
    public void testIsPalindrome() {
        Palindrome p = new Palindrome();
        assertEquals(true, p.isPalindrome(""));
        assertEquals(true, p.isPalindrome(null));
        assertEquals(true, p.isPalindrome("x"));
        assertEquals(true, p.isPalindrome("xx"));
        assertEquals(false, p.isPalindrome("xy"));
        assertEquals(true, p.isPalindrome("level"));
        assertEquals(false, p.isPalindrome("henway"));
        assertEquals(true, p.isPalindrome("racecar"));
    }
}
```

**Problem: Reverse**

- **Objective:** Add a method `String reverse(String s)` to the `Palindrome` class.
- **Modification:** Update `isPalindrome` to use the `reverse` method.

```java
boolean isPalindrome(String s) {
    return s.equals(reverse(s));
}

// Example implementation of reverse
String reverse(String s) {
    String reversed = "";
    for (int i = s.length() - 1; i >= 0; i--) {
        reversed += s.charAt(i);
    }
    return reversed;
}
```

**Continue Statement**

- **Usage Example:**

```java
while (in.hasNext()) {
    word = in.next();
    if (word.length() != 4)
        count = count + 1;
}
```

- **Equivalent Using `continue`:**

```java
while (in.hasNext()) {
    word = in.next();
    if (word.length() == 4)
        continue;
    else
        count = count + 1;
}
```

**Break Statement**

- **Usage Example:**

```java
while (in.hasNext()) {
    word = in.next();
    if (word.length() == 4)
        break;
    else
        count = count + 1;
}
```

**Pro Tip: Compound Assignment**

- **Common Assignments:**

    ```java
    x = x + y;
    a = a - b;
    s = s + "\n"; // s is a string
    ```

- **Using Compound Assignments:**

    ```java
    x += y;
    a -= b;
    s += "\n";
    ```

- **Applicability:** Available for all (or most) binary operators.

**Pro Tip 2: Increment/Decrement Operators**

- **Simplifying Common Cases:**

    ```java
    x = x + 1;
    a = a - 1;
    ```

- **Using Increment/Decrement Operators:**

    ```java
    x++;
    a--;
    ```

- **Other Forms:**

    ```java
    ++x;
    --a;
    ```

**Post- and Pre-Increment/Decrement**

- **Post-Increment (`x++`):**
  - Increments `x` by one.
  - Expression value is original `x`.
  - **Example:**
    ```java
    int x = 0;
    System.out.println(x++); // Outputs: 0
    System.out.println(x);   // Outputs: 1
    ```

- **Pre-Increment (`++x`):**
  - Increments `x` by one.
  - Expression value is the new `x`.
  - **Example:**
    ```java
    int x = 0;
    System.out.println(++x); // Outputs: 1
    System.out.println(x);   // Outputs: 1
    ```

- **Common Idioms:**
  - `x++` and `x--` are widely used.
  - Avoid complex expressions with multiple pre- and post-increments to prevent confusion.

**Problem: WhileDefinite**

- **Task:** Print “hello” 10 times using a `while` loop.
- **Objective:** Illustrate using a `while` loop for definite iteration.

**Solution: WhileDefinite**

```java
public class WhileDefinite {
    public static void main(String[] args) {
        int n = 0;
        while (n < 10) {
            System.out.printf("hello (#%d)\n", n);
            n++;
        }
    }
}
```

**The Loop Parts**

- **Components of Loops:**
  - **Initialization:** Setting the initial state before the loop starts.
  - **Test:** Condition checked before each iteration to determine if the loop should continue.
  - **Update:** Modifying the state to eventually terminate the loop.

- **Example Comparison:**

    ```java
    public class WhileDefinite {
        public static void main(String[] args) {
            int n = 0;
            while (n < 10) {
                System.out.printf("hello (#%d)\n", n);
                n++;
            }

            for (int n = 0; n < 10; n++)
                System.out.printf("hello (#%d)\n", n);
        }
    }
    ```

**Definite Iteration: `for` Loop**

- **General Form:**

    ```java
    for (e1; e2; e3) {
        statements;
    }
    ```

- **Sequence of Actions:**
  1. Evaluate `e1` (once only).
  2. Evaluate `e2`. If `TRUE`, execute loop body.
  3. Evaluate `e3`.
  4. Return to step 2.

- **Components:**
  - **`e1` (Initialization):**
    - Evaluated once at loop start.
    - Can be omitted.
    - Can include local declarations and initializations, possibly multiple separated by commas.

  - **`e2` (Termination):**
    - Boolean expression evaluated before every iteration.
    - If `FALSE`, loop terminates and control moves to the statement following the loop body.

  - **`e3` (Update/Increment):**
    - Can be omitted.
    - Can include an expression or multiple expressions separated by commas.

**Common Practices**

- **Looping `n` Times:**

    ```java
    for (int i = 0; i < n; i++) {
        statements;
    }
    ```
  - **Reason:** Works well with 0-based indexing in strings and arrays.

- **Example: Print Characters in a String `s`:**

    ```java
    String s = "hello there world";
    for (int i = 0; i < s.length(); i++)
        System.out.printf("s.charAt(%d) = '%c'\n", i, s.charAt(i));
    ```

**Infinite Loop Example**

- **Syntax for Infinite Loop Using `for`:**

    ```java
    for ( ; ; ) {
        // Infinite loop body
        // Example: System.out.println("XINU is not UNIX is not UNIX is not UNIX");
    }
    ```

**Enhanced `for` Loop Example**

- **Purpose:** Iterate through elements of collections and arrays with improved readability.

- **Declare an Array:**

    ```java
    int[] numbers = {1,2,3,4,5,6,7,8,9,10};
    ```

- **Example Class Using Enhanced `for` Loop:**

    ```java
    class EnhancedForDemo {
        public static void main(String[] args){
            int[] numbers = {1,2,3,4,5,6,7,8,9,10};
            for (int item : numbers) {
                System.out.println("Count is: " + item);
            }
        }
    }
    ```

- **Recommendation:** Oracle suggests using the enhanced `for` loop whenever possible for enhanced readability.
## CS18000: Problem Solving and Object-Oriented Programming
### Network I/O

### Communication Among Computers
- **Early Communication:**
  - Computers initially couldn't communicate directly.
  - Data transfer required physical transportation of files via external devices from Computer A to Computer B.
- **Development in the 1960s:**
  - Researchers from universities, industry, and military began developing direct communication methods.
  - Concept introduced: Using wires to transmit packets of bits between computers.
  - Evolution to include wireless transmission methods.

### Computer Networks
- **Building-Level Networks:**
  - Multiple computers within a single building connected via a network, enabling intra-building data sharing.
- **Inter-Building Networks:**
  - Networks across different buildings interconnected to form a network of networks.
- **Global Networks:**
  - Development of worldwide interconnected networks, culminating in the Internet.
- **Key Contributor:**
  - Purdue CS Professor Douglas Comer contributed significantly to Internet development.

### ARPANET: Predecessor to the Internet
- **Overview:**
  - ARPANET was an early network that laid the foundation for the modern Internet.
  - Connected various research institutions and computer facilities.
- **Network Topology:**
  - Nodes represented by research institutions such as Stanford, UCLA, MIT.
  - Communication links connected these nodes, forming a robust early network structure.

### Key Networking Concepts
#### Internet Protocol (IP)
- **Function:**
  - Uniquely identifies hosts (servers, workstations, laptops, etc.) on a network.
- **Example Address:** `128.10.2.21`
- **Types:**
  - **IPv4:** Dotted-decimal notation (e.g., `128.10.9.143`).
  - **IPv6:** 32 hexadecimal digits (e.g., `0123:4567:89ab:cdef:0123:4567:89ab:cdef`).
- **Address Translation:**
  - Firewalls may translate public IP addresses to internal ones (e.g., PAL).

#### Domain Name System (DNS)
- **Function:**
  - Maps human-readable domain names to IP addresses.
- **Example:**
  - `data.cs.purdue.edu` → `128.10.2.13`

#### Transmission Control Protocol (TCP)
- **Function:**
  - Identifies ports on hosts for network connections between processes.
  - Provides communication rules to handle issues like packet loss and rearrangement.
- **Key Features:**
  - Ensures reliable data transmission by sequencing packets and handling retransmissions.
- **Socket Definition:**
  - Combination of IP address and TCP port.
  - Enables a network connection between two processes on different computers.

### Client-Server Architecture
- **Server:**
  - A process that waits for client connections.
- **Client:**
  - A process that initiates a connection to a server.
- **Dual Roles:**
  - A single process can act as both a client and a server at different times.
- **Flexibility:**
  - Any computer can run both client and server processes simultaneously.
- **Data Exchange:**
  - Once connected, client and server can read and write data asynchronously, functioning as a bi-directional byte pipe.

### Use of Sockets
- **Communication Medium:**
  - Clients and servers utilize sockets to communicate.
- **Socket Components:**
  - **IP Address:**
    - Uniquely identifies a computer on the Internet.
    - Public IPs are globally unique.
    - Represented in IPv4 (dotted-decimal) or IPv6 formats.
  - **Port Number:**
    - Range: 0-65535 (16 bits).
    - Lower numbers are reserved for standard services.
- **Analogy:**
  - IP address is like a street name, and port number is like a house number.
- **Firewall Functionality:**
  - Firewalls may perform Network Address Translation (NAT) to map internal addresses to external ones.

### Objects and Networking in Java
- **Java Object Serialization:**
  - Java objects can be serialized to and deserialized from files.
  - Similarly, they can be exchanged over network connections.
- **Streams for Object Exchange:**
  - **ObjectOutputStream:** Used to serialize objects to an output stream.
    - Generates a header that must be read by the receiving end.
    - Requires `flush()` after creation to avoid blocking.
  - **ObjectInputStream:** Used to deserialize objects from an input stream.
- **Blocking:**
  - Occurs when code execution is halted due to waiting for data transmission or resource availability.
  - Proper management of streams and threads is essential to prevent blocking during network operations.

### Client-Server Timeline with Object Streams
1. **Server Process:**
   - Opens a `ServerSocket` and blocks, waiting for a client connection.
2. **Client Process:**
   - Opens a `Socket` to connect to the server.
3. **Connection Establishment:**
   - Server accepts the connection and establishes an `ObjectOutputStream`.
   - Server sends a header to the client and flushes the stream.
4. **Client Setup:**
   - Client receives the header from the server via `ObjectInputStream`.
   - Client opens its `ObjectOutputStream`, sends its header, and flushes.
5. **Object Exchange:**
   - Both client and server exchange serialized objects in a predefined order.
   - Communication continues asynchronously until termination.

### Java Networking Classes
#### Socket Class
- **Purpose:**
  - Models a TCP/IP socket for network communication.
- **Usage by Client:**
  - Identifies the server using IP address (or DNS name) and port number.
  - Example: `new Socket("pc.cs.purdue.edu", 12190);`
- **Usage by Server:**
  - Identifies the connected client after accepting a connection.
- **Communication Streams:**
  - `getOutputStream()`: For sending data.
  - `getInputStream()`: For receiving data.

#### ServerSocket Class
- **Purpose:**
  - Used by servers to listen for incoming client connections.
- **Constructor:**
  - Specifies the TCP port number.
  - Example: `ServerSocket ss = new ServerSocket(4242);`
- **Accept Method:**
  - `accept()`: Blocks and waits for a client to connect.
  - Returns a `Socket` object upon successful connection.

### Example Implementations
#### Object Server Example
```java
import java.io.*;
import java.net.*;

public class Server {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        // Create server socket on port 4242
        ServerSocket serverSocket = new ServerSocket(4242);

        // Wait for client to connect
        Socket socket = serverSocket.accept();

        // Open ObjectOutputStream and send header
        ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
        oos.flush(); // Ensure header is sent

        // Open ObjectInputStream
        ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());

        // Send object to client
        String s1 = "hello there";
        oos.writeObject(s1);
        oos.flush();
        System.out.printf("sent to client: %s \n", s1);

        // Receive object from client
        String s2 = (String) ois.readObject();
        System.out.printf("received from client: %s \n", s2);

        // Close streams
        oos.close();
        ois.close();
    }
}
```
- **Functionality:**
  - Listens on port 4242.
  - Accepts a client connection.
  - Sends a greeting message to the client.
  - Receives a response from the client.
  - Closes the connection.

#### Object Client Example
```java
import java.io.*;
import java.net.*;

public class Client {
    public static void main(String[] args) throws UnknownHostException, IOException, ClassNotFoundException {
        // Connect to server at data.cs.purdue.edu on port 4242
        Socket socket = new Socket("data.cs.purdue.edu", 4242);

        // Open ObjectInputStream to receive header from server
        ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());

        // Open ObjectOutputStream and send header
        ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
        oos.flush(); // Ensure header is sent

        // Receive object from server
        String s1 = (String) ois.readObject();
        System.out.printf("received from server: %s \n", s1);

        // Send response to server
        String s2 = s1.toUpperCase();
        oos.writeObject(s2);
        oos.flush();
        System.out.printf("sent to server: %s \n", s2);

        // Close streams
        oos.close();
        ois.close();
    }
}
```
- **Functionality:**
  - Connects to the server at `data.cs.purdue.edu` on port 4242.
  - Receives a greeting message from the server.
  - Sends an uppercase version of the received message back to the server.
  - Closes the connection.

### Client-Server with Threads
- **Multiple Clients:**
  - A single server often handles multiple client connections simultaneously.
- **Thread Management:**
  - To prevent blocking, the server spawns a separate thread for each client connection.
- **Bidirectional Threads:**
  - Both client and server can create separate threads for reading and writing to enhance communication efficiency.

### Example: Echo Server
- **Purpose:**
  - A simple server that echoes back any received messages from clients.
- **Features:**
  - Accepts multiple client connections.
  - Spawns a dedicated thread for each client.
  - Reads lines from clients, logs them, and sends the same lines back.
- **Use Case:**
  - Useful for debugging network issues and verifying communication protocols.

#### Echo Server Implementation
```java
import java.io.IOException;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Scanner;

public class EchoServer implements Runnable {
    Socket socket;

    public EchoServer(Socket socket) {
        this.socket = socket;
    }

    // Run method for the thread
    public void run() {
        System.out.printf("connection received from %s \n", socket);
        try {
            // Initialize PrintWriter and Scanner for communication
            PrintWriter pw = new PrintWriter(socket.getOutputStream());
            Scanner in = new Scanner(socket.getInputStream());

            // Echo loop
            while (in.hasNextLine()) {
                String line = in.nextLine();
                System.out.printf("%s says: %s \n", socket, line);
                pw.printf("echo: %s \n", line);
                pw.flush();
            }

            // Close connections
            pw.close();
            in.close();
        } catch(IOException e) {
            e.printStackTrace();
        }
    }

    // Main method to start the server
    public static void main(String[] args) throws IOException {
        // Allocate server socket on port 4343
        ServerSocket serverSocket = new ServerSocket(4343);
        System.out.printf("socket open, waiting for connections on %s \n", serverSocket);

        // Infinite loop to accept multiple clients
        while (true) {
            Socket socket = serverSocket.accept();
            EchoServer server = new EchoServer(socket);
            new Thread(server).start();
        }
    }
}
```
- **Components:**
  - **EchoServer Class:** Implements `Runnable` to allow concurrent handling of clients.
  - **Constructor:** Accepts a client `Socket`.
  - **Run Method:**
    - Logs the connection.
    - Reads input from the client.
    - Echoes the received lines back to the client.
    - Ensures data is flushed to prevent blocking.
    - Closes streams upon completion.
  - **Main Method:**
    - Initializes `ServerSocket` on port 4343.
    - Continuously accepts new client connections.
    - Starts a new thread for each connected client.

### Network Communication in Java
- **Standard I/O Classes:**
  - Java provides low-level, high-level, object, and text I/O classes for handling data.
- **Network Abstractions:**
  - **ServerSocket:** Listens for incoming client connections.
  - **Socket:** Represents a TCP connection between two endpoints, identified by IP address and port.
- **Thread Utilization:**
  - Enhances responsiveness and prevents blocking by handling each client connection in a separate thread.
  - Allows simultaneous communication with multiple clients.

---

## Key Concepts Summary
- **IP Address & TCP Port:** Fundamental identifiers for network communication, forming the basis of sockets.
- **Client-Server Model:** Core architecture where servers listen for connections and clients initiate them.
- **Sockets:** Essential for establishing and managing network connections in Java, encapsulating IP and port details.
- **Object Streams:** Facilitate the exchange of serialized Java objects over network connections, requiring careful management of headers and flushing to prevent blocking.
- **Multithreading in Servers:** Critical for handling multiple clients efficiently without blocking, enabling scalable and responsive network applications.
- **Echo Server Example:** Demonstrates the practical application of sockets, object streams, and multithreading to create a functional network service.

---

## Practical Tips
- **Stream Initialization Order:** Always open `ObjectOutputStream` before `ObjectInputStream` on both client and server to prevent deadlocks.
- **Flushing Streams:** After creating `ObjectOutputStream`, immediately call `flush()` to send header data and avoid blocking the input stream.
- **Thread Safety:** Ensure that shared resources are properly synchronized when handling multiple threads to prevent race conditions.
- **Exception Handling:** Always handle `IOException` and other potential exceptions to maintain robust network communication.
- **Resource Management:** Close all streams and sockets in a `finally` block or use try-with-resources to ensure resources are freed even if errors occur.

---

## Exam Preparation Focus
- **Understand the Client-Server Lifecycle:** From socket creation, connection establishment, data exchange, to termination.
- **Be Able to Implement Basic Network Programs in Java:** Including server and client applications using `ServerSocket` and `Socket`.
- **Grasp Key Networking Protocols and Concepts:** Such as IP, DNS, TCP, sockets, and how they interact in network communication.
- **Multithreading Concepts in Networking:** How threads are used to handle multiple clients and the importance of avoiding blocking.
- **Serialization Mechanisms in Java:** How objects are transmitted over networks, including the use of `ObjectOutputStream` and `ObjectInputStream`.

---

## Sample Questions to Practice
1. **Explain the client-server model and how it operates in a networked application.**
2. **Describe the role of IP addresses and port numbers in establishing a network connection.**
3. **Write a simple Java server using `ServerSocket` that can accept a single client connection and exchange messages.**
4. **What are the potential issues when sending objects over a network, and how does Java address them?**
5. **How does multithreading improve the performance and scalability of a server application? Provide an example.**
6. **Describe the sequence of steps involved in establishing a connection between a Java client and server using sockets.**
7. **What is the purpose of calling `flush()` on an `ObjectOutputStream`, and what might happen if it is omitted?**
8. **Compare and contrast IPv4 and IPv6 addressing schemes. Why was IPv6 introduced?**
9. **Explain how DNS works and why it is essential for network communication.**
10. **Provide an overview of how an echo server functions and its usefulness in network communication.**

### Review: File Objects
- **Purpose:** Manipulates and queries the file system structure
- **Creation:**
  ```java
  File someFile = new File("data.txt");
  ```
- **Key Methods:**
  - **Execution Permissions:**
    - `canExecute()`
    - `canWrite()`
    - `canRead()`
  - **Deletion:**
    - `delete()`
    - `deleteOnExit()`
  - **Existence and Type Checks:**
    - `exists()`
    - `isDirectory()`
    - `isFile()`
  - **File and Directory Creation:**
    - `createNewFile()`
    - `mkdir()`
  - **Listing Contents:**
    - `list()`
- **Note:** Actual file opening occurs when a `File` object is passed to a Stream constructor.

### File I/O Layers in Java
- **Low-Level I/O:**
  - **Description:** “Raw” data transfer; byte-oriented
  - **Classes:**
    - `FileOutputStream`
    - `FileInputStream`
- **High-Level I/O:**
  - **Description:** Handles Java primitive types
  - **Classes:**
    - `DataOutputStream`
    - `DataInputStream`
- **Object I/O:**
  - **Description:** Manages Java object types
  - **Classes:**
    - `ObjectOutputStream`
    - `ObjectInputStream`
- **Overall:** All data is ultimately stored as a sequence of bytes.

### Exceptions
- **Key Concepts:**
  - `try-catch`
  - `throw`

### Handling Error Situations
- **Example Class: `Summer`**
  ```java
  public class Summer {
      public static void main(String[] args) {
          Scanner in = new Scanner(System.in);
          int number;        // Number that is input
          int sum = 0;       // Sum of values
          int c = 0;         // Count of values read
          double average;    // Average value

          while (in.hasNextInt()) {
              number = in.nextInt();
              c = c + 1;
              sum = sum + number;
          }

          if (c > 0) {
              average = (double) sum / c;
              System.out.printf("%d values, sum %d, average %f", c, sum, average);
          } else {
              System.out.printf("no values, no sum, no average");
          }
      }
  }
  ```
- **Behavior:**
  - Reads integers from input until no more integers are available.
  - Calculates the sum and average if at least one integer is read.
  - Outputs the results or a message indicating no values were entered.

### What to Do When an Error Occurs
- **Old Style: Return an “Error Code”**
  - **Caller Responsibilities:**
    - Must check the return value on each call to determine if an error occurred.
    - Requires a special value to indicate an error condition.
  - **Example:**
    - `indexOf()` method returns `-1` if the specified character is not found in a string.
    - Programmer must check for `-1` after each `indexOf()` call.

### Java Approach: Exceptions
- **Advantages:**
  - Write code without the need to check for errors after every operation.
- **Mechanism:**
  - When an error is detected, an exception is “thrown”.
    - **Effect:** Java system stops execution of the current method.
    - **Exception Handling:** Searches for an “exception handler” to manage the problem.
  - **Handler Search Path:**
    - Begins in the current method and continues up the call stack:
      - Caller → Caller’s caller → ... → `main` → ...

### The Call Stack
- **Structure:**
  - Each method call creates a "frame" on the stack.
    - **Contents of a Frame:**
      - Parameters
      - Local variables
  - **Execution Flow:**
    - Currently executing method is at the top.
    - Methods below are waiting for the called method to complete.

### Searching for a Handler
- **Process:**
  - When an exception occurs, Java searches for an appropriate handler starting from the current method.
  - Each method can either:
    - **Catch** the exception.
    - **Throw** it to its caller.
- **Hierarchy:**
  - Exception handling search continues up the method call chain until a handler is found or the stack is exhausted.

### Exception Class
- **Nature of Exceptions:**
  - Exceptions are objects.
  - An exception object is an instance of:
    - `Exception` class, or
    - A subclass of `Exception`.
- **Creation:**
  - Using the `new` keyword, similar to other objects.
- **Useful Methods:**
  - `e.getMessage()`: Retrieves the associated text message.
  - `e.printStackTrace()`: Prints the current call stack trace.

### Exception Class Hierarchy
- **Top Level:**
  - `Exception`
    - `IOException`
      - `FileNotFoundException`
    - `RuntimeException`
      - `ArithmeticException`
      - `NullPointerException`
      - `IndexOutOfBoundsException`
    - Custom Exceptions:
      - `YourException`

### Checked vs. Unchecked Exceptions
- **Unchecked Exceptions:**
  - **Definition:** Subclasses of `RuntimeException`.
  - **Characteristics:**
    - Indicate program or JVM errors (e.g., null pointer, arithmetic errors, invalid array index).
    - Typically unrecoverable; program may crash.
- **Checked Exceptions:**
  - **Definition:** All other subclasses of `Exception`.
  - **Characteristics:**
    - Indicate user or external errors (e.g., file not found).
    - Must be explicitly handled using `try-catch` or by declaring `throws`.
    - Generally recoverable, allowing the program to prompt the user or take corrective action.

### EOF: Unchecked Exception
- **Example Without Handling:**
  ```java
  import java.util.Scanner;
  public class EOF {
      public static void main(String[] args) {
          FileReader fr = new FileReader(f);
          Scanner s = new Scanner(fr);

          while (true) {
              String word = s.next();
              System.out.println(word);
          }
      }
  }
  ```
  - **Issue:** Throws `NoSuchElementException` at end of file without handling.

### EOF: Catching NoSuchElementException
- **Example With Handling:**
  ```java
  import java.util.Scanner;
  import java.util.NoSuchElementException;
  public class EOF {
      public static void main(String[] args) {
          FileReader fr = new FileReader(f);
          Scanner s = new Scanner(fr);
          while (true) {
              try {
                  String word = s.next();
                  System.out.println(word);
              } catch (NoSuchElementException e) {
                  System.out.printf("NoSuchElementException: %s\n", e.getMessage());
                  break;
              }
          }
      }
  }
  ```
  - **Behavior:** Catches `NoSuchElementException` when EOF is reached and exits the loop.

### Scanner: Catching FileNotFoundException
- **Example:**
  ```java
  import java.util.Scanner;
  import java.io.File;
  import java.io.FileNotFoundException;

  public class LineCounter {
      public static void main(String[] args) {
          File f = new File(args[0]);

          try {
              FileReader fr = new FileReader(f);
              Scanner s = new Scanner(fr);
              int c = 0;
              while (s.hasNextLine()) {
                  s.nextLine();
                  c++;
              }

              System.out.printf("read %d lines from file %s\n", c, f);
          } catch (FileNotFoundException e) {
              System.out.printf("Exception: %s\n", e.getMessage());
          }
      }
  }
  ```
  - **Behavior:** Counts the number of lines in a file; handles `FileNotFoundException` if the file does not exist.

### Catching Multiple Exceptions
- **Technique:**
  - Use multiple `catch` blocks after a single `try`.
  - Java matches exceptions from top to bottom.
  - **Example:**
    ```java
    try {
        // Statements that may throw exceptions
    } catch (StudentNotFoundException e) {
        // Handle student not found
    } catch (NullPointerException e) {
        // Handle null pointer
    } catch (Exception e) {
        // Handle all other exceptions
    }
    ```

### Making Your Own Exception Class
- **Custom Exception Example:**
  ```java
  public class StudentNotFoundException extends Exception {
      public StudentNotFoundException(String message) {
          super(message);
      }
  }

  public class FindStudent {
      public Student search(int studentId) throws StudentNotFoundException {
          if (/* student not found */) {
              throw new StudentNotFoundException(Integer.toString(studentId));
          }
          // Return found student
      }
  }
  ```
  - **Details:**
    - `StudentNotFoundException` extends `Exception`.
    - Constructor takes a `String` message and passes it to the superclass.
    - `search` method declares it throws `StudentNotFoundException` and throws it when appropriate.

### Typical Exception Handling Situation
- **Example:**
  ```java
  try {
      // Code that may throw an exception
      method1(...);
  } catch (StudentNotFoundException e) {
      // Recovery statements
  }
  ```
  - **Behavior:** Attempts to execute `method1`; catches `StudentNotFoundException` to perform recovery.

### Catching Multiple Exceptions (Ordering)
- **Important:** Order `catch` blocks from the most specific (subclasses) to the most general (superclasses).
- **Example:**
  ```java
  try {
      // Statements that may throw exceptions
  } catch (StudentNotFoundException e) {
      // Handle student not found
  } catch (NullPointerException e) {
      // Handle null pointer
  } catch (Exception e) {
      // Handle all other exceptions
  }
  ```

### Finally Clause
- **Purpose:** Execute code after `try-catch` blocks regardless of whether an exception was thrown or caught.
- **Guarantee:** Executes even if previous clauses return or throw exceptions.
- **Example:**
  ```java
  try {
      // Statements that may throw exceptions
  } catch (StudentNotFoundException e) {
      // Handle student not found
  } finally {
      // Cleanup code
  }
  ```

### Try-With-Resources Statement
- **Purpose:** Automatically manage resources (e.g., close them) without needing a `finally` block.
- **Resource Definition:** An object that must be closed after use (e.g., file streams).
- **Syntax Example:**
  ```java
  static String readFirstLineFromFile(String path) throws IOException {
      try (BufferedReader br = new BufferedReader(new FileReader(path))) {
          return br.readLine();
      } catch (StudentNotFoundException e) {
          // Handle other exceptions
      }
  }
  ```
- **Behavior:**
  - **Resource Management:** `BufferedReader` is automatically closed after the `try` block completes, whether normally or abruptly.
  - **Exception Handling:** Any exceptions thrown within the `try` block can still be caught and handled.

### Summary of Key Points
- **File I/O:**
  - Understand the different layers and associated classes for handling I/O in Java.
  - Utilize `File` object methods for file operations and checks.
- **Exception Handling:**
  - Distinguish between checked and unchecked exceptions.
  - Implement `try-catch` blocks to handle exceptions gracefully.
  - Use `finally` for cleanup operations and `try-with-resources` for automatic resource management.
  - Create and use custom exception classes for specific error scenarios.
  - Order `catch` blocks from specific to general to ensure proper exception handling.
### Exceptions

- **try-catch**: Control structure to catch exceptions and handle errors gracefully.
- **throw**: Statement to signal that an exception has occurred, transferring control to exception handling code.

### Handling Error Situations

```java
public class Summer {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int number;       // number that is input
        int sum = 0;      // sum of values
        int c = 0;        // how many values read
        double average;   // average value
        while (in.hasNextInt()) {
            number = in.nextInt();
            c = c + 1;
            sum = sum + number;
        }
        if (c > 0) {
            average = sum / (double)c;
            System.out.printf("%d values, sum %d, average %f", c, sum, average);
        } else {
            System.out.printf("no values, no sum, no average");
        }
    }
}
```

### What to Do When an Error Occurs

- **Old Style**:
  - Return an “error code”.
  - Caller must check on each call:
    - Did the method return an error?
    - Requires a special value to indicate error.
  - **Example**:
    - `indexOf()` method:
      - Retrieves index position of a character in a string.
      - Returns `-1` if character not found.
      - Programmer must check for `-1`.

### Java Approach: Exceptions

- Write code without worrying about checking for errors.
- When an error is detected, an exception is **thrown**:
  - Java system stops execution of the current method.
  - Searches for an “exception handler” to deal with the problem.
- **Search Process**:
  - Begins in the current method.
  - Continues to caller → caller’s caller → ... → main → ...

### The Call Stack

- Structure:
  - `main`
  - `method1`
  - `method2`
  - `method3`
  - `method4` (currently executing)
- Each method frame on the stack contains storage for:
  - Parameters
  - Local variables
- Methods wait for called methods to complete.

### Searching for a Handler

- Java searches for an exception handler starting with the current method, then caller, caller’s caller, etc.
- Each method can either **catch** the exception or **throw** it to its caller.

### Exception Class

- **Exceptions are objects**:
  - Instance of `Exception` class or a subclass.
- **Creation**:
  - Using `new`, like any other object.
- **Useful Methods**:
  - `e.getMessage()`: Retrieves the associated text message.
  - `e.printStackTrace()`: Prints the current call stack.

### Exception Class Hierarchy

- **Exception**
  - **IOException**
    - `FileNotFoundException`
  - **RuntimeException**
    - `ArithmeticException`
    - `NullPointerException`
    - `IndexOutOfBoundsException`
  - **YourException**

### Checked vs. Unchecked Exceptions

- **Unchecked Exceptions**:
  - Subclasses of `RuntimeException`.
  - Indicate program or JVM errors (e.g., null pointer, arithmetic errors, invalid array index).
  - Typically, no recovery is possible; program may crash.
- **Checked Exceptions**:
  - All other subclasses of `Exception`.
  - Indicate user errors (e.g., file not found).
  - Must be handled using `try-catch` or `throws`.
  - Typically recoverable (e.g., prompt user again).

### Example: EOF as Unchecked Exception

```java
import java.util.Scanner;

public class EOF {
    public static void main(String[] args) {
        FileReader fr = new FileReader(f);
        Scanner s = new Scanner(fr);

        while (true) {
            String word = s.next(); // Throws NoSuchElementException at end of file
            System.out.println(word);
        }
    }
}
```

### Catching NoSuchElementException

```java
import java.util.Scanner;
import java.util.NoSuchElementException;

public class EOF {
    public static void main(String[] args) {
        FileReader fr = new FileReader(f);
        Scanner s = new Scanner(fr);
        while (true) {
            try {
                String word = s.next();
                System.out.println(word);
            } catch (NoSuchElementException e) {
                System.out.printf("NoSuchElementException: %s\n", e.getMessage());
                break;
            }
        }
    }
}
```

### Catching FileNotFoundException with Scanner

```java
import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;

public class LineCounter {
    public static void main(String[] args) {
        File f = new File(args[0]);

        try {
            FileReader fr = new FileReader(f);
            Scanner s = new Scanner(fr);
            int c = 0;
            while (s.hasNextLine()) {
                s.nextLine();
                c++;
            }
            System.out.printf("read %d lines from file %s\n", c, f);
        } catch (FileNotFoundException e) {
            System.out.printf("Exception: %s\n", e.getMessage());
        }
    }
}
```

### Catching Multiple Exceptions

```java
try {
    // Statements that may throw exceptions
} catch (StudentNotFoundException e) {
    // Handle student not found
} catch (NullPointerException e) {
    // Handle null pointer
} catch (Exception e) {
    // Handle all other exceptions
}
```

- Java matches exceptions from top to bottom.

### Making Your Own Exception Class

```java
public class StudentNotFoundException extends Exception {
    public StudentNotFoundException(String message) {
        super(message);
    }
}

public class FindStudent {
    public Student search(int student) throws StudentNotFoundException {
        if (...) {
            throw new StudentNotFoundException(Integer.toString(student));
        }
    }
}
```

### Typical Exception Handling Situation

```java
try {
    // ...
    method1(...);
    // ...
} catch (StudentNotFoundException e) {
    // Statements to recover
}
```

### Ordering Catch Blocks

```java
try {
    // Statements that may throw exceptions
} catch (StudentNotFoundException e) {
    // Handle student not found
} catch (NullPointerException e) {
    // Handle null pointer
} catch (Exception e) {
    // Handle all other exceptions
}
```

- **Order**: From lowest subclass to highest superclass.

### Finally Clause

```java
try {
    // Statements that may throw exceptions
} catch (StudentNotFoundException e) {
    // Handle student not found
} finally {
    // Code to clean things up
}
```

- **Execution**: Finally clause executes after all try/catch statements.
- **Guarantee**: Executes even if earlier clause returns.

### Try-With-Resources Statement

- **Purpose**: Ensures that resources are closed automatically.
- **Resource**: An object that must be closed after use (e.g., `BufferedReader`).

```java
static String readFirstLineFromFile(String path) throws IOException {
    try (BufferedReader br = new BufferedReader(new FileReader(path))) {
        return br.readLine();
    } catch (StudentNotFoundException e) {
        // Handle other exceptions
    }
}
```

- **Behavior**:
  - Resource (`BufferedReader br`) is declared in the try-with-resources statement.
  - `br` is closed automatically after the try block completes, whether normally or abruptly.

### Key Points

- **Exception Objects**:
  - Instances of `Exception` or its subclasses.
  - Created using `new`.
- **Handling Exceptions**:
  - Use `try-catch` blocks to handle specific exceptions.
  - Multiple catch blocks allow handling different exception types.
  - `finally` blocks ensure cleanup code runs regardless of exceptions.
- **Custom Exceptions**:
  - Extend the `Exception` class.
  - Provide constructors to pass messages.
- **Resource Management**:
  - Try-with-resources simplifies the automatic closing of resources.
  - Ensures no resource leaks occur even if exceptions are thrown.
## Interfaces and Inheritance in Java

### 1. Interface Concepts
- **Interface Definition**:
  - A point where two systems interact.
  - Typically **asymmetric**: one system defines the interface, the other uses it.

- **Examples of Interfaces**:
  - **Graphical User Interface (GUI)**: Interaction between user and computer.
  - **Application Programming Interface (API)**: Interaction between application programs and a library of methods.

### 2. Java Class as an Interface
- **Java Class as Interface**:
  - A Java class serves as a form of interface.
  - **Public Members**:
    - Primarily methods that define the interface to clients (users) of the class.
  - **Class Interface Components**:
    - **Public Method Signatures**: Define what parameters the method expects.
    - **Method Return Types**: Define what the method returns.

- **Java Abstraction**:
  - The Java language abstracts class interfaces further, enhancing encapsulation and modularity.

### 3. Java Interface
- **Contract Definition**:
  - Establishes a contract between:
    - **Interface-Defining Class**: The class that declares the interface.
    - **Implementing Class**: The class that provides implementations for the interface.

- **Implementation Requirements**:
  - Any class implementing the interface must provide concrete implementations for all declared methods, except for **default methods**.

### 4. Interface Syntax
- **Declaration**:
  ```java
  interface Doable {
      // method declarations
  }
  ```
- **Characteristics**:
  - Exists in its own `.java` file.
  - Includes method declarations without bodies, except for methods labeled with `default` or `static`.
  - Does not contain fields except for constants.

- **Analogy**:
  - An interface is like a class without declared fields and method bodies.

### 5. Default Methods
- **Definition**:
  - Instance methods within an interface prefixed with the `default` keyword.

- **Features**:
  - Provide a default implementation (code body).
  - Implementing classes inherit these methods but can override them if needed.

- **Example**:
  ```java
  public interface Addressable {
      String getStreet();
      String getCity();

      default String getFullAddress() {
          return getStreet() + ", " + getCity();
      }
  }
  ```

### 6. Static Methods
- **Definition**:
  - Methods within an interface declared with the `static` keyword.

- **Characteristics**:
  - Typically used for utility or helper methods.
  - Implicitly `public`.
  - Can be referenced using the interface name: `InterfaceName.myStaticMethod()`.

- **Usage in Default Methods**:
  - Facilitate shared code between methods within the interface.

- **Inheritance Behavior**:
  - Not inherited by implementing classes.
  - Implementing classes can define methods with the same name without conflict.

### 7. Implementing an Interface
- **Declaration**:
  ```java
  public class Henway implements Doable {
      // method implementations
  }
  ```

- **Requirements**:
  - Must implement all methods declared in the interface (`Doable` in this case).
  - Can include additional methods beyond those specified in the interface.

- **Example Implementation**:
  ```java
  interface Doable {
      int compute(int x);
      void doit(int y);
  }

  class Henway implements Doable {
      public int compute(int x) {
          return x + 1;
      }

      public void doit(int y) {
          System.out.println(y);
      }
  }
  ```

### 8. Fields in Interfaces
- **Characteristics**:
  - Fields in interfaces are implicitly `public`, `final`, and `static`.

- **Constants**:
  - Must be initialized upon declaration.
  - Facilitate the use of shared constants across implementing classes.

- **Example**:
  ```java
  interface Constants {
      double X = 1234.56;
      int Y = -1;
      String Z = "hello there";
  }

  public class Booyah implements Constants {
      public static void main(String[] args) {
          System.out.println(X);
          System.out.println(Y);
          System.out.println(Z);
      }
  }
  ```

### 9. Implementing Multiple Interfaces
- **Capability**:
  - A class can implement multiple interfaces.

- **Method Implementation**:
  - Must implement the union of all methods specified in the interfaces.

- **Examples**:
  ```java
  class SoapOpera implements Cryable { ... }
  class SitCom implements Laughable { ... }
  class Movie implements Laughable, Cryable { ... }
  ```

- **Challenges**:
  - **Default Methods Conflict**:
    - If multiple interfaces provide the same default method, the implementing class must override and provide an explicit definition.

  - **Constant Name Conflicts**:
    - Interfaces cannot define constants with the same name unless they are not used ambiguously in the implementing class.

### 10. Interface Example: Rideable
- **Interface Definition**:
  ```java
  interface Rideable {
      void mount();
      void dismount();
      void move(boolean forward);
      void turn(int direction);
      void setSpeed(double mph);
  }
  ```

- **Implementations**:
  ```java
  class Motorcycle implements Rideable { ... }

  class Horse implements Rideable, Trainable { ... }

  class Bicycle implements Rideable { ... }
  ```

### 11. Building a Game Using Interfaces
- **Problem Statement**:
  - Implement a turn-based game where players can pick up valuable objects.

- **Components**:
  - **Players**: Multiple players, each with their own strategy.
  - **Game Controller**: Enforces game rules.

- **Use of Interfaces**:
  - **Player Interface**: Each player class implements the `Player` interface.
  - **Game Controller**: Expects parameters of type `Player`.

- **Main Program Flow**:
  1. Create player objects from various classes.
  2. Initialize the game controller with these player objects.
  3. Start the game controller.
  4. Display game results.

- **Class Diagram Overview**:
  - **Player (Interface)**
  - **Player Classes**: `Player1 (strategy1)`, `Player2 (strategy2)`
  - **Game Class**: Contains rules and logic, interacts with `Player` instances.
  - **Main Class**: Initializes and starts the game.

- **Player Interface**:
  ```java
  interface Player {
      void makeMove();
      void getItems();
  }
  ```

- **Dragon Class Implementation**:
  ```java
  public class Dragon implements Player {
      public void makeMove() { /* Implementation */ }
      public void getItems() { /* Implementation */ }
      // Other methods...
  }
  ```

- **Butterfly Class Implementation**:
  ```java
  public class Butterfly implements Player {
      public void makeMove() { /* Implementation */ }
      public void getItems() { /* Implementation */ }
      // Other methods...
  }
  ```

- **Main Class Execution**:
  ```java
  public class Main {
      public static void main(String[] args) {
          Dragon bob = new Dragon();
          Butterfly ann = new Butterfly();
          Game game = new Game(bob, ann);

          game.play();
          System.out.println("game over");
      }
  }
  ```

- **Game Class Structure**:
  ```java
  public class Game {
      private Player p1;
      private Player p2;

      Game(Player p1, Player p2) {
          this.p1 = p1;
          this.p2 = p2;
      }

      void play() {
          p1.makeMove();
          p2.makeMove();
          p1.getItems();
          p2.getItems();
      }
  }
  ```

### 12. Key Takeaways
- **Interfaces Enhance Flexibility**:
  - Allow for multiple implementations and promote loose coupling between components.

- **Default and Static Methods**:
  - Provide additional flexibility in interface design without breaking existing implementations.

- **Multiple Interface Implementation**:
  - Enables classes to inherit behaviors from multiple sources, but requires careful handling of method and constant conflicts.

- **Use in Design Patterns**:
  - Interfaces are foundational in many design patterns, facilitating abstraction and polymorphism.

---
### CS18000: Problem Solving and Object-Oriented Programming
#### Complex GUIs, Part 1 & Part 2

---

#### Constructing Graphical User Interfaces
- **Frames**
  - Basic top-level window in Java Swing.
  - Interacts with the OS window manager.
  - Houses and lays out interactive controls.
  - **Usage Approaches:**
    - Create a raw `JFrame` object.
    - Extend `JFrame` and then create an instance.

- **Panels**
  - Used to group widgets for layout.
  - Hierarchical structure; panels can contain sub-panels.
  - **Class `JPanel`:**
    - Java's panel class.
    - `jf.getContentPane()` returns a `JPanel`.
    - `jf.add(...)` automatically adds components to the content pane.
    - Default layout manager for content pane is `BorderLayout`.

- **Widgets**
  - User-interface elements visible to the user.
  - Examples: `JLabel`, `JButton`, `JTextField`, `JScrollBar`, `JCanvas`, etc.
  - Panels are also considered widgets to allow sub-layouts.

---

#### Review from Earlier Lecture on GUIs
- **JOptionPane**
  - Used for creating standard dialog boxes.
  - Facilitates user input and message display.

- **JFileChooser**
  - Provides a dialog for file selection.

- **One-shot, Pop-up Dialogs**
  - Temporary dialog windows for interacting with the user.

---

#### Paradigm Shift: From Commands to GUI
- **Command-Line Interface (CLI)**
  - Program prompts user with text.
  - User responds with arbitrary text input.
  - Program must validate input to prevent nonsense or malicious text.

- **Graphical User Interface (GUI)**
  - Program presents a graphical input interface.
  - Includes elements like text boxes, buttons, sliders.
  - User interactions are constrained to specific formats:
    - Keystrokes for text boxes.
    - Mouse clicks for buttons.
    - Mouse movements for sliders.

---

#### Model-View-Controller (MVC)
- **Software Paradigm for GUIs**
  - Not rigid; accommodates various implementations.

- **Components:**
  - **Model:**
    - Represents the data or database underlying the application.

  - **View:**
    - Comprises the GUI components visible to the user.

  - **Controller:**
    - Acts as the "glue" implementing the business rules.
    - **Responsibilities:**
      - Updates the view when the model changes.
      - Updates the model based on user interactions with the view.

- **Benefits:**
  - Separates responsibilities to manage system complexity.
  - Allows specialization in model, view, and controller areas.

---

#### GUI Concept: Interface Hierarchy
- **Components/Widgets Hierarchy:**
  - **Top-Level: `JFrame`**
    - Interacts with the user’s desktop environment.

  - **Inside `JFrame`:**
    - **`JMenuBar`**
      - Contains `JMenu` items.
        - Each `JMenu` can contain `JMenuItem` entries.
    - **`JPanel`**
      - Organizes layout using layout managers.

  - **Interface Widgets within Panels:**
    - **`JButton`**
    - **`JLabel`**
    - **`JTextField`**
    - **`JTextArea`**
    - **`JScrollBar`**
    - **`JCanvas`**

  - **Sub-Panels:**
    - Panels can contain other panels to create complex layouts.

---

#### GUIs in Java
- **Java Packages for GUIs:**
  - **`java.awt` (Abstract Window Toolkit)**
    - Original package for GUI components.

  - **`javax.swing`**
    - Newer, more versatile, built on AWT.
    - Most commonly used for building GUIs.
    - Contains "J" classes, e.g., `JFrame`, `JPanel`.

---

#### Class `JFrame`
- **Basic Top-Level Window**
  - Serves as the main window in Swing applications.

- **Operations:**
  - **`setDefaultCloseOperation(int operation)`**
    - `DISPOSE_ON_CLOSE`: Graceful shutdown; disposes of the frame without terminating the application.
    - `EXIT_ON_CLOSE`: Terminates the entire application (`System.exit()` equivalent).

  - **`setSize(int width, int height)`**
    - Sets the dimensions of the frame (e.g., 640x480).

  - **`setResizable(boolean resizable)`**
    - Determines if the frame can be resized by the user.

  - **`setVisible(boolean visible)`**
    - Makes the frame visible (`true`) or hidden (`false`).
    - `true` also triggers layout validation.

  - **`setTitle(String title)`**
    - Sets the text displayed in the frame's title bar.

  - **`add(Component comp)`**
    - Adds a component to the frame's content pane.

---

#### Example: `EmptyFrame`
```java
import javax.swing.JFrame;

public class EmptyFrame {
    public static void main(String[] args) {
        JFrame jf = new JFrame("Empty Frame");
        jf.setSize(640, 480);
        jf.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        jf.setVisible(true);
    }
}
// Important change to this code coming later!
```
- **Purpose:**
  - Creates an empty window titled "Empty Frame" with specified size.
  - Sets close operation to dispose of the frame gracefully.
  - Makes the frame visible to the user.

---

#### Panels and Layout Managers
- **Panels:**
  - Group widgets for organized layout.
  - Hierarchical; can contain sub-panels for complex interfaces.

- **Layout Managers:**
  - Define rules for positioning and sizing widgets within containers like `JPanel`.
  - Common Layout Managers:
    - **`BorderLayout`**: Divides container into five regions (Center, North, East, South, West).
    - **`FlowLayout`**: Arranges components left-to-right, top-to-bottom.
    - **`GridLayout`**: Organizes components in a grid of equal-sized cells.
    - **Others**: `BoxLayout`, `GridBagLayout`, etc.
  - **Behavior:**
    - Automatically adjusts layout as container sizes change.

---

#### Class `JPanel`
- **Java Panel Class**
  - Acts as a container for organizing GUI components.

- **Special Features with `JFrame`:**
  - `jf.getContentPane()` returns a `JPanel`.
  - `jf.add(...)` adds components to the content pane automatically.
  - Default layout manager of content pane is `BorderLayout`.

---

#### A Java GUI: A Tree of Components
- **Hierarchy Example:**
  - `JFrame`
    - `JMenuBar`
      - `JMenu`
        - `JMenuItem`
        - `JMenuItem`
    - `JPanel`
      - `JButton`
      - `JLabel`
        - `JLabel`
        - `JTextField`
      - `JLabel`
        - `JButton`

---

#### Example Layout Manager: `BorderLayout`
```java
import javax.swing.JFrame;
import javax.swing.JButton;
import java.awt.BorderLayout;

public class BorderLayoutExample {
    public static void main(String[] args) {
        JFrame jf = new JFrame("BorderLayout Example");
        jf.setSize(400, 300);
        jf.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

        JButton jbCenter = new JButton("Center");
        JButton jbNorth = new JButton("North");
        JButton jbSouth = new JButton("South");
        JButton jbEast = new JButton("East");
        JButton jbWest = new JButton("West");

        jf.add(jbCenter, BorderLayout.CENTER);
        jf.add(jbNorth, BorderLayout.NORTH);
        jf.add(jbSouth, BorderLayout.SOUTH);
        jf.add(jbEast, BorderLayout.EAST);
        jf.add(jbWest, BorderLayout.WEST);

        jf.setVisible(true);
    }
}
```
- **Functionality:**
  - Divides the container into five regions.
  - One component can be added to each region.
  - Example adds five buttons to respective regions.

---

#### Class `JLabel`
- **Displays Unselectable Text and Images**
  - Can render text and images.

- **Supports HTML:**
  - Allows formatting using HTML tags.

- **Common Methods:**
  - **`setFont(Font f)`**: Sets the font of the label text.
  - **`setForeground(Color c)`**: Sets the text color.
  - Additional methods available for customization.

---

#### Example: Adding Buttons to Borders
```java
JButton jbCenter = new JButton("Center");
JButton jbNorth = new JButton("North");
JButton jbSouth = new JButton("South");
JButton jbEast = new JButton("East");
JButton jbWest = new JButton("West");

jf.add(jbCenter, BorderLayout.CENTER);
jf.add(jbNorth, BorderLayout.NORTH);
jf.add(jbSouth, BorderLayout.SOUTH);
jf.add(jbEast, BorderLayout.EAST);
jf.add(jbWest, BorderLayout.WEST);
```
- **Purpose:**
  - Adds five buttons to the respective regions of a `BorderLayout`.

---

#### Widgets for Interaction
- **Common Widgets:**
  - `JLabel`
  - `JButton`
  - `JTextField`
  - `JTextArea`
  - Additional: Radio buttons, scroll bars, toggles, etc.

---

#### Event Handling
- **Events:**
  - Connect user actions to the program.

- **Event Sources:**
  - Keystrokes.
  - Mouse actions (clicks, movements).

- **Event Listeners:**
  - Methods in code that respond to events.
  - Linked to widgets to process corresponding events.

- **Execution Thread:**
  - Runs on the Event Dispatch Thread (EDT).
  - Importance of not blocking the EDT to maintain responsiveness.

---

#### Java Event Handling
- **Event Dispatch Thread (EDT):**
  - Dedicated thread for handling GUI events.

- **Typical Scenario:**
  - **Main Thread:**
    - Builds `JFrame` and lays out interface.
    - Makes `JFrame` visible.
    - Exits after completing `main` method.

  - **EDT:**
    - Continues running after main thread exits.
    - Interacts with the user.
    - Invokes listeners/callbacks to handle events.
    - Ensures event-handling code runs on the EDT.

---

#### A Better Way to Launch a `JFrame`
- **Thread Safety:**
  - Swing classes are not thread-safe.

- **Deadlock Prevention:**
  - Ensure Swing components are created, modified, and queried only on the EDT.

- **Implementation:**
  - Use `SwingUtilities.invokeLater(Runnable r)` to execute GUI-related code on the EDT.

- **Example Modification:**
  ```java
  import javax.swing.SwingUtilities;
  import javax.swing.JFrame;

  public class EmptyFrame {
      public static void main(String[] args) {
          SwingUtilities.invokeLater(new Runnable() {
              public void run() {
                  createGUI();
              }
          });
      }

      public static void createGUI() {
          JFrame jf = new JFrame("Empty Frame");
          jf.setSize(640, 480);
          jf.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
          jf.setVisible(true);
      }
  }
  ```

---

#### Observers (“Listeners”) in Java
- **Common Listener Interfaces:**
  - **`ActionListener`**: For buttons.
  - **`MouseListener`**: For detecting component entry/exit.
  - **`MouseMotionListener`**: For tracking mouse movement over a component.
  - **`ItemListener`**: For check boxes.
  - **`DocumentListener`**: For text fields.
  - **`KeyListener`**: For keyboard input in text boxes.

---

#### `ActionListener` Interface
- **Method to Implement:**
  - `public void actionPerformed(ActionEvent e)`

- **`ActionEvent` Methods:**
  - **`getSource()`**: Returns the widget that generated the event.
  - **`getActionCommand()`**: Returns an associated string command.
  - **`getWhen()`**: Returns the timestamp of the event.

- **Setting Action Command:**
  - **`source.setActionCommand(String s)`**: Sets the string returned by `getActionCommand()`.

---

#### Example: `PushMe` Class Implementing `ActionListener`
```java
import javax.swing.SwingUtilities;
import javax.swing.JFrame;
import javax.swing.JButton;
import javax.swing.JLabel;
import java.awt.BorderLayout;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

public class PushMe implements ActionListener {
    static JFrame frame;

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                createGUI();
            }
        });
    }

    public static void createGUI() {
        frame = new JFrame("Push Me");
        frame.setSize(200, 100);
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

        JButton button = centeredButton();
        button.addActionListener(new PushMe());
        frame.setVisible(true);
        frame.setLocationRelativeTo(null);
    }

    public void actionPerformed(ActionEvent e) {
        JButton b = (JButton) e.getSource();
        if (b.getActionCommand().equals("last time"))
            frame.dispose();
        if (b.getActionCommand().equals("push")) {
            b.setActionCommand("last time");
            b.setText("Push Again");
        }
    }

    static JButton centeredButton() {
        String[] location = { BorderLayout.NORTH, BorderLayout.EAST, BorderLayout.SOUTH, BorderLayout.WEST };
        for (String s : location) {
            frame.add(new JLabel("     "), s);
        }
        JButton jb = new JButton("Push Me");
        jb.setActionCommand("push");
        frame.add(jb);
        return jb;
    }
}
```
- **Functionality:**
  - Creates a window with a "Push Me" button.
  - When clicked, changes to "Push Again" and updates action command.
  - On second click ("last time"), disposes of the frame.

---

#### Source to Listener Relationships
- **One-to-One**
  - **Description:** One event source sends events to one listener.
  - **Usage:** Simple, direct handling of events.

- **Many-to-One**
  - **Description:** Multiple event sources send events to a single listener.
  - **Usage:** Allows a single piece of code to handle multiple buttons or components.

- **One-to-Many**
  - **Description:** One event source sends events to multiple listeners.
  - **Usage:** Enables independent actions to occur on the same event trigger.
  - **Note:** Less commonly used compared to other relationships.

---

#### Using the `ActionListener`
- **Technique 1: Named Class**
  - Create a separate, named class that implements `ActionListener`.
  - Instantiate the listener object.
  - Attach the listener to one or more buttons.

- **Technique 2: Nested Class**
  - Define a nested class within another class (e.g., within `main` method).
  - Implement `ActionListener`.
  - Instantiate and attach to a button.

- **Technique 3: Anonymous Inner Class**
  - Implement `ActionListener` without naming the class.
  - Declare, instantiate, and attach the listener in a single step.

---

#### Local Inner Classes & Anonymous Classes
- **Local Inner Classes**
  - Declared within an instance method.
  - No access level modifiers.
  - Can capture effectively final local variables.

- **Anonymous Classes**
  - Similar to local inner classes but designed for one-time use.
  - Declared and instantiated in one step.
  - Convenient for implementing listener interfaces on the fly.

---

#### Example: Implement `ActionListener` Using Named Class
```java
public class ListenerTechnique1 implements ActionListener {
    public static void main(String[] args) {
        // Initialization code omitted
        JButton button = new JButton("Push Me");
        button.addActionListener(new ListenerTechnique1());
        button.setActionCommand("doit");
        // Finish and make visible omitted
    }

    public void actionPerformed(ActionEvent ae) {
        System.out.printf("Button pressed: %s \n", ae.getActionCommand());
    }
}
```
- **Functionality:**
  - Defines a named class `ListenerTechnique1` that implements `ActionListener`.
  - Handles button press by printing the action command to the console.

---

#### Example: Use Nested Class
```java
// This class is nested inside main method (for example)…
class OneShot implements ActionListener {
    public void actionPerformed(ActionEvent ae) {
        System.out.printf("Button pressed: %s \n", ae.getActionCommand());
    }
}
button.addActionListener(new OneShot());
```
- **Functionality:**
  - Defines a nested class `OneShot` within a method.
  - Implements `ActionListener`.
  - Handles button press by printing action command.

---

#### One-Shot `ActionListener`
- **Characteristics:**
  - No need for a named class.
  - Intended for single-use listeners.

- **Implementation:**
  - Utilize anonymous inner classes.
  - Combine method declaration, class definition, object creation, and listener attachment in one step.

---

#### Anonymous Inner Class Example
```java
button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent ae) {
        // Do something with ae
    }
});
```
- **Functionality:**
  - Implements `ActionListener` anonymously.
  - Defines `actionPerformed` method inline.
  - Attaches the listener directly to the button.

---

#### Adapter Classes
- **Problem:**
  - Some listener interfaces contain multiple methods.
  - Often only one method is needed for specific use cases.
  - Implementing the interface requires defining all methods, even if unused.

- **Solution:**
  - Use adapter classes that provide default (empty) implementations for all methods.
  - Subclass the adapter and override only the necessary methods.

---

#### Example: `MouseAdapter` Class
- **Provides Implementations For:**
  - `mouseEntered(...)`
  - `mouseClicked(...)`
  - `mouseExited(...)`
  - `mousePressed(...)`
  - `mouseReleased(...)`

- **Usage:**
  - Extend `MouseAdapter`.
  - Override only the methods required for specific event handling.

---

#### Layout Managers
- **Purpose:**
  - Define the rules for positioning and sizing components within containers like `JPanel`.

- **Common Layout Managers:**
  - **`BorderLayout`**
    - Divides container into five regions: Center, North, East, South, West.

  - **`FlowLayout`**
    - Arranges components left-to-right, top-to-bottom.
    - Wraps to next line when space is filled.
    - Each line is centered by default.
    - Components retain their preferred size.

  - **`GridLayout`**
    - Organizes components in a grid with specified rows and columns.
    - All cells are equal in size; components fill the entire cell space.

  - **Others:**
    - `BoxLayout`, `GridBagLayout`, etc.

- **Behavior:**
  - Automatically re-layouts components as container sizes change.

---

#### FlowLayout
- **Default Layout Manager:**
  - Used by `JPanel` unless specified otherwise.
  - Not the default for JFrame's content pane; `BorderLayout` is used instead.

- **Characteristics:**
  - Widgets "flow" together, one after another.
  - Left to right until space fills, then wraps to top-to-bottom.
  - Each line of components is centered.
  - Widgets maintain their preferred size.

---

#### Example: FlowLayout
```java
import javax.swing.SwingUtilities;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JButton;

public class FlowLayoutExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                createGUI();
            }
        });
    }

    public static void createGUI() {
        JFrame frame = new JFrame("FlowLayout Example");
        frame.setSize(500, 300);
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

        JPanel panel = new JPanel(); // Defaults to FlowLayout
        for (int i = 1; i <= 10; i++) {
            JButton button = new JButton("Button " + i);
            panel.add(button);
        }

        frame.add(panel);
        frame.setVisible(true);
    }
}
```
- **Functionality:**
  - Creates a window with a `JPanel` using `FlowLayout`.
  - Adds ten buttons labeled "Button 1" to "Button 10".
  - Demonstrates automatic component flow and wrapping.

- **Issue Highlighted:**
  - Button 10 may appear misaligned or isolated, indicating potential layout management concerns.

---

#### GridLayout
- **Definition:**
  - Arranges components in a grid of specified rows and columns.

- **Characteristics:**
  - Each component fills its cell entirely.
  - All cells are the same size, determined by the layout's overall size.

- **Usage Example:**
  ```java
  setLayout(new GridLayout(0, 4));
  // Four columns per row, multiple rows as needed.
  ```

- **Example: GridLayout**
  ```java
  import javax.swing.SwingUtilities;
  import javax.swing.JFrame;
  import javax.swing.JPanel;
  import javax.swing.JButton;
  import java.awt.GridLayout;

  public class GridLayoutExample {
      public static void main(String[] args) {
          SwingUtilities.invokeLater(new Runnable() {
              public void run() {
                  createGUI();
              }
          });
      }

      public static void createGUI() {
          JFrame frame = new JFrame("GridLayout Example");
          frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
          JPanel panel = new JPanel(new GridLayout(3, 4)); // 3 rows, 4 columns

          for (int i = 1; i <= 12; i++) {
              JButton button = new JButton("Button " + i);
              panel.add(button);
          }

          frame.add(panel);
          frame.pack(); // Adjust frame size to fit components
          frame.setVisible(true);
      }
  }
  ```
- **Functionality:**
  - Creates a 3x4 grid layout.
  - Adds twelve buttons uniformly across the grid.
  - Ensures all cells are the same size, enhancing visual consistency.

---

#### Changing the `JFrame`’s Layout Manager
```java
public static void createGUI() {
    JFrame jf = new JFrame();
    JPanel jp = jf.getContentPane();
    jp.setLayout(new FlowLayout());
    jp.add(...); // Uses FlowLayout
    // Additional component additions
}
```
- **Purpose:**
  - Alters the default layout manager (`BorderLayout`) of the JFrame's content pane to `FlowLayout`.
  - Allows for different arrangement behaviors of components within the frame.

---

#### Factory Pattern
- **Definition:**
  - A design pattern for creating objects.

- **Characteristics:**
  - Utilizes static methods instead of direct object instantiation with `new`.

- **Benefits:**
  - Encapsulates object creation logic.
  - Enables reuse of read-only or shared objects.
  - Enhances code maintainability and flexibility.

- **Examples:**
  - **`BorderFactory`:**
    - `BorderFactory.createLineBorder(Color.RED)`
    - `BorderFactory.createTitledBorder("Sub Panel")`

  - **Usage:**
    - Provides a centralized way to create objects with specific configurations.

---

#### Example: Using Sub-Panels
```java
import javax.swing.SwingUtilities;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JButton;
import javax.swing.BorderFactory;
import javax.swing.border.Border;
import java.awt.Color;
import java.awt.GridLayout;

public class SubPanelExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                createGUI();
            }
        });
    }

    public static void createGUI() {
        JFrame frame = new JFrame("SubPanel Example");
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

        JPanel pane1 = new JPanel();
        JPanel pane2 = new JPanel(new GridLayout(0, 2));

        Border b1 = BorderFactory.createLineBorder(Color.RED);
        Border b2 = BorderFactory.createTitledBorder("Sub Panel");
        pane1.setBorder(b1);
        pane2.setBorder(b2);

        addButtons(pane2, 5);
        addButtons(pane1, 2);
        pane1.add(pane2);
        addButtons(pane1, 3);

        frame.add(pane1);
        frame.setVisible(true);
    }

    static int counter = 0;

    static void addButtons(JPanel pane, int count) {
        for (int i = 1; i <= count; i++)
            pane.add(new JButton("Button " + ++counter));
    }
}
```
- **Functionality:**
  - Creates a main panel (`pane1`) with a red line border.
  - Creates a sub-panel (`pane2`) with a titled border "Sub Panel" and a grid layout of 0 rows x 2 columns.
  - Adds five buttons to `pane2` and two buttons to `pane1`.
  - Nesting: Adds `pane2` to `pane1`, then adds three more buttons to `pane1`.
  - Adds the main panel to the frame and makes it visible.

- **Outcome:**
  - Demonstrates hierarchical panel structure with nested sub-panels and organized button placement.

---

#### JComponent Class
- **Definition:**
  - Generic Swing class.
  - Parent (ancestor) of all Swing components except `JFrame`.

- **Features:**
  - Represents a blank rectangular area, similar to a painter’s canvas.
  - Can be added to a `JPanel`.

- **Customization:**
  - Permits drawing operations by subclassing.
  - Override `void paintComponent(Graphics g)` method to perform custom rendering.

---

#### Graphics / Graphics2D Class
- **Graphics Argument in `paintComponent`:**
  - `Graphics` object provides context for drawing on a `JComponent`.

- **`Graphics2D`:**
  - Subclass of `Graphics` with a more extensive API.
  - Commonly used in custom painting.

- **Boilerplate Code:**
  ```java
  public void paintComponent(Graphics g) {
      super.paintComponent(g); // Ensures proper painting behavior
      Graphics2D g2 = (Graphics2D) g;
      // Custom drawing code
  }
  ```

- **Coordinate System:**
  - Origin (0,0) at the upper-left corner.
  - X-axis increases to the right.
  - Y-axis increases downward.

- **Graphics Context Includes:**
  - Current color (`g2.setColor(Color.RED);`)
  - Current font (`g2.setFont(new Font("Arial", Font.PLAIN, 12));`)
  - Other properties like stroke, transformation, etc.

- **Common Operations:**
  - `g2.drawLine(int x1, int y1, int x2, int y2)`
  - `g2.drawRect(int x, int y, int width, int height)`
  - `g2.fillOval(int x, int y, int width, int height)`
  - `g2.drawString(String s, int x, int y)`

- **Repainting:**
  - Call `repaint()` when the model changes.
  - `repaint()` schedules `paintComponent()` to be called on the EDT.

---

#### Example: `ViewSwing` Class with Custom Painting
```java
import javax.swing.SwingUtilities;
import javax.swing.JFrame;
import javax.swing.JComponent;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;

public class ViewSwing extends JComponent {
    Model model;

    ViewSwing(Model model) {
        this.model = model;
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                createGUI();
            }
        });
    }

    public static void createGUI() {
        JFrame frame = new JFrame();
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        frame.setSize(640, 480);
        frame.add(new ViewSwing(new Model()));
        frame.repaint();
        frame.setVisible(true);
    }

    /**
     * The paintComponent method is called on the EDT in response
     * to a call to repaint().
     */
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g; // Ensures using Graphics2D
        int x = model.getX();
        int y = model.getY();
        int width = model.getWidth();
        int height = model.getHeight();

        g2.drawRect(x, y, width, height);
        g2.setColor(Color.RED);
        g2.fillOval(x, y, width, height);
    }
}
```
- **Components:**
  - **`Model` Class:**
    - Provides data for the view (not detailed here).

  - **`ViewSwing` Constructor:**
    - Initializes with a `Model` instance.
    - Schedules GUI creation on the EDT.

  - **`createGUI()` Method:**
    - Sets up the frame.
    - Adds `ViewSwing` component to the frame.
    - Calls `repaint()` to trigger `paintComponent()`.
    - Makes the frame visible.

  - **`paintComponent(Graphics g)` Method:**
    - Casts `Graphics` to `Graphics2D`.
    - Retrieves coordinates and dimensions from the model.
    - Draws a rectangle and fills an oval with the specified properties.

---

#### Evolution of User Interfaces (UIs)
- **Early Interfaces:**
  - Front panel switches.
    - Simpler and cheaper alternative to keyboards.

- **WIMP Paradigm (50 Years of WIMPs)**
  - **Components:**
    - Window
    - Icons
    - Menus
    - Pointer

  - **Examples:**
    - **Xerox Star (1981):**
      - Early implementation of WIMP.

    - **Windows 2.0 (1987):**
      - Adoption of WIMP concepts in mainstream operating systems.

- **Key Concepts:**
  - **GUI as a Visual Language:**
    - Forms a medium for user interaction through visual elements.

  - **Skeuomorphism:**
    - Design principle where interface objects mimic real-world counterparts.
    - Examples: Trash cans for delete actions, buttons with 3D effects.

  - **Desktop Metaphor:**
    - Conceptual model where the GUI resembles a physical desktop.
    - Eventually evolved beyond the traditional desktop metaphor.

  - **Post-WIMP Interfaces:**
    - E.g., Android and iOS smartphones.
      - Emphasis on touch and multi-touch gestures.
      - Viewed as two-dimensional UIs.

  - **Future Directions:**
    - Exploration of three-dimensional UIs for more immersive interactions.

---

#### Factory Pattern in GUI Construction
- **Usage:**
  - Centralizing object creation for consistency and reusability.

- **Example: `BorderFactory`**
  - **Methods:**
    - `BorderFactory.createLineBorder(Color.RED)`
    - `BorderFactory.createTitledBorder("Sub Panel")`
  - **Advantages:**
    - Encapsulates creation logic.
    - Provides pre-configured objects.
    - Facilitates reuse of shared, read-only components.

---

### Summary of Key Topics
- **GUI Construction:**
  - Frames, Panels, and Widgets are fundamental components.
  - Layout Managers (`BorderLayout`, `FlowLayout`, `GridLayout`) control component arrangement.

- **Event Handling:**
  - Employ listeners (`ActionListener`, `MouseListener`, etc.) to respond to user interactions.
  - Implement listeners via named classes, nested classes, or anonymous inner classes.
  - Utilize adapter classes to simplify handling interfaces with multiple methods.

- **Graphics and Custom Painting:**
  - Override `paintComponent(Graphics g)` in `JComponent` subclasses.
  - Use `Graphics2D` for advanced drawing capabilities.
  - Coordinate system starts at (0,0) in the upper-left corner.

- **Design Patterns:**
  - **MVC:** Separates data, presentation, and control logic.
  - **Factory Pattern:** Streamlines object creation for uniformity and reuse.

- **Evolution of GUIs:**
  - Transition from command-line interfaces to WIMP-based GUIs.
  - Continued evolution towards touch-based and potentially 3D interfaces.

---

### Additional Notes
- Ensure all GUI-related code runs on the EDT to maintain thread safety.
- Use `SwingUtilities.invokeLater` when initializing GUIs.
- Understand the hierarchical nature of GUI components for effective interface design.
- Familiarize with different layout managers to choose the appropriate one based on design requirements.
- Practice implementing event listeners through various techniques to handle user interactions efficiently.
- **clone():**
  - Creates and returns a copy of the object.

- **equals(Object e):**
  - Compares the current object with another for equality.
  - **Default Behavior:**
    - Uses `==` to check reference equality.
  - **Override Requirement:**
    - To compare object content, override `equals(Object e)`.
    - Must preserve the parameter type as `Object`.

- **toString():**
  - Returns a `String` representation of the object.
  - **Usage:**
    - Called by `printf` and similar methods when a `String` is needed.
  - **Customization:**
    - Override to provide a more descriptive representation of the object.

## Constructor Chaining

- **Purpose:**
  - Ensures all constructors in the inheritance chain initialize the object properly.

- **Java Enforcement:**
  - Implicitly inserts calls to superclass constructors (`super()`).

- **Customization:**
  - Override default behavior by explicitly calling `super(...)` or `this(...)`.

### Constructor Rules

- **Mandatory Constructor:**
  - Every class must have at least one constructor.

- **First Statement Requirement:**
  - The first line of every constructor must call another constructor:
    - Either `this(...)` to call another constructor in the same class.
    - Or `super(...)` to call a constructor in the superclass.

### Default Constructors

- **Automatic Provision:**
  - If no constructors are provided, Java supplies a default constructor:
    ```java
    public ClassName() {
        super();
    }
    ```
  - **Function:**
    - Calls the zero-argument constructor of the superclass.

### Default Chaining

- **Behavior When Constructor Provided:**
  - Java automatically inserts `super();` at the beginning of the constructor to enforce chaining.

### Explicit Chaining

- **Manual Invocation:**
  - Explicitly call a superclass constructor using `super(arguments)`.

- **Use Case:**
  - Pass arguments to superclass constructors to initialize inherited fields.

- **Example:**
  ```java
  public class Student extends Person {
      public Student(String name, String address) {
          super(name, address);
          // Initialize Student-specific fields
      }
  }
  ```

### Constructor Complications

- **Absence of Parameterless Constructor:**
  - If the base class lacks a parameterless constructor, derived class constructors must explicitly call an available superclass constructor with appropriate arguments.

- **Result of Missing super(...):**
  - Leads to a syntax error if Java inserts `super()` automatically and it's unavailable.

### super() and this()

- **this(...):**
  - Calls another constructor within the same class.
  - Prevents automatic call to `super()`.

- **super(...):**
  - Calls a constructor in the superclass.

- **Rules:**
  - Only one constructor call (`super(...)` or `this(...)`) is allowed per constructor.
  - Must be the first statement in the constructor to ensure proper initialization.

## Wheel Example

```java
public class Wheel {
    private double radius;

    public Wheel(double radius) {
        this.radius = radius;
    }
}

public class Tire extends Wheel {
    private double width;

    public Tire(double radius, double width) {
        // super(radius); // Must call superclass constructor
        this.width = width; // Error: missing super(radius) leads to syntax error
    }
}
```
- **Issue:**
  - Without an explicit call to `super(radius)`, Java inserts `super()`, which doesn't exist in `Wheel`, causing a syntax error.

## Terminology

- **Inheritance Hierarchy:**
  - **Student extends Person**
    - **Student:** Subclass, child class, derived class.
    - **Person:** Superclass, parent class, base class.

- **Conceptual Understanding:**
  - **Superclass/Subclass vs. Superset/Subset:**
    - Subclass contains more specific features, analogous to a subset.
    - Superclass is a more general category, analogous to a superset.

## More Inheritance

- **Key Topics:**
  - Access Restrictions and Visibility
  - Overriding and Hiding
  - `instanceof` Operator

## Subclass Access

- **Access to Superclass Fields:**
  - Subclasses cannot directly access private fields in their superclasses.

- **Solutions:**
  1. **Use Accessors/Mutators:**
     - Provide public or protected getter and setter methods in the superclass.
  2. **Change Access Modifier:**
     - Change private fields to `protected` to allow subclass access.

- **Best Practice:**
  - Prefer using accessors and mutators to maintain encapsulation.

## More Java Access Modifiers

- **Applicability:**
  - Can apply to class members: fields and methods.

- **Purpose:**
  - Control access from methods in other classes.

- **Access Levels (Least to Most Restrictive):**
  1. **public:**
     - No restrictions; accessible from any other class.
  2. **protected:**
     - Accessible within the same package and by subclasses in different packages.
  3. **[none] (Package Private):**
     - Accessible only within the same package.
  4. **private:**
     - Accessible only within the declaring class.

## Overloading vs Overriding

- **Overloading:**
  - Occurs within the same class.
  - Methods have the same name but different signatures (parameter lists).
  - **Example:**
    ```java
    public void display(int a);
    public void display(String a);
    ```

- **Overriding:**
  - Occurs between superclass and subclass.
  - Methods have the same name and identical signatures.
  - **Example:**
    ```java
    // In superclass
    public void display();

    // In subclass
    @Override
    public void display() {
        // Customized behavior
    }
    ```

## Overriding Methods

- **Definition:**
  - A subclass method with the same signature as a superclass method overrides the superclass method.

- **Behavior:**
  - The overridden method in the subclass is executed instead of the superclass method.

- **Purpose:**
  - Allows altering or extending the behavior of inherited methods for subclass-specific functionality.

- **Inheritance:**
  - Methods not overridden are inherited and available to the subclass.

## Accessing Overridden Methods

- **Using `super`:**
  - Access the superclass version of an overridden method within the subclass.
  - **Syntax:**
    ```java
    super.methodName(arguments);
    ```

- **Example:**
  ```java
  public class Student extends Person {
      @Override
      public void display() {
          super.display(); // Calls Person's display method
          System.out.println(classes, grades);
      }
  }
  ```

## Overriding Methods Examples

### Example 1

```java
public class Person {
    public void display() {
        System.out.println(name, address);
    }
}

public class Student extends Person {
    @Override
    public void display() {
        System.out.println(getName(), getAddress(), classes, grades);
    }
}
```
- **Behavior:**
  - `Student`'s `display` method overrides `Person`'s `display` method.
  - Outputs additional fields specific to `Student`.

### Example 2

```java
public class Person {
    public void display() {
        System.out.println(name, address);
    }
}

public class Student extends Person {
    @Override
    public void display() {
        super.display(); // Calls Person's display
        System.out.println(classes, grades);
    }
}
```
- **Behavior:**
  - `Student`'s `display` method first calls `Person`'s `display` method using `super.display()`.
  - Then, it prints additional `Student`-specific fields.

## The instanceof Operator

- **Purpose:**
  - Determines if an object is an instance of a specific class or its subclasses.

- **Syntax:**
  ```java
  (objectA instanceof ClassB)
  ```

- **Evaluation:**
  - Returns `true` if `objectA` is an instance of `ClassB` or any subclass of `ClassB`.

- **Example:**
  ```java
  Person pers = (Person) ois.readObject();
  if (pers instanceof Student) {
      // Executes if pers is a Student instance
  }
  ```

## Exception Class Hierarchy

- **Top-Level Class:**
  - `Exception`

- **Subclasses:**
  - `IOException`
    - `FileNotFoundException`
  - `RuntimeException`
    - `ArithmeticException`
    - `NullPointerException`
    - `IndexOutOfBoundsException`
  - `YourException` (User-Defined)

## Making Your Own Exception Class

- **Custom Exception Example: StudentNotFoundException**

  ```java
  public class StudentNotFoundException extends Exception {
      public StudentNotFoundException(String message) {
          super(message);
      }
  }
  ```

- **Usage in a Class: FindStudent**

  ```java
  public class FindStudent {
      public Student search(int studentId) throws StudentNotFoundException {
          if (/* condition to find student */) {
              // Student not found
              throw new StudentNotFoundException(Integer.toString(studentId));
          }
          // Return found student
      }
  }
  ```

- **Key Points:**
  - **Inheritance:**
    - Custom exception extends `Exception` to create a checked exception.
  - **Constructor:**
    - Passes error message to superclass constructor.
  - **Throwing Exception:**
    - Use `throw` to raise the custom exception when specific error conditions are met.
  - **Method Signature:**
    - Declares `throws StudentNotFoundException` to indicate the method may throw this exception.

## Summary of Key Concepts

- **Inheritance:** Mechanism where one class (subclass) inherits fields and methods from another (superclass).

- **Access Modifiers:** Control visibility and access to class members (`public`, `protected`, package-private `[none]`, `private`).

- **Constructor Chaining:** Ensures proper initialization by calling superclass constructors, either implicitly or explicitly.

- **Method Overriding:** Allows a subclass to provide a specific implementation of a method already defined in its superclass.

- **instanceof Operator:** Checks an object's type at runtime to determine class membership.

- **Exception Handling:** Organizes error handling through a hierarchy of exception classes, enabling custom exceptions for specific scenarios.
### Success Tips

- **Start Assignments Early**
  - Prevents mental blocks by allowing breaks before deadlines.
  - Taking a break can provide fresh perspectives to resolve issues.
  - Essential for handling assignments with challenging problems.

### Numbers and Mathematical Operators

#### Types

- **Primitive Types**
  - Built-in to Java.
  - **List of Primitive Types:**
    - `boolean`: true, false.
    - `byte`: 8 bits, range -128 to 127.
    - `short`: 16 bits, range -32,768 to 32,767.
    - `int`: 32 bits, range -2,147,483,648 to 2,147,483,647.
    - `long`: 64 bits, can represent values up to 18 digits.
    - `float`: 32 bits, single precision.
    - `double`: 64 bits, double precision.
    - `char`: Represents single characters.
  - Fixed size in bytes.
  - Store values directly in memory.

- **Reference Types**
  - Defined by the programmer.
  - Hold references (pointers) to objects in memory.
  - Examples: `String`, `Scanner`, `LinkedList`, custom classes like `Wheel`.
  - Size varies based on the object.
  - Managed through the heap memory.

#### Values

- **Definition**
  - Data referred to by program source code.
  - Processed by CPUs, GPUs during execution.
  - Stored in computer working memory.
  - Accessed via memory addresses identified by bit strings.

#### Values and Literals

- **Literals**
  - Fixed values in source code.
  - Appear as character strings.
  - **Examples:**
    - Numeric: `-3`, `-23`, `4.5`, `0.23`, `3E8`, `6.02e+23`.
    - String/Character: `"Hello there"`, `'A'`.
    - Boolean: `true`, `false`.
  - Stored in guarded memory locations to maintain immutability.

#### Values Identified by Variables

- **Variables**
  - Abstract symbols/names in source code.
  - **Example Names:** `x`, `y`, `a`, `b`, `helloMessage`, `wheel`, `robot`, `r1`, `w27`.
  - Identify memory locations chosen by compiler/interpreter.
  - Values can be changed during program execution.

#### Values Identified by Constants

- **Constants**
  - Abstract symbols/names in source code.
  - **Example Declarations:**
    - `final double PI = 3.14159;`
    - `final String LOCAL_TIME_ZONE = "EST";`
  - Memory locations chosen by compiler/interpreter.
  - Values immutable during program execution.

### Naming Constants and Variables

- **Conventions**
  - Start with a letter.
  - Followed by letters, digits, or underscores (`_`).
- **Best Practices**
  - **Variables:** Use camelCase (e.g., `helloMessage`).
  - **Constants:** Use uppercase letters with underscores (e.g., `PI`, `LOCAL_TIME_ZONE`).
- **Memory Management**
  - Compiler/interpreter assigns memory locations.
  - Symbol table maintains mappings: `(name, address)` pairs.

### Types

- **Definition**
  - A formal definition consisting of a set of values and operations.
- **Examples of Types:**
  - `int`
  - `double`
  - `String`

#### Example Java Type: `int`

- **Set of Values**
  - Subset of integers.
  - Stored in 4 bytes (32 bits).
  - Range: `-2,147,483,648` to `2,147,483,647`.
  - **Literals:** `23`, `45`, `-19`, `0`.
  - Declared using the reserved word `int`.
- **Set of Operations**
  - Standard mathematical: `+`, `-`, `*`.
  - Division: `/` performs integer division (truncates fractional part).
  - Modulus: `%` (e.g., `17 % 3 = 2`).

### Type Categories in Java

#### Primitive Types

- **Characteristics**
  - Built into Java.
  - Fixed size in bytes.
  - Directly store values.
- **List of Primitive Types:**
  - `boolean`, `byte`, `short`, `int`, `long`, `float`, `double`, `char`.

#### Reference Types

- **Characteristics**
  - Defined by the programmer.
  - Hold references to objects.
  - Symbolic names point to memory addresses storing objects.
  - Size depends on the object’s requirements.
- **Examples:**
  - `String`
  - Custom classes like `Wheel`.

### Example Reference Type: `String`

- **Set of Values**
  - Sequences of characters.
  - Length ranges from `0` to `2,147,483,647`.
- **Set of Operations**
  - `concat()` and `+` operator for concatenation.
  - `toUpperCase()`.
  - `length()`.
  - `substring()`.
  - Additional methods available in the Java `String` class.

#### `String` Operations Example

```java
String school = "Purdue";
String univ = "University";
String s1 = school.concat(univ); // "PurdueUniversity"
String s2 = school + " " + univ; // "Purdue University"
String s3 = school.toUpperCase(); // "PURDUE"
```

### Example Reference Type: `Wheel`

```java
public class Wheel {
    double radius;

    Wheel(double radius) {
        this.radius = radius;
    }

    double getCircumference() {
        return 2 * Math.PI * radius;
    }

    double getArea() {
        return Math.PI * radius * radius;
    }

    double getRadius() {
        return radius;
    }
}
```

- **Set of Values**
  - Cardinality limited by memory size.
  - Each `new Wheel(...)` creates a distinct memory location.
  - Instances can have identical or varying `radius` values.
- **Set of Operations**
  - `getArea()`: Calculates area (`πr²`).
  - `getCircumference()`: Calculates circumference (`2πr`).
  - `getRadius()`: Retrieves the radius value.

### Declarations

- **Java Variable Declaration**
  - Must declare variables with a type.
  - **Syntax Examples:**
    - `int x;` // Declare only
    - `int x = 5;` // Declare and initialize
    - `int x, y;` // Declare two variables
    - `int x = 5, y = 10;` // Declare and initialize two variables
- **Best Practices**
  - Declare one variable per line.
  - Include comments explaining the variable’s purpose.
    - Example: `int mass; // mass of the particle`

### Primitive Types

#### Integer and Real Number Types

##### Integer Types in Java

- **Characteristics**
  - Represent subsets of integers.
  - Differ by number of bits used, affecting range and storage.
- **List of Integer Types:**
  - `byte`: 8 bits, range `-128` to `127`.
  - `short`: 16 bits, range `-32,768` to `32,767`.
  - `int`: 32 bits, range `-2,147,483,648` to `2,147,483,647`.
  - `long`: 64 bits, can represent values up to 18 digits.
- **Most Popular Type:** `int`.

##### Operations on Integer Types

- **Mathematical Operations:**
  - Addition (`+`), Subtraction (`-`), Multiplication (`*`), Division (`/`), Modulus (`%`).
- **Integer Division**
  - Performs “integer divide” resulting in an integer.
  - Truncates fractional parts (“rounding towards zero”).
  - **Examples:**
    - `10 / 5 = 2`
    - `13 / 4 = 3`
    - `3 / -2 = -1`
    - `1 / 2 = 0`

##### Real Number Types in Java

- **Characteristics**
  - Represent subsets of real numbers.
  - Differ by number of bits used.
- **List of Real Types:**
  - `float`: 32 bits, single precision.
  - `double`: 64 bits, double precision.
- **Most Popular Type:** `double`.

##### Operations on Real Types

- **Mathematical Operations:**
  - Addition (`+`), Subtraction (`-`), Multiplication (`*`), Division (`/`).
- **Java Math Class Operations:**
  - `Math.pow(base, exponent)`.
  - `Math.log10(number)`.
  - Trigonometric functions: `Math.sin()`, `Math.cos()`, etc.
- **Reference:** [Java Math API](https://docs.oracle.com/javase/6/docs/api/java/lang/Math.html)

### Expressions

- **Definition**
  - Combination of variables, literals, and operators.
  - **Components:**
    - **Variables:** e.g., `x`, `y`.
    - **Literals:** e.g., `3`, `27`.
    - **Operators:** e.g., `+`, `-`, `*`, `/`.
- **Mathematical Precedence**
  - **Order of Operations:**
    1. Multiplication and Division (`*`, `/`)
    2. Addition and Subtraction (`+`, `-`)
- **Example Expression**
  - `x = b + c * d - a / b / d;`
  - Equivalent to: `x = ((b + (c * d)) - ((a / b) / d));`

### Operator Precedence (Highest to Lowest)

1. **Unary Operators**
   - `+expr`, `-expr`
2. **Multiplicative Operators**
   - `*`, `/`, `%`
3. **Additive Operators**
   - `+`, `-`
4. **Shift Operators**
   - `<<`, `>>`, `>>>`
5. **Bitwise Operators**
   - `&`, `^`, `|`
6. **Logical Operators**
   - `&&`, `||`
7. **Assignment Operator**
   - `=`
- **Reference for Complete List:** [Java Operators](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html)

### Summary of Key Points

- **Values:** Fundamental data processed by programs, stored in memory, accessed via addresses.
- **Literals vs. Variables vs. Constants:**
  - **Literals:** Fixed values in code.
  - **Variables:** Mutable storage identified by names.
  - **Constants:** Immutable values identified by names.
- **Types:** Define sets of values and permissible operations.
- **Primitive vs. Reference Types:**
  - **Primitive:** Directly store values, fixed size.
  - **Reference:** Store references to objects, flexible size.
- **Declarations:** Essential for type safety and memory management.
- **Expressions and Precedence:** Critical for correct computation and program logic.
### Concurrency and Synchronization

#### Sequential vs. Concurrent

- **Sequential Execution**
  - Single thread of execution.
  - Single Program Counter (PC) tracks the current instruction.

- **Concurrent Execution**
  - Multiple threads running simultaneously.
  - Multiple PCs, one for each thread.

#### Models of Concurrency

- **Shared Memory Architecture (Java)**
  - Single program with multiple threads sharing the same memory space.
  - Threads can access and modify shared variables.

- **Message Passing**
  - Communication via messages between separate processes.
  - Typically one process per program.
  - Processes may run on different physical machines.

#### Java Threads

- **Thread Class**
  - Contains a `run()` method.
  - Import with `import java.lang.*;`.
  - Creation examples:
    ```java
    Thread t = new Thread();
    Thread t = new Thread(task);
    ```

- **Runnable Interface**
  ```java
  public interface Runnable {
      void run();
  }
  ```

- **Important Methods**
  - `t.start()`: Initiates the thread, calling `run()` in a new thread.
  - `t.join()`: Waits for thread `t` to complete.
  - `t.run()`: Executes `run()` method in the current thread (not directly called by user code).

#### Three Steps to Create Threads

1. **Implement Runnable**
   ```java
   public class MyTask implements Runnable {
       public void run() { /* Task code */ }
   }
   ```

2. **Construct Thread Object**
   ```java
   Thread t = new Thread(new MyTask());
   ```

3. **Start the Thread**
   ```java
   t.start();
   ```

#### Examples

- **MyTask Example**
  ```java
  public class MyTask implements Runnable {
      public static void main(String[] args) {
          MyTask m = new MyTask();
          Thread t = new Thread(m);
          t.start();
      }

      public void run() {
          System.out.printf("now in %s\n", Thread.currentThread());
      }
  }
  ```

- **MainThread Example**
  ```java
  public class MainThread {
      public static void main(String[] args) {
          Thread t = Thread.currentThread();
          System.out.printf("main thread = %s\n", t);
          System.out.printf("going to sleep...\n");
          try {
              Thread.sleep(5000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.printf("ah, that was nice\n");
          System.out.printf("letting someone else run\n");
          Thread.yield();
          System.out.printf("back\n");
      }
  }
  ```

#### Task and Domain Decomposition

- **Using Concurrent Processing**
  - Decompose large problems into smaller pieces.
  - Two approaches:
    - **Task Decomposition**: Split into multiple subtasks, each running different code on separate cores.
    - **Domain Decomposition**: Divide input data into subdomains, running the same code on different inputs across cores.

- **Task Decomposition**
  - **Benefits**: Enhances responsiveness.
  - **Example**:
    - Video Game:
      - One thread processes player moves.
      - Another thread updates the display.
    - Student Registration:
      - Check prerequisites.
      - Verify schedule availability.
      - Confirm seat availability.
      - Combine results upon completion.

- **Domain Decomposition**
  - **Benefits**: Increases raw speed.
  - **Example**:
    - Factoring a Large Number:
      - Divide trial divisors among threads.
      - Stop all threads when a divisor is found.
    - Word Search Puzzle:
      - Split word list into subsets.
      - Assign each subset to a thread for searching.

- **Matrix Multiplication Example**
  - Divide the matrix product computation across multiple cores.
  - Core 1 computes the top half of the product matrix.
  - Core 2 computes the bottom half.

- **Task Decomposition in Code**
  ```java
  public class Model implements Runnable {
      public void run() { /* Track characters */ }
  }

  public class View implements Runnable {
      public void run() { /* Update GUI */ }
  }

  public class Game {
      public static void main(String[] args) {
          Thread data = new Thread(new Model());
          Thread gui = new Thread(new View());
          data.start();
          gui.start();
          // Additional code...
      }
  }
  ```

#### Synchronization

- **Challenges**
  - Thread execution can be interrupted due to time slicing or higher priority tasks.
  - Threads may proceed at different rates, complicating coordination.

- **Race Conditions**
  - Occur when threads interleave instructions unpredictably.
  - Lead to inconsistent access and modification of shared data.

- **Example of Race Condition**
  ```java
  public class RaceCondition implements Runnable {
      private static int counter;

      public static void main(String[] args) {
          counter = 0;
          Thread t1 = new Thread(new RaceCondition());
          Thread t2 = new Thread(new RaceCondition());
          t1.start();
          t2.start();
          try {
              t1.join();
              t2.join();
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.printf("counter = %d\n", counter);
      }

      public void run() {
          for (int i = 0; i < 10000; i++) {
              counter++;
          }
      }
  }
  ```

- **Two Threads Updating a Counter**
  - **Thread 1**
    ```java
    int t1 = counter;
    t1 = t1 + 1;
    counter = t1;
    ```
  - **Thread 2**
    ```java
    int t2 = counter;
    t2 = t2 + 1;
    counter = t2;
    ```

- **Solution: Synchronize Threads**
  - Use the `synchronized` keyword to prevent race conditions.
  - **Syntax**
    ```java
    synchronized (object) {
        // Modify shared data
    }
    ```
  - **Guidelines**
    - The `object` can be any Java object.
    - Avoid using string literals or boxed primitives (e.g., `Integer(42)`) to prevent unexpected locks.

- **Example: NoRaceCondition**
  ```java
  public class NoRaceCondition implements Runnable {
      private static int counter = 0;
      private static Object gateKeeper = new Object();

      public static void main(String[] args) {
          Thread t1 = new Thread(new NoRaceCondition());
          Thread t2 = new Thread(new NoRaceCondition());
          t1.start();
          t2.start();
          try {
              t1.join();
              t2.join();
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.printf("counter = %d\n", counter);
      }

      public void run() {
          for (int i = 0; i < 10000; i++) {
              synchronized (gateKeeper) {
                  counter++;
              }
          }
      }
  }
  ```

#### Advanced Synchronization

- **Interrupting Threads**
  - `t2.interrupt()`: Sends an interrupt signal to thread `t2`.
  - **Behavior**
    - If `t2` is waiting (e.g., sleeping or joining), an `InterruptedException` is thrown.
    - Otherwise, a flag can be set, and `t2` can check `Thread.interrupted()` to decide on termination.

- **Example: Search for a Student Using Threads**
  ```java
  public class FindStudent implements Runnable {
      private static Student stu = null;
      private static boolean found = false;
      private static int student;
      private Fileserver fileserver;
      private Student maybe = null;

      public FindStudent(Fileserver f) {
          fileserver = f;
      }

      public Student search(int student) throws StudentNotFoundException {
          this.student = student;
          Thread t1 = new Thread(new FindStudent(fileserver1));
          Thread t2 = new Thread(new FindStudent(fileserver2));
          Thread t3 = new Thread(new FindStudent(fileserver3));

          t1.start();
          t2.start();
          t3.start();

          try {
              t1.join();
              t2.join();
              t3.join();
          } catch (InterruptedException e) {
              // Handle interruption
          }

          if (found)
              return stu;
          else
              throw new StudentNotFoundException(Integer.toString(student));
      }

      public void run() {
          while (/* more to read on fileserver */) {
              if (found) return;
              // Read next Student object into maybe
              if (maybe.getID() == student) {
                  stu = maybe;
                  found = true;
              }
          }
      }
  }
  ```

#### Thread States

- **Lifecycle States**
  - **New**: Thread created but not started.
  - **Runnable**: Thread started and ready to run.
  - **Not Runnable**: Thread is sleeping, waiting for I/O, or otherwise blocked.
  - **Terminated**: Thread has completed execution and returned from `run()`.

- **Thread Methods Affecting States**
  - `t.sleep(n)`: Puts the current thread to sleep for `n` milliseconds, allowing others to run.
  - `t.yield()`: Suggests that the current thread relinquishes the CPU, allowing another thread to execute.
  - `start()`: Moves thread from New to Runnable.
  - `run()`: Executes the thread’s task; when completed, thread enters Terminated state.
  - `wait()`, `notify()`: Manage thread synchronization and state transitions between Runnable and Not Runnable.

### Summary

- **Concurrency in Java** involves managing multiple threads that can execute simultaneously.
- **Task and Domain Decomposition** are strategies to break down large problems for concurrent execution.
- **Synchronization** mechanisms, such as the `synchronized` keyword, are essential to prevent race conditions when threads interact with shared data.
- Understanding **Thread States** and methods (`start()`, `join()`, `sleep()`, `yield()`) is crucial for effective thread management and synchronization.
- Proper handling of **race conditions** and synchronization ensures thread-safe operations and predictable program behavior.
### CS18000: Problem Solving and Object-Oriented Programming Notes

#### Video 1: Algorithms, Abstraction, and Number Systems

**Problem Solving**
- **Examples:**
  - Assemble a bookcase: directions
  - Bake a cake: recipe
- **Algorithm:**
  - Step-by-step series of instructions to solve a problem
  - Must be correct, complete, and terminate
- **Abstraction:**
  - Creation of a concept from specific examples

**Von Neumann Architecture**
- **Essential Components:**
  1. **Input/Output Devices (I/O):** Allow user interaction with the computer
  2. **Memory:**
     - Stores information to be processed
     - Stores programs (instructions)
  3. **Central Processing Unit (CPU):** Executes instructions to process information
- **Architecture Characteristics:**
  - Sequential data and instruction processing
  - Shared bus between CPU, memory, and I/O

**Memory and Storage Sizes**
| Unit       | Size (Bytes)       | Practical Measure           |
|------------|--------------------|-----------------------------|
| **byte**   | 8 bits             | 1 byte = single character   |
| **KB**     | 1,024 bytes        | ≈ \(10^3\) bytes = paragraph of text |
| **MB**     | 1,024 KB           | ≈ \(10^6\) bytes = minute of MP3 music |
| **GB**     | 1,024 MB           | ≈ \(10^9\) bytes = half hour of video |
| **TB**     | 1,024 GB           | ≈ \(10^{12}\) bytes = 80% of human's memory capacity |

**Number Systems**
- **Positional Numbering:**
  - Value of a digit depends on its position relative to the decimal point
  - Each position is a multiple/divisor of the base
- **Bases Used:**
  - Binary (2)
  - Octal (8)
  - Decimal (10)
  - Hexadecimal (16)

**Examples of Number Representations**
- **Decimal (Base 10):**
  - \(352 = 3 \times 10^2 + 5 \times 10^1 + 2 \times 10^0 = 300 + 50 + 2\)
- **Binary (Base 2):**
  - \(1110 = 1 \times 2^3 + 1 \times 2^2 + 1 \times 2^1 + 0 \times 2^0 = 8 + 4 + 2 = 14\)
- **Hexadecimal (Base 16):**
  - \(3F = 3 \times 16^1 + 15 \times 16^0 = 48 + 15 = 63\)

**Conversions Between Number Systems**
- **Algorithm:**
  1. Divide number by target base
  2. Prepend remainder to result string
  3. Replace number with quotient
  4. Repeat until quotient is zero
- **Example: Convert 42 to binary**
  - 42 / 2 = 21 remainder 0 → 0
  - 21 / 2 = 10 remainder 1 → 10
  - 10 / 2 = 5 remainder 0 → 010
  - 5 / 2 = 2 remainder 1 → 1010
  - 2 / 2 = 1 remainder 0 → 01010
  - 1 / 2 = 0 remainder 1 → 101010
  - **Answer:** 101010

#### Video 2: Storing Integers

**Finite Precision**
- **Bit Organization:**
  - Bits organized into bytes (8 bits)
  - Bytes into words (typically 4 bytes = 32 bits or 8 bytes = 64 bits)
- **Representation Limits:**
  - Can only represent integers that fit within the allocated bits
- **Handling Negative Numbers:**
  - Use two’s complement representation

**Interpreting Bits**
- **3-bit Word Example:**
  - **Unsigned:** 000 = 0, 001 = 1, ..., 111 = 7
  - **Signed (Two’s Complement):** 000 = 0, 001 = 1, 010 = 2, 011 = 3, 100 = -4, ..., 111 = -1
- **4-bit Word Example:**
  - **Unsigned:** 0000 = 0, ..., 1111 = 15
  - **Signed:** 0000 = 0, ..., 0111 = 7, 1000 = -8, ..., 1111 = -1

**Sign Bit and Two’s Complement**
- **Sign Bit:**
  - Leftmost bit indicates sign: 0 = positive, 1 = negative
- **Two’s Complement Representation:**
  - **Positive Numbers:** Leading zeros to match word size
  - **Negative Numbers:**
    1. Convert positive value to binary
    2. Flip all bits (0 ↔ 1) – one’s complement
    3. Add one to obtain two’s complement
- **Example: Convert -42 to 8-bit binary**
  1. 42 = 00101010
  2. Flip bits = 11010101
  3. Add one = 11010110

**Useful Consequences**
- **Largest Signed Positive Number:** \(2^{N-1} - 1\)
  - Example (8 bits): 01111111 = 127
- **Largest Negative Number:** \(-2^{N-1}\)
  - Example (8 bits): 10000000 = -128

**Potential Issues**
- **Overflow:**
  - Sum of two positive numbers exceeds maximum representable value
  - Example: 127 + 1 in eight bits
- **Underflow:**
  - Difference results in a value below minimum representable
  - Example: -128 - 1 in eight bits
- **Java Behavior:**
  - Java ignores overflow and underflow silently

#### Video 3: Wheel Class

**Wheel Class in Java**
- **Attributes (Instance Variables):**
  - `double radius;`
  - `String material;`
- **Constructors:**
  1. **With Radius and Material:**
     ```java
     Wheel(double radius, String material) {
         this.radius = radius;
         this.material = material;
     }
     ```
  2. **With Only Radius:**
     ```java
     Wheel(double radius) {
         this.radius = radius;
         this.material = "unknown";
     }
     ```
- **Accessor Methods (Getters):**
  - `double getCircumference() { return 2 * Math.PI * radius; }`
  - `double getArea() { return Math.PI * radius * radius; }`
  - `double getRadius() { return radius; }`
  - `String getMaterial() { return material; }`
- **Mutator Methods (Setters):**
  - `void setRadius(double radius) { this.radius = radius; }`
  - `void setMaterial(String material) { this.material = material; }`
  - `void setRadiusAndMaterial(double radius, String material) { this.radius = radius; this.material = material; }`

**Making a Class a Program**
- **Main Method:**
  ```java
  public static void main(String[] args) {
      double area, circ, rad;
      String mat;

      Wheel bicycle = new Wheel(27.5, "rubber");
      Wheel wagon = new Wheel(54.75);
      wagon.setMaterial("wood");

      circ = bicycle.getCircumference();
      area = bicycle.getArea();
      rad = bicycle.getRadius();
      mat = wagon.getMaterial();

      bicycle.setRadius(32.0);
      bicycle.setMaterial("polyethylene");
      wagon.setRadiusAndMaterial(88.35, "aluminum");
  }
  ```
- **Object Instantiation:**
  - `Wheel bicycle = new Wheel(27.5, "rubber");`
  - `Wheel wagon = new Wheel(54.75);`
- **Method Calls:**
  - `wagon.setMaterial("wood");`
  - `circ = bicycle.getCircumference();`
  - `area = bicycle.getArea();`
  - `rad = bicycle.getRadius();`
  - `mat = wagon.getMaterial();`
  - `bicycle.setRadius(32.0);`
  - `bicycle.setMaterial("polyethylene");`
  - `wagon.setRadiusAndMaterial(88.35, "aluminum");`

**Methods and Headers**
- **Method Structure:**
  ```java
  return-type methodName(parameters) {
      // method body
  }
  ```
- **Return Types:**
  - Methods can return values (e.g., `double`) or nothing (`void`)
- **Parameters:**
  - Methods can have no parameters, one, or multiple
- **Method Overloading:**
  - Java selects the method that matches the argument types and number during invocation
- **Examples:**
  - `wagon.setRadiusAndMaterial(88.35, "aluminum");` uses the method with `double` and `String` parameters
  - `Wheel wagon = new Wheel(54.75);` uses the constructor with only a `double` parameter

#### Software Development

**Software Development Lifecycle**
1. Understand the problem
2. Design a solution
3. Implement the solution
4. Test the solution
5. Maintenance

**How is Software Written?**
- **Programming Languages:**
  - **High-Level Languages:** Use complex statements (e.g., Java, Python)
  - **Assembly Languages:** Use very simple instructions
  - **Machine Languages:** Use binary code (1s and 0s)
- **Compilers and Interpreters:**
  - **Compiler:** Translates high-level code to machine language before execution
  - **Interpreter:** Executes code line-by-line directly
- **Integrated Development Environments (IDEs):**
  - Facilitate editing, compiling, executing, and debugging programs
  - Examples: IntelliJ, Eclipse

**Program Translation**
- **High-Level to Machine Language:**
  - **C Example:**
    ```c
    #include <stdio.h>
    int main() {
        printf("Hello!");
        return 0;
    }
    ```
    - Compiled to machine language directly executable by CPU
- **Python Example:**
  ```python
  print("Hello!")
  ```
    - Interpreted line-by-line by the interpreter on CPU
- **Java Example:**
  ```java
  public class HelloWorld {
      public static void main(String[] args) {
          System.out.println("Hello World");
      }
  }
  ```
    - Compiled to bytecode, then executed by the JVM with Just-In-Time (JIT) compilation to machine language

#### Tools for Abstraction

**Object-Oriented Programming (OOP)**
- **Class:**
  - Template for creating objects (instances)
  - Examples: Wheel, Robot, Car, Chair
  - Contains variables and methods defining the abstraction
- **Variable:**
  - Names and stores a quantity
  - Examples: radius, name, speed, color
- **Method:**
  - Names and defines operations on a class or object
  - Examples: getArea, speak, accelerate, eject

**Class vs. Program**
- **Class:**
  - Blueprint for objects, can contain multiple methods and variables
- **Program:**
  - Contains a `main` method where execution starts
  - Example classes: Robot.java, Calculator.java

**Examples of Classes**
- **Robot.java:**
  ```java
  public class Robot {
      void speak(String message) {
          System.out.println(message);
      }

      public static void main(String[] args) {
          Robot r = new Robot();
          r.speak("hello world");
      }
  }
  ```
- **Calculator.java:**
  ```java
  import java.util.Scanner;

  public class Calculator {
      int add(int x, int y) {
          return x + y;
      }
      int subtract(int x, int y) {
          return x - y;
      }
      public static void main(String[] args) {
          Calculator c = new Calculator();
          Scanner scanner = new Scanner(System.in);
          int x = scanner.nextInt();
          int y = scanner.nextInt();
          System.out.println(c.add(x, y));
          System.out.println(c.subtract(x, y));
      }
  }
  ```

#### Java Basics

**Program Structure**
- **Top-Level Class:**
  - Name matches the file name (e.g., `class Robot` in `Robot.java`)
- **Methods:**
  - Contains one or more methods, including `main`
- **Execution:**
  - Begins at the `main` method
- **Input and Output:**
  - **Input:** `Scanner` class
  - **Output:** `System.out.println(...)`

**Syntax Details**
- **Comments:**
  - Single-line: `//`
  - Multi-line: `/* */`
- **Whitespace:**
  - Ignored, used to delimit tokens
- **Statements:**
  - End with a semicolon `;`
- **Grouping:**
  - Use curly braces `{ }` to group statements
- **Reserved Words:**
  - Cannot be used as names for variables, methods, or classes
- **Import Statement:**
  - Access other classes (e.g., `import java.util.Scanner;`)

**System Class**
- **Members:**
  - `System.in`: Input stream
  - `System.out`: Output stream
- **Usage:**
  - In command-line systems, can be linked to keyboard/display or redirected

**Parsing Input with Scanner**
- **Creating Scanner Object:**
  ```java
  Scanner s = new Scanner(System.in);
  ```
- **Reading Input:**
  - `String name = s.nextLine();`
  - `int i = s.nextInt();`
  - `double d = s.nextDouble();`

**Java Formatting Notes**
- **Naming Conventions:**
  - Variables: `lowerCamelCase`
  - Classes: `UpperCamelCase`
  - Symbolic Constants: `UPPER_CASE`
- **Brace Placement:**
  - Open curly brace `{` at the end of the line
- **Indentation:**
  - Use consistent indentation (e.g., 4 spaces)
- **Documentation:**
  - Complete documentation available on course website

**How to Read an Assignment**
1. **Creating a Class:**
   - When instructed to “Create a class Henway”:
     - Create `Henway.java` with:
       ```java
       public class Henway {
       }
       ```
     - Ensure correct capitalization
     - Compile to check for errors; running it may cause an error due to missing `main` method
2. **Writing a Java Program:**
   - When instructed to “Write a Java program named Henway”:
     - Create `Henway.java` with:
       ```java
       public class Henway {
           public static void main(String[] args) {
               // Program execution begins here
           }
       }
       ```
     - Compile and run to ensure no errors and no output
3. **Reading from Standard Input:**
   - **Import Scanner:**
     ```java
     import java.util.Scanner;
     ```
   - **Initialize Scanner in main method:**
     ```java
     Scanner scanner = new Scanner(System.in);
     ```
   - **Read Input:**
     ```java
     int x = scanner.nextInt();
     ```

### Summary of Key Concepts
- **Algorithm and Abstraction** are fundamental to problem-solving in programming.
- **Von Neumann Architecture** outlines the basic components of modern computers.
- **Number Systems**: Understanding binary, decimal, and hexadecimal representations is crucial.
- **Finite Precision**: Limits in representing integers and handling negative numbers using two’s complement.
- **Object-Oriented Programming**: Classes, objects, methods, and encapsulation are core principles.
- **Software Development Lifecycle**: From understanding the problem to maintenance.
- **Java Programming Basics**: Syntax, program structure, input/output, and formatting conventions.

### Additional Resources
- **Useful Site for Two’s Complement Calculations:** [PlanetCalc](http://planetcalc.com/747/)
### CS18000: Problem Solving and Object-Oriented Programming
#### Dynamic Data Structures

---

#### **Progression through CS180**
1. **Basics** (Chapters 1 & 2)
2. **Primitives** (Chapter 3)
3. **Selection** (Chapter 4)
4. **Repetition** (Chapter 5)
5. **Methods/Classes** (Chapters 8 & 9)
6. **Arrays, File I/O, Exceptions** (Chapters 6, 12, & 20)
7. **Interfaces, Inheritance** (Chapters 10 & 11)
8. **Polymorphism** (Chapter 17)
9. **Concurrency** (Chapters 13 & 14)
10. **Networking I/O** (Chapter 21)
11. **Simple GUI** (Chapter 7)
12. **Complex GUI** (Chapter 15)
13. **Dynamic Data Structures** (Chapter 18)
14. **Recursion** (Chapter 19)

---

### **Dynamic Data Structures Overview**
- **Dynamic Data Structures** allow memory usage to grow and shrink as necessary.
- Key types:
  - **Dynamic Arrays (e.g., ArrayList)**
  - **Linked Lists**
  - **Stacks**
  - **Queues**
  - **HashMaps**
- **Niklaus Wirth:** “Algorithms + Data Structures = Programs”

---

### **Definitions**
- **Data Structure:** A method to organize, store, and retrieve information in a program.
- **Dynamic Data Structure:** Can grow and shrink in memory as needed to store information.

---

### **ArrayList**
- **Characteristics:**
  - Similar to arrays but can dynamically grow as elements are added.
  - Implements abstraction through class definition with accessor and mutator methods.
- **Implementation:**
  - **Underlying Structure:** Fixed-size array.
  - **Key Attributes:**
    - `private String[] strings;`
    - `private int size;`
  - **Key Methods:**
    - **Constructor:** Initializes array with default capacity (e.g., 10) and sets size to 0.
    - `get(int i)`: Returns element at index `i`.
    - `set(int i, String s)`: Sets element at index `i` to `s`.
    - `add(String s)`: Adds element `s` to the end, reallocates if necessary.
    - `reallocate()`: Doubles array size, copies elements to new array, and frees old array.
    - `toArray()`: Converts ArrayList to a standard array.
- **Example Implementation:**
  ```java
  public class ArrayList<Ty> {
      private Ty[] values;
      private int size;

      public ArrayList() {
          values = (Ty[]) new Object[10];
          size = 0;
      }

      public Ty get(int i) {
          return values[i];
      }

      public void set(int i, Ty s) {
          values[i] = s;
      }

      public void add(Ty item) {
          if (size >= values.length)
              reallocate();
          values[size++] = item;
      }

      private void reallocate() {
          Ty[] newvalues = (Ty[]) new Object[values.length * 2];
          for (int i = 0; i < size; i++)
              newvalues[i] = values[i];
          values = newvalues;
      }
  }
  ```

- **Limitations:**
  - **Type Restriction:** Holds only one type (e.g., String). To store multiple types, use generics.
  - **Efficiency:** Doubling size can lead to wasted memory and time during reallocation.
  - **Solution:** Use Linked Lists for scenarios with frequent insertions and deletions.

---

### **Linked Lists**
- **Definition:** An ordered sequence of objects called nodes. Each node contains a value and a pointer/link to the next node.
- **Characteristics:**
  - **Dynamic Resizing:** Efficient at inserting and deleting nodes.
  - **Memory Allocation:** Nodes can be anywhere in memory; linked via pointers.
  - **Singly-Linked List:** Each node points only to the next node.

- **Operations:**
  - **Insertion:**
    1. Create a new node with the desired value.
    2. Point the new node's link to the current head.
    3. Update the head to the new node.
    - **Time Complexity:** O(1) when inserting at the head.
  - **Deletion:**
    1. Search for the node to delete while keeping track of the previous node.
    2. Update the previous node’s link to skip the deleted node.
    3. Reclaim memory used by the deleted node.
    - **Time Complexity:** O(n) for searching, O(1) for deletion once node is found.
  - **Searching:**
    1. Begin at the head node.
    2. Traverse nodes sequentially.
    3. Compare each node’s value with the search key.
    - **Time Complexity:** O(n)

- **Example Implementation:**
  ```java
  public class LinkedList {
      private Node head;
      private Node tail;
      private int size;

      private class Node {
          String value;
          Node link;

          Node(String value) {
              this.value = value;
              size++;
          }
      }

      public LinkedList() {
          head = tail = null;
          size = 0;
      }

      public void add(String s) {
          Node n = new Node(s);
          if (head == null)
              head = n;
          if (tail != null)
              tail.link = n;
          tail = n;
      }

      public int getSize() {
          return size;
      }

      public String[] toArray() {
          String[] array = new String[size];
          int i = 0;
          Node node = head;
          while(node != null) {
              array[i++] = node.value;
              node = node.link;
          }
          return array;
      }
  }
  ```

- **Problems in Version 1:**
  - **Reverse Order:** New nodes are added at the head, resulting in the most recently added node appearing first in the array.
  - **Solution:** Introduce a `tail` pointer to allow adding nodes at the end, preserving insertion order.

---

### **Stacks**
- **Abstract Data Type (ADT):** Last In, First Out (LIFO)
- **Operations:**
  - `push(element)`: Add an element to the top.
  - `pop()`: Remove and return the top element.
  - `isEmpty()`: Check if the stack is empty.
- **Uses:**
  - **RPN Expression Evaluation**
  - **Java Virtual Machine:** Managing method execution and local variables.
  - **Undo Operations**
- **Implementation with Linked List:**
  ```java
  public interface Stack {
      boolean isEmpty();
      void push(int value);
      int pop();
  }

  public class LinkedListStack implements Stack {
      private class Node {
          int value;
          Node link;
      }
      private Node head = null;

      public void push(int x) {
          Node n = new Node();
          n.value = x;
          n.link = head;
          head = n;
      }

      public int pop() {
          if (isEmpty())
              throw new RuntimeException("Can't pop empty stack");
          int value = head.value;
          head = head.link;
          return value;
      }

      public boolean isEmpty() {
          return head == null;
      }
  }
  ```
- **Implementation with Array:**
  ```java
  public class ArrayStack {
      private int[] array;
      private int size;

      public ArrayStack(int capacity) {
          array = new int[capacity];
          size = 0;
      }

      public boolean isEmpty() {
          return size == 0;
      }

      public void push(int value) {
          if (size >= array.length)
              throw new RuntimeException("Stack overflow");
          array[size++] = value;
      }

      public int pop() {
          if (isEmpty())
              throw new RuntimeException("Can't pop empty stack");
          return array[--size];
      }
  }
  ```
- **Java Collections:**
  - `java.util.Stack`
  - `java.util.Deque` (for more generalized stack operations)

---

### **Queues**
- **Abstract Data Type (ADT):** First In, First Out (FIFO)
- **Operations:**
  - `add(element)` / `enqueue(element)`: Add an element to the end.
  - `remove()` / `dequeue()`: Remove and return the front element.
  - `peek()`: View the front element without removing it.
  - `isEmpty()`: Check if the queue is empty.
- **Uses:**
  - **Print Queues:** Managing print jobs.
  - **CPU Scheduling:** Managing thread/process execution.
  - **Network Packets:** Managing data transmission.
  - **Producer/Consumer Models:** Handling tasks generated by producers to be processed by consumers.
- **Implementation with Linked List:**
  ```java
  public interface Queue {
      boolean isEmpty();
      void add(int value);
      int remove();
      int peek();
  }

  public class LinkedListQueue implements Queue {
      private class Node {
          int value;
          Node link;

          Node(int value) {
              this.value = value;
          }
      }

      private Node head = null;
      private Node tail = null;

      public boolean isEmpty() {
          return head == null;
      }

      public void add(int value) {
          Node node = new Node(value);
          if (isEmpty()) {
              head = tail = node;
          } else {
              tail.link = node;
              tail = node;
          }
      }

      public int remove() {
          if (isEmpty())
              throw new RuntimeException("Can’t remove from empty queue");
          int value = head.value;
          head = head.link;
          if (head == null)
              tail = null;
          return value;
      }

      public int peek() {
          if (isEmpty())
              throw new RuntimeException("Can’t peek empty queue");
          return head.value;
      }
  }
  ```
- **Java Collections:**
  - `java.util.Queue`
  - `java.util.Deque` (supports both queue and stack operations)

---

### **Generic Classes**
- **Purpose:** To allow data structures to handle multiple data types without rewriting code.
- **Syntax:** Use `<T>` to denote type parameters.
- **Examples:**
  ```java
  Stack<Integer> integerStack = new Stack<>();
  ArrayList<String> stringList = new ArrayList<>();
  ```

- **Implementing Generic ArrayList:**
  ```java
  public class ArrayList<Ty> {
      private Ty[] values;
      private int size;

      public ArrayList() {
          values = (Ty[]) new Object[10];
          size = 0;
      }

      public Ty get(int i) {
          return values[i];
      }

      public void set(int i, Ty s) {
          values[i] = s;
      }

      public void add(Ty item) {
          if (size >= values.length)
              reallocate();
          values[size++] = item;
      }

      private void reallocate() {
          Ty[] newvalues = (Ty[]) new Object[values.length * 2];
          for (int i = 0; i < size; i++)
              newvalues[i] = values[i];
          values = newvalues;
      }
  }
  ```

- **Notes:**
  - Java does not support generic arrays directly. Use an array of `Object` and cast to the generic type.
  - Ensures type safety while providing flexibility.

---

### **HashMap**
- **Definition:** A data structure that stores values referenced by keys, functioning as a dictionary or associative array.
- **Usage:** Maps keys to values, e.g., `"word" -> "definition"`.
- **Syntax:**
  ```java
  HashMap<K, V> map = new HashMap<>();
  map.put("key1", value1);
  V value = map.get("key1");
  ```
- **Example:**
  ```java
  HashMap<String, Tree> map = new HashMap<>();
  map.put("elm", new Tree("elm", 34.5));
  map.put("maple", new Tree("maple", 14.2));
  Tree t = map.get("elm");
  ```
- **Generics in HashMap:**
  - `K`: Type of the key.
  - `V`: Type of the value.
- **Benefits:**
  - Efficient retrieval based on keys.
  - Avoids needing separate structures for different types.

---

### **Java Library Examples**
- **ArrayList**: Dynamic array implementation.
- **Stack, Queue (Interface), Deque (Interface)**: Define operations for stack and queue ADTs.
- **LinkedList**: Implements `List`, `Queue`, and `Deque` interfaces.
- **HashMap**: Stores key-value pairs, implementing the `Map` interface.

---

### **RPN (Reverse Polish Notation) Evaluation**
- **Problem:**
  - Evaluate expressions written in RPN, e.g., `3 5 * 5 - 3 5 + * 2 / = 40`.
- **Approach:**
  - Use a **stack** to handle operands and operators.
- **Example Evaluator:**
  ```java
  public class Evaluator {
      public static int evaluate(String s) {
          Stack stack = new LinkedListStack();
          String[] tokens = s.split(" ");
          for (String token : tokens) {
              if (token.matches("\\d+"))
                  stack.push(Integer.parseInt(token));
              else {
                  int op2 = stack.pop();
                  int op1 = stack.pop();
                  switch(token) {
                      case "+": stack.push(op1 + op2); break;
                      case "-": stack.push(op1 - op2); break;
                      case "*": stack.push(op1 * op2); break;
                      case "/": stack.push(op1 / op2); break;
                      default: throw new RuntimeException("unknown operator");
                  }
              }
          }
          return stack.pop();
      }

      public static void main(String[] args) {
          String s = "3 5 * 5 - 3 5 + * 2 /";
          System.out.printf("%s = %d\n", s, evaluate(s));
      }
  }
  ```

- **Explanation:**
  - **Tokenization:** Split the input string by spaces.
  - **Processing Tokens:**
    - **Operands:** Push onto the stack.
    - **Operators:** Pop two operands, apply the operator, and push the result back.
  - **Result:** The final element on the stack is the evaluated result.

---

### **Abstract Data Types (ADTs)**
- **Definition:** Descriptions of behaviors of data types without specifying implementation.
- **Benefits:**
  - Encapsulation of implementation details.
  - Flexibility for implementers to choose the underlying structure.
- **Common ADTs:**
  - **Stack** (LIFO)
  - **Queue** (FIFO)

---

### **Understanding Implementation vs. Access**
- **Data Structures Provide:**
  - **Access Methods:** How users interact with data (e.g., `add`, `remove`).
  - **Not Implementation Details:** Underlying mechanisms are abstracted.
- **Importance:**
  - Users can utilize data structures without needing to understand their internal workings.
  - Enhances modularity and reusability in code.

---

### **Best Practices**
- **Choose the Right Data Structure:**
  - Based on the operations that are most frequent or critical.
  - E.g., Use Linked Lists for frequent insertions/deletions; Arrays for random access.
- **Implement Abstractions:**
  - Use interfaces to define ADTs.
  - Hide implementation details to allow flexibility.
- **Utilize Generics:**
  - To create versatile and type-safe data structures.
- **Handle Edge Cases:**
  - Implement error checking for operations like `pop` or `remove` on empty structures.

---

### **Key Takeaways**
- **Dynamic Data Structures** are essential for efficient memory management and performance in various programming scenarios.
- **Linked Lists** offer efficient insertions and deletions but have slower search times compared to arrays.
- **Stacks and Queues** are fundamental ADTs with specific use-cases in algorithms and system operations.
- **Generics** in Java provide a way to create flexible and reusable data structures without compromising type safety.
- **HashMaps** are powerful for associating keys with values, enabling fast data retrieval.

---

### **Additional Resources**
- **Start Concurrent: An Introduction to Problem Solving in Java with a Focus on Concurrency**
  - Authors: Wittman, Mathur, and Korb
  - Website: [start-concurrent.github.io](http://start-concurrent.github.io)
- **Java Documentation:**
  - [Stack Class](http://docs.oracle.com/javase/8/docs/api/java/util/Stack.html)
  - [Deque Interface](http://docs.oracle.com/javase/8/docs/api/java/util/Deque.html)
  - [HashMap Class](http://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html)

---

### **Example Problems**
1. **ProcessFile:**
   - **Task:** Read lines from a file with an unknown number of lines and store each line in a data structure.
   - **Solution:** Use a LinkedList to handle dynamic insertions, then convert to an array.
   - **Code Snippet:**
     ```java
     import java.io.File;
     import java.io.FileNotFoundException;
     import java.util.Scanner;

     public class ProcessFile {
         public static void main(String[] args) throws FileNotFoundException {
             LinkedList list = new LinkedList();
             Scanner in = new Scanner(new File("dickens-tale-of-two-cities.txt"));
             while (in.hasNextLine()) {
                 list.add(in.nextLine());
             }

             String[] array = list.toArray();
             System.out.printf("read %d lines\n", list.getSize());
             for (int i = 0; i < array.length; i++)
                 System.out.println(array[i]);
         }
     }
     ```

2. **RPN Evaluator:**
   - **Task:** Evaluate a Reverse Polish Notation expression.
   - **Solution:** Implement a stack-based evaluator.
   - **Code Snippet:** (As provided above under RPN Evaluation)

---

### **Summary**
Understanding dynamic data structures like ArrayLists, Linked Lists, Stacks, Queues, and HashMaps is crucial for efficient problem-solving and programming in Java. Implementing these structures using both arrays and linked constructs allows for flexibility and optimization based on the specific requirements of your application. Utilizing generics enhances the reusability and type safety of these data structures, making your code more robust and maintainable.
**CS18000: Problem Solving and Object-Oriented Programming**
**Simple GUIs: Dialogs**

---

### **Projects and Exam 2**
- **Project 3**
  - Due: 6 pm, Monday, October 28
- **Homework 10**
  - Released for everyone
  - Recommended to attempt before the exam
  - Due: Friday, November 1, 11:59 pm
- **Team Project**
  - Released and team rosters posted on Brightspace
  - If not placed on a team, contact your lab's Lead TA
- **Exam 2**
  - Covers topics from Arrays through Concurrency
  - Scheduled for 8 pm - 10 pm, Monday, October 28
  - No lecture at 8:30 am on exam day

---

### **Simple Graphical User Interfaces (GUIs)**
#### **Text-Based Interface vs. GUI**
- **Text-Based Interface**
  - Program prompts user for data
  - User inputs data via keyboard
  - Output displayed in a terminal window
  - Historical context: terminal served as the window interface
- **Graphical User Interface (GUI)**
  - Window displays a set of controls or widgets
  - User interacts with these controls
  - Program responds to user-generated events with actions

---

### **Dialog Concepts in Java**
- **Prerequisites**
  - Application must run on JVM with a configured window system
  - Windows Subsystem for Linux (WSL) users might require no additional configuration
- **Modal Dialogs**
  - Java dialogs are modal
  - Application code blocks while waiting for user response
  - Similar behavior to using `Scanner` for keyboard input
- **Look and Feel Adaptation**
  - Java GUI components adapt to the local system's "Look and Feel"

---

### **Java History**
- **Abstract Window Toolkit (AWT)**
  - Original approach in Java
  - Development against a GUI abstraction
  - Java utilized native OS components for GUI
  - Goal: "Write once, deploy everywhere"
  - Challenges:
    - Subtle differences and bugs across platforms
    - Necessitated lowest common denominator for components
    - Resulted in "Write once, debug everywhere"
- **Swing Framework**
  - Introduced in Java versions 1.1 and 1.2
  - Access via `import javax.swing.*;`
  - Java "paints" the entire window, managing widgets independently of the OS
  - Attempts to match the native Look and Feel
  - Swing class names typically start with "J" (e.g., `JButton` vs. `java.awt.Button`)

---

### **JOptionPane Class**
- **Overview**
  - Core class for creating modal dialogs in Java Swing
  - Part of the `javax.swing` package
  - Import statement: `import javax.swing.JOptionPane;`
- **Common Static Methods**
  - `showMessageDialog`
  - `showInputDialog`
  - `showConfirmDialog`
  - `showOptionDialog`
- **Common Arguments**
  - **Parent Component**: Location where dialog appears (`null` centers on screen)
  - **Message**: Content of the dialog (can be String, Icon, HTML)
  - **Title**: Window heading string
  - **Message Type**: Determines icon and appearance based on Look and Feel
  - **Option Type**: Specifies default buttons (e.g., Yes/No)
  - **Options**: Custom button labels as an array of Strings
  - **Icon**: Custom icon replacing the default message type icon
  - **Initial Value**: Default selection for certain option types
  - **Note**: Many arguments can be omitted for default behaviors

---

### **Message Type Parameters**
- **Purpose**
  - Selects the icon displayed in the dialog
  - Dependent on the system's Look and Feel
- **Possible Values**
  - `JOptionPane.PLAIN_MESSAGE` (-1)
  - `JOptionPane.ERROR_MESSAGE` (0)
  - `JOptionPane.INFORMATION_MESSAGE` (1)
  - `JOptionPane.WARNING_MESSAGE` (2)
  - `JOptionPane.QUESTION_MESSAGE` (3)

---

### **JOptionPane Methods**
#### **showMessageDialog**
- **Description**
  - Displays a simple message to the user
  - Minimal configuration with additional parameters for appearance
- **Return Type**
  - Void (do-only method)
- **Exceptions**
  - Can throw `HeadlessException` (unchecked)

**Example Usage:**
```java
JOptionPane.showMessageDialog(null, "Thanks for using the Codon Extractor!");
```
- **Parameters:**
  - `null`: Centers the dialog on the screen
  - `"Thanks for using the Codon Extractor!"`: Message displayed

#### **showConfirmDialog**
- **Description**
  - Prompts the user to confirm an action
- **Default Options**
  - "Yes", "No", "Cancel"
- **Return Value**
  - `int` indicating the user's selection
- **Customizable Button Combinations**
  - "Yes" or "No"
  - "OK" or "Cancel"
  - User-defined list of Strings

**Example Usage:**
```java
int result = JOptionPane.showConfirmDialog(null,
    "Do you want to continue?",
    "Codon Extractor",
    JOptionPane.YES_NO_OPTION);
```
- **Parameters:**
  - `null`: Centers the dialog
  - `"Do you want to continue?"`: Confirmation message
  - `"Codon Extractor"`: Title of the dialog
  - `JOptionPane.YES_NO_OPTION`: Specifies "Yes" and "No" buttons

**Return Values:**
- `JOptionPane.YES_OPTION` (0)
- `JOptionPane.NO_OPTION` (1)
- `JOptionPane.CANCEL_OPTION` (2)
- `JOptionPane.CLOSED_OPTION` (-1)

#### **showInputDialog**
- **Description**
  - Prompts the user to enter input
- **Return Value**
  - `String` representing user input
- **Input Types**
  - Freely typed text
  - Selection from a drop-down box or list
- **Creating Drop-Down or List Inputs**
  - Provide an array of Strings and a default value
  - Or provide an array of Objects with a `toString()` method
  - Cast the returned Object to String

**Example Usage:**
```java
String input = JOptionPane.showInputDialog("Enter a DNA sequence");
```

#### **showOptionDialog**
- **Description**
  - Highly customizable dialog with configurable buttons
- **Return Value**
  - Index of the selected button
- **Parameters:**
  - `Component parentComponent`
  - `Object message`
  - `String title`
  - `int optionType`
  - `int messageType`
  - `Icon icon`
  - `Object[] options`
  - `Object initialValue`

---

### **Example Program: CodonExtractor**
**Objective:**
- Read a DNA sequence from the user
- Display codons (sequences of three characters)
- Handle input validity and allow repeated processing until the user opts to exit

**Definitions:**
- **DNA Sequence:** A string composed of characters A, C, G, T
- **Codon:** A substring of three characters from the DNA sequence

**Algorithm:**
1. Prompt the user for a DNA sequence
2. Validate the input
3. Break the DNA sequence into 3-character codons and display them
4. Repeat the process based on user confirmation

**Code Components:**

#### **Main Method**
```java
int continueProgram;

do {
    // Read DNA sequence
    String input = JOptionPane.showInputDialog("Enter a DNA sequence");
    input = input.toUpperCase(); // Convert to uppercase
    String message = "Do you want to continue?";

    if (isValid(input)) // Validate input
        displayCodons(input); // Display codons
    else
        message = "Invalid DNA Sequence.\n" + message;

    continueProgram = JOptionPane.showConfirmDialog(null, message,
        "Alert",
        JOptionPane.YES_NO_OPTION);
} while (continueProgram == JOptionPane.YES_OPTION );

JOptionPane.showMessageDialog(null, "Thanks for using the Codon Extractor!");
```
- **Variables:**
  - `continueProgram`: Controls the loop continuation
- **Process:**
  - User inputs DNA sequence
  - Input is converted to uppercase for consistency
  - Validation performed via `isValid` method
  - If valid, codons are displayed using `displayCodons`
  - If invalid, an error message is concatenated
  - User is prompted to continue or exit
  - Upon exiting, a thank-you message is displayed

#### **isValid Method**
```java
public static boolean isValid(String dna) {
    String validBases = "ACGT";
    for (int i = 0; i < dna.length(); i++) {
        char base = dna.charAt(i);
        if (validBases.indexOf(base) == -1)
            return false; // Invalid base detected
    }
    return true;
}
```
- **Purpose:**
  - Ensures that the DNA sequence contains only valid bases (A, C, G, T)
- **Logic:**
  - Iterates through each character in the input string
  - Checks if the character exists in `validBases`
  - Returns `false` immediately if an invalid base is found
  - Returns `true` if all characters are valid

#### **displayCodons Method**
```java
public static void displayCodons(String dna) {
    String message = "";

    // Extract complete codons
    for (int i = 0; i < dna.length() - 2; i += 3)
        message += "\n" + dna.substring(i, i + 3);

    // Handle remaining bases
    int remaining = dna.length() % 3;
    if (remaining == 1)
        message += "\n" + dna.substring(dna.length() - 1, dna.length()) + "**";
    else if (remaining == 2)
        message += "\n" + dna.substring(dna.length() - 2, dna.length()) + "*";

    message = "DNA length: " + dna.length() + "\n\nCodons: " + message;
    JOptionPane.showMessageDialog(null, message,
        "Codons in DNA",
        JOptionPane.INFORMATION_MESSAGE );
}
```
- **Functionality:**
  - Extracts and formats codons from the DNA sequence
  - Handles cases where the sequence length is not a multiple of three
    - Appends "**" if one base remains
    - Appends "*" if two bases remain
  - Displays the results in an informational dialog

**Example Output for Input "ACGTAGCA":**
```
DNA length: 8

Codons:
ACG
TAG
CA*
```

---

### **JFileChooser**
**Purpose:**
- Provides a GUI component for users to select files or directories

**Usage Steps:**
1. **Import Statements**
   ```java
   import java.io.File;
   import javax.swing.JFileChooser;
   ```
2. **Create JFileChooser Object**
   ```java
   JFileChooser fc = new JFileChooser();
   ```
3. **Set Dialog Title**
   ```java
   fc.setDialogTitle("Choose Important File");
   ```
4. **Display Open Dialog**
   ```java
   int val = fc.showOpenDialog(null);
   ```
   - **Return Values:**
     - `0`: Open selected
     - `1`: Cancel selected
5. **Retrieve Selected File**
   ```java
   File f = fc.getSelectedFile();
   ```
   - The `File` object contains the name and path of the selected file

**Example Code:**
```java
import java.io.File;
import javax.swing.JFileChooser;

public class FileChooser {
    public static void main(String[] args) {
        JFileChooser fc = new JFileChooser();

        fc.setDialogTitle("Choose Important File");
        int val = fc.showOpenDialog(null);
        System.out.println(val);

        File f = fc.getSelectedFile();
        System.out.println(f);
    }
}
```
- **Explanation:**
  - Initializes a `JFileChooser` instance
  - Sets the dialog title to guide the user
  - Opens the dialog and captures the user's action
  - Prints the action result (`0` for open, `1` for cancel)
  - Retrieves and prints the selected file's details

---

### **Key Java Swing Components and Methods**
- **JOptionPane**
  - Facilitates creation of standard dialog boxes
  - Static methods simplify common dialog types (message, input, confirm, option)
- **JFileChooser**
  - Empowers users to navigate the file system graphically
  - Handles file selection and provides metadata about the chosen file
- **Modal Dialogs**
  - Block interaction with other application windows until dismissed
  - Ensure user input before proceeding

---

### **Best Practices for Using JOptionPane**
- **Dialog Placement**
  - Use `null` for centering dialogs; alternatively, specify a parent component for relative positioning
- **Message Content**
  - Utilize Strings, Icons, or HTML for rich content
- **Consistent Look and Feel**
  - Respect the system's Look and Feel for native appearance
- **Error Handling**
  - Anticipate and manage exceptions like `HeadlessException` when using dialogs
- **User Experience**
  - Provide clear and concise messages
  - Use appropriate message types to convey the correct context (information, warning, error)

---

### **Study Tips**
- **Understand Method Overloads**
  - Familiarize with different signatures of `JOptionPane` methods and their parameters
- **Practice Dialog Configurations**
  - Create various dialogs (message, confirm, input, option) with different configurations
- **Analyze Example Programs**
  - Study and modify example code like the CodonExtractor to grasp dialog interactions
- **Explore JFileChooser Functionalities**
  - Implement file selection dialogs and handle file objects effectively

---
### Polymorphism

- **Definition:**
  - Polymorphism means "many forms."
  - Allows objects of different classes to be treated as objects of a common superclass.

- **Key Concepts:**
  - **Superclass Variable Referencing Subclass Object:**
    - Example: `Account account = new StudentAcct(...);`
    - `account` can reference objects like `SavingsAcct`, `CheckingAcct`, `MoneyMarketAcct`, etc.

  - **Method Overriding:**
    - The compiler determines which overridden method to execute based on the actual object type at runtime.
    - Example: `account.withdraw(amount);` executes the `withdraw` method of the actual subclass.

- **Dynamic Binding:**
  - Methods are selected at runtime based on the object's actual class, not the variable’s declared type.
  - Example:
    ```java
    Animal[] animals = new Animal[100];
    animals[i].speak();
    ```
    - If `animals[i]` is a `Dog`, `Dog`'s `speak()` method is called, despite `animals[i]` being of type `Animal`.

- **Benefits:**
  - **Code Reuse:**
    - Reduces redundancy by allowing multiple subclasses to inherit and override methods from a common superclass.
    - Example: Creating a superclass `Account` to handle different types of accounts, each with specific behaviors.

  - **Generic Treatment of Objects:**
    - Enables handling a collection of diverse objects uniformly.
    - Example: An array of `Animal` objects can include `Dog`, `Cat`, or any new subclasses without modifying existing code.

- **Discipline Required:**
  - Overridden methods should implement consistent and expected behaviors to ensure reliability across different subclasses.

- **Practical Example:**
  - In Java GUI frameworks, all widgets are subclasses of `Component`, allowing GUI code to handle them uniformly regardless of their specific types.

### Abstract Classes

- **Definition:**
  - An abstract class cannot be instantiated.
  - Can contain both abstract methods (without implementation) and concrete methods (with implementation).
  - Can include fields.

- **Usage:**
  - Serves as a superclass for related classes to share common code and enforce a contract for subclasses.
  - Example:
    ```java
    public abstract class Animal {
        private String name;

        public Animal(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }

        abstract void speak();

        public static void main(String[] args) {
            Animal[] animals = new Animal[2];
            animals[0] = new Cat("Garfield");
            animals[1] = new Dog("Snoopy");
            for (int i = 0; i < animals.length; i++)
                animals[i].speak();

            Dog d = new Dog("Marmaduke");
            System.out.println(d.getName());
            Animal a = d;
            System.out.println(a.getName());
        }
    }
    ```

- **Subclass Implementation:**
  - Subclasses must provide implementations for all abstract methods unless the subclass is also abstract.

- **Example Subclasses:**
  ```java
  public class Cat extends Animal {
      public Cat(String name) {
          super(name);
      }

      void speak() {
          System.out.printf("Meow\n");
      }
  }

  public class Dog extends Animal {
      private String name;

      public Dog(String name) {
          super(name);
          this.name = super.getName() + " Barker";
      }

      public String getName() {
          return name;
      }

      void speak() {
          System.out.printf("Bark\n");
      }
  }
  ```

### Abstract Methods

- **Characteristics:**
  - Declared with the `abstract` keyword.
  - Provide only the method signature without a body.
  - Classes containing abstract methods must be declared as abstract.

- **In Interfaces:**
  - All methods are implicitly abstract.

- **Subclassing Abstract Classes:**
  - Subclasses must implement all abstract methods unless they remain abstract.
  - If any abstract methods are not implemented, the subclass must also be declared abstract.

- **Example:**
  ```java
  abstract public class AbstractParent {
      abstract void doOne();
      abstract void doTwo();
  }

  abstract class AbstractChild extends AbstractParent {
      void doOne() {
          System.out.println("in AbstractChild");
      }
  }

  class ConcreteGrandChild extends AbstractChild {
      void doTwo() {
          System.out.println("in ConcreteGrandChild");
      }

      public static void main(String[] args) {
          ConcreteGrandChild cc = new ConcreteGrandChild();
          cc.doOne();
          cc.doTwo();
      }
  }
  ```

### Abstract Classes vs Interfaces

- **Similarities:**
  - Cannot be instantiated.
  - Can contain a mix of methods with and without implementations.

- **Differences:**
  - **Fields:**
    - Abstract classes can declare fields that are not static and final.
    - Interfaces cannot declare instance fields.

  - **Access Modifiers:**
    - Abstract classes can define public, protected, and private methods.
    - Interface methods are implicitly public and abstract.

  - **Inheritance:**
    - Abstract classes can only extend one class.
    - Interfaces can extend multiple interfaces and allow for multiple inheritance of type.

### Choosing Between Abstract Classes and Interfaces

- **Choose Abstract Classes When:**
  - Sharing code among several closely related classes.
  - Subclasses share many common methods or fields.
  - Need access modifiers other than public (e.g., protected, private).
  - Require non-static or non-final fields.

- **Choose Interfaces When:**
  - Expecting unrelated classes to implement the interface.
  - Specifying behavior of a particular data type without concern for implementing classes.
  - Wanting to take advantage of multiple inheritance since a class can implement multiple interfaces.

### Final Methods and Classes

- **Final Methods:**
  - Declared with the `final` keyword.
  - Cannot be overridden by subclasses.
  - Opposite of abstract methods which require overriding.

- **Final Classes:**
  - Declared with the `final` keyword.
  - Cannot be extended by any other class.
  - Common example: `String` class in Java.
    - Designed to prevent extension for security and immutability reasons.

- **Usage Example:**
  ```java
  public final class String {
      // Implementation details
  }

  public class MyString extends String { // Compilation error
      // Cannot extend final class
  }
  ```

### Code Reuse Example: Animal Hierarchy

- **Superclass `Animal`:**
  - Abstract class containing common fields and methods.
  - Prevents instantiation of a generic `Animal` object.

- **Subclasses:**
  - `Dog`, `Cat`, etc., extend `Animal` and provide specific implementations of abstract methods.

- **Example Code:**
  ```java
  public abstract class Animal {
      private String name;

      public Animal(String name) {
          this.name = name;
      }

      public String getName() {
          return name;
      }

      abstract void speak();

      public static void main(String[] args) {
          Animal[] animals = new Animal[2];
          animals[0] = new Cat("Garfield");
          animals[1] = new Dog("Snoopy");
          for (int i = 0; i < animals.length; i++)
              animals[i].speak();

          Dog d = new Dog("Marmaduke");
          System.out.println(d.getName());
          Animal a = d;
          System.out.println(a.getName());
      }
  }

  public class Cat extends Animal {
      public Cat(String name) {
          super(name);
      }

      void speak() {
          System.out.printf("Meow\n");
      }
  }

  public class Dog extends Animal {
      private String name;

      public Dog(String name) {
          super(name);
          this.name = super.getName() + " Barker";
      }

      public String getName() {
          return name;
      }

      void speak() {
          System.out.printf("Bark\n");
      }
  }
  ```

- **Explanation:**
  - The `Animal` class maintains a `name` field and provides a `getName()` method.
  - `Cat` and `Dog` subclasses implement the `speak()` method.
  - Demonstrates polymorphism by storing `Cat` and `Dog` objects in an `Animal` array and invoking `speak()`.

### Additional Notes

- **Inheritance Structure:**
  - `Dog` object contains fields from `Object`, `Animal`, and `Dog`.

- **Program Discipline:**
  - Ensuring that overridden methods in subclasses adhere to expected behaviors is crucial for maintaining code robustness and predictability.

- **Practical Applications:**
  - GUI frameworks leverage polymorphism by treating different widgets as instances of a common superclass, simplifying code management and event handling.
### Selection Statements

#### If-Else Statements

- **Syntax:**
  ```java
  if (boolean-expression) {
      // Statements if true
  }

  if (boolean-expression) {
      // Statements if true
  } else {
      // Statements if false
  }
  ```
- **Cascading If-Else-If Example: Median Calculation**
  - **Problem:**
    ```java
    double median(double a, double b, double c)
    ```
    - Write a method to find the median of three numbers using cascading if-else-if statements.
  - **Solution:**
    ```java
    double median(double x, double y, double z) {
        if ((x <= y && y <= z) || (z <= y && y <= x))
            return y;
        else if ((y <= x && x <= z) || (z <= x && x <= y))
            return x;
        else if ((x <= z && z <= y) || (y <= z && z <= x))
            return z;
        else
            return 0;
    }
    ```
  - **Examples:**
    - `x = 12, y = 14, z = 27` → Median is `y` (14)
    - `x = 14, y = 27, z = 12` → Median is `x` (14)
    - `x = 24, y = 15, z = 18` → Median is `z` (18)

#### Switch Statements

- **Basic Syntax:**
  ```java
  switch (expression) {
      case value1:
          // Statements
          break;
      case value2:
          // Statements
          break;
      // ...
      default:
          // Statements
          break;
  }
  ```
  - **Points:**
    - The `expression` is typically a numeric type (Java 7 and above allow `String`).
    - Executes statements corresponding to the first matching `case`.
    - Execution continues ("falls through") to subsequent cases unless interrupted by `break` or `return`.
    - The `default` case executes if no matching case is found.

- **Arrow Case Labels Syntax:**
  ```java
  switch (expression) {
      case value1, value2, value3 -> {
          // Statements
      }
      case value4, value5 -> {
          // Statements
      }
      // ...
      default -> {
          // Statements
      }
  }
  ```
  - **Features:**
    - Introduces `->` to separate case labels from their statements.
    - Can handle multiple case labels separated by commas.
    - Requires statements to be within braces `{}` if multiple statements are needed.

- **Switch Expressions with Yield:**
  ```java
  int daysInMonth(int month, int year) {
      int numberOfDays;
      numberOfDays = switch (month) {
          case 1, 3, 5, 7, 8, 10, 12 -> 31;
          case 4, 6, 9, 11 -> 30;
          case 2 -> {
              LeapYear ly = new LeapYear();
              if (ly.isLeapYear(year))
                  yield 29;
              else
                  yield 28;
          }
          default -> -1;
      };
      return numberOfDays;
  }
  ```
  - **Details:**
    - `switch` is used as an expression that returns a value.
    - `yield` is used within a block to return a value from a case.
    - The switch expression must end with a semicolon.

- **Examples:**
  - **Days in a Month:**
    - **Problem:**
      ```java
      int daysInMonth(int month, int year)
      ```
      - Write a method to return the number of days in a given month and year.
    - **Solution Using If-Else:**
      ```java
      int daysInMonth1(int month, int year) {
          if (month == 1) return 31;
          else if (month == 2) {
              LeapYear ly = new LeapYear();
              return ly.isLeapYear(year) ? 29 : 28;
          }
          // ... (other months)
          return -1;
      }
      ```
    - **Solution Using Switch:**
      ```java
      int daysInMonth2(int month, int year) {
          switch (month) {
              case 1, 3, 5, 7, 8, 10, 12:
                  return 31;
              case 4, 6, 9, 11:
                  return 30;
              case 2:
                  LeapYear ly = new LeapYear();
                  return ly.isLeapYear(year) ? 29 : 28;
          }
          return -1;
      }
      ```
  - **What Stuff Students Receive:**
    - **Problem:**
      ```java
      String whatStuff(int yearInCollege)
      ```
      - Return a string specifying items based on the student's year:
        - Seniors (4) and Juniors (3): New backpack
        - Sophomores (2): New coat
        - Freshmen (1): New gloves and a new coat
    - **Solution:**
      ```java
      String whatStuff(int yearInCollege) {
          String stuff = "You will be given ";
          switch (yearInCollege) {
              case 1:
                  stuff += "new gloves and ";
              case 2:
                  stuff += "a new coat";
                  break;
              case 3:
              case 4:
                  stuff += "a new backpack";
                  break;
              default:
                  stuff += "nothing";
                  break;
          }
          return stuff;
      }
      ```
      - **Note:** Missing `break` after case 1 may cause fall-through, appending both "new gloves and a new coat" for Freshmen.

### Short-Circuit Evaluation

- **Boolean Operators:**
  - `&&` (AND)
  - `||` (OR)
- **Behavior:**
  - **`||` Operator:**
    - `true || (whatever)` → Result is `true`; `(whatever)` is **not evaluated**.
  - **`&&` Operator:**
    - `false && (whatever)` → Result is `false`; `(whatever)` is **not evaluated**.
- **Common Usage:**
  - Prevents errors such as `NullPointerException`:
    ```java
    if (p != null && p.isImportant()) {
        // Safe to use p
    }
    ```
    - Here, `p.isImportant()` is only evaluated if `p != null`.

### Dangling Else Problem

- **Issue:**
  ```java
  if (familyVisiting)
      if (isWarmOut)
          goToPark();
      else
          hangoutWithFriends();
  ```
  - The `else` is associated with the closest `if` (`isWarmOut`), not `familyVisiting`.
- **Solution: Use Braces to Clarify Association:**
  ```java
  if (familyVisiting) {
      if (isWarmOut)
          goToPark();
      else
          hangoutWithFriends();
  }
  ```

### Floating-Point Comparisons

- **Problem:**
  - Floating-point numbers (`double`, `float`) are imprecise.
  - Example:
    ```java
    double paid = 10.00;
    double check = 9.10;
    double change = 0.90;
    boolean isCorrect = (paid - check) == change; // May fail
    ```
- **Solution: Use Epsilon for Comparison:**
  ```java
  double epsilon = 1e-6;
  if (Math.abs((paid - check) - change) < epsilon) {
      // Considered equal
  }
  ```
  - **Reason:**
    - Accounts for minor precision errors in floating-point representations.

### Ternary Assignment Operator

- **Description:**
  - Simplifies conditional assignments by choosing between two values based on a condition.
- **Syntax:**
  ```java
  condition ? valueIfTrue : valueIfFalse
  ```
- **Example:**
  - **If-Else Statement:**
    ```java
    if (a < b)
        minVal = a;
    else
        minVal = b;
    ```
  - **Equivalent Ternary Operator:**
    ```java
    minVal = (a < b) ? a : b;
    ```

### Practical Programming Problems and Solutions

#### Problem: Swapper

- **Task:**
  - Write a program that ensures `y` is not less than `x` by swapping their values if necessary.
- **Solution:**
  ```java
  import java.util.Scanner;

  public class Swapper {
      public static void main(String[] args) {
          Scanner in = new Scanner(System.in);

          int x = in.nextInt();
          int y = in.nextInt();

          System.out.printf("BEFORE: x = %d, y = %d \n", x, y);
          if (x > y) {
              int t = x; // Temporarily save value of x
              x = y;     // Swap, because y was smaller
              y = t;     // y gets saved value of x
          }

          System.out.printf("AFTER: x = %d, y = %d \n", x, y);
      }
  }
  ```
  - **Explanation:**
    - Uses a temporary variable `t` to hold the value of `x` during the swap.
    - Ensures that after execution, `y` is not less than `x`.

#### Problem: FileExtensions

- **Task:**
  - Write a method to extract the file extension from a filename.
  - Example illustrates short-circuit evaluation.

- **Solution Version 1: Using If-Else**
  ```java
  String findExtension(String fname) {
      int dot;
      if (fname == null)
          return "";

      dot = fname.indexOf('.');

      if (dot == -1)
          return "";
      String extension = fname.substring(dot, fname.length());
      return extension;
  }
  ```
- **Solution Version 2: Using Short-Circuit Evaluation**
  ```java
  String findExtension(String fname) {
      int dot;
      if (fname == null || (dot = fname.indexOf('.')) == -1)
          return "";

      String extension = fname.substring(dot, fname.length());
      return extension;
  }
  ```
  - **Explanation:**
    - Checks if `fname` is `null` or lacks a `.` using `||` to short-circuit evaluation.
    - Extracts the substring starting from the dot to get the extension.

#### Problem: What Stuff

- **Task:**
  - Write a method that returns a string indicating what items students receive based on their year in college.
    - Seniors (4) and Juniors (3): New backpack
    - Sophomores (2): New coat
    - Freshmen (1): New gloves and a new coat

- **Solution:**
  ```java
  String whatStuff(int yearInCollege) {
      String stuff = "You will be given ";
      switch (yearInCollege) {
          case 1:
              stuff += "new gloves and ";
          case 2:
              stuff += "a new coat";
              break;
          case 3:
          case 4:
              stuff += "a new backpack";
              break;
          default:
              stuff += "nothing";
              break;
      }
      return stuff;
  }
  ```
  - **Note:**
    - Missing `break` after `case 1` causes "new gloves and a new coat" for Freshmen.
    - Ensures correct items are appended based on the student's year.

### Comparing Real Values

- **Issue with Floating-Point Precision:**
  - Direct comparisons using `==` may fail due to representation errors.
- **Common Solution:**
  - Use an epsilon value to determine if two floating-point numbers are "close enough."
  - **Implementation:**
    ```java
    double epsilon = 1e-6;
    if (Math.abs(x - y) < epsilon) {
        // x and y are considered equal
    }
    ```
  - **Example Usage:**
    ```java
    if (Math.abs(c.computeChange(9.10, 10) - 0.90) < 0.000001) {
        // Change is correctly computed
    }
    ```

### Summary of Switch Statements

- **Basic Syntax:**
  ```java
  switch (expression) {
      case value1:
          // Statements
          break;
      case value2:
          // Statements
          break;
      // ...
      default:
          // Statements
          break;
  }
  ```
- **Key Points:**
  - **Expression:** Typically a numeric type; `String` allowed in Java 7+.
  - **Case Matching:** Switch evaluates the expression and starts execution at the first matching case.
  - **Flow Control:** Execution continues through subsequent cases unless interrupted by `break` or `return`.
  - **Default Case:** Executes if no case matches and a `default:` is provided.

### Best Practices

- **Use Braces `{}`** to clearly define blocks, especially in nested `if-else` statements, to avoid the dangling else problem.
- **Always Include `break` Statements** in switch cases to prevent unintended fall-through.
- **Utilize Short-Circuit Evaluation** to write safer and more efficient conditional statements.
- **Avoid Direct Floating-Point Comparisons**; instead, use a small epsilon value to compare floating-point numbers.
### **Progression through CS180**
- **Core Background**
  1. Basics (Ch. 1,2)
  2. Primitives (Ch. 3)
  3. Selection (Ch. 4)
  4. Repetition (Ch. 5)
  5. Methods/Classes (Ch. 8,9)
  6. Arrays (Ch. 6)

- **Abstraction**
  1. File I/O and Exceptions (Ch. 12,20)
  2. Interfaces and Inheritance (Ch. 10,11)
  3. Polymorphism (Ch. 17)

- **Multi-threading**
  1. Concurrency (Ch. 13,14)
  2. Networking I/O (Ch. 21)

- **Graphical User Interfaces**
  1. Simple GUI (Ch. 7)
  2. Complex GUI (Ch. 15)

- **Data Structures**
  1. Dynamic Data Structures (Ch. 18)
  2. Recursion (Ch. 19)

### **Dynamic Data Structures**
- **Dynamic Arrays**
- **Linked Lists**
- **Quote:** “Algorithms + Data Structures = Programs” — Niklaus Wirth

### **Definitions**
- **Data Structure:** A way to organize, store, and retrieve information in a program.
- **Dynamic Data Structure:** A data structure whose memory use can grow and shrink as necessary to store the information being maintained.

### **ArrayList**
- **Description:**
  - Like an array, but grows dynamically as elements are added.

- **Implementing a Custom ArrayList:**
  - **Components:**
    - Fixed-sized underlying array.
    - Abstraction via class definition.
    - Accessor (`get`) and mutator (`set`) methods.

- **Implementation Details:**
  - **Class Structure:**
    ```java
    public class MyArrayList {
        private String[] strings;
        private int size;

        public MyArrayList() {
            strings = new String[10];
            size = 0;
        }

        public String get(int i) {
            return strings[i];
        }

        public void set(int i, String s) {
            strings[i] = s;
        }

        public void add(String s) {
            if (size >= strings.length)
                reallocate();
            strings[size++] = s;
        }

        private void reallocate() {
            String[] newstrings = new String[strings.length * 2];
            for (int i = 0; i < size; i++)
                newstrings[i] = strings[i];
            strings = newstrings;
        }

        public int getSize() {
            return size;
        }

        public String[] toArray() {
            String[] array = new String[size];
            int i = 0;
            Node node = head;
            while(node != null) {
                array[i++] = node.value;
                node = node.link;
            }
            return array;
        }
    }
    ```

  - **Expanding the Underlying Array:**
    1. Allocate a new array twice the size of the current array.
    2. Copy existing elements to the new array.
    3. Free the old array.
    - **Reason for Doubling Size:**
      - Reduces the frequency of resizing operations.
      - Improves time efficiency by minimizing overhead.

- **Limitations of ArrayList:**
  - **Type Restriction:**
    - Holds only a single type (e.g., Strings).
    - To store different types, use generics or create separate classes.

  - **Space and Time Efficiency:**
    - Doubling array size can lead to wasted memory.
    - Reallocation involves time-consuming copying of elements.

  - **Alternative:** Linked List as a more efficient dynamic data structure for certain operations.

### **Singly-Linked List**
- **Definition:**
  - An ordered sequence of objects called nodes.
  - Each node contains a value and a single link (pointer) to the next node.
  - The location of each node in memory is arbitrary.

- **Structure:**
  - **Head:** Points to the first node.
  - **Nodes:** Contain `value` and `link`.
  - **Tail:** Last node’s `link` is `null`.

- **Operations:**
  - **Insertion:**
    - **At Head:**
      1. Create a new node.
      2. Set new node’s `link` to current `head`.
      3. Update `head` to the new node.
    - **At Tail (Version 2):**
      1. Maintain a `tail` pointer.
      2. Link new node to `tail.link`.
      3. Update `tail` to the new node.

  - **Deletion:**
    1. Search for the node to delete while tracking the previous node.
    2. Update previous node’s `link` to skip the deleted node.
    3. Reclaim memory of the deleted node.

  - **Searching:**
    1. Start at `head`.
    2. Traverse nodes sequentially.
    3. Compare each node’s `value` with the `searchKey`.
    4. Return `TRUE` if found; else `FALSE`.
    - **Note:** Traversal is only possible in one direction (from head).

- **LinkedList Class Structure:**
  ```java
  public class LinkedList {
      private Node head;
      private Node tail; // For Version 2
      private int size;

      private class Node {
          String value;
          Node link;

          Node(String value) {
              this.value = value;
              size++;
          }
      }

      public LinkedList() {
          head = null;
          tail = null; // For Version 2
          size = 0;
      }

      public void add(String s) {
          Node node = new Node(s);
          if (tail != null) {
              tail.link = node;
          } else {
              head = node;
          }
          tail = node;
      }

      public int getSize() {
          return size;
      }

      public String[] toArray() {
          String[] array = new String[size];
          int i = 0;
          Node node = head;
          while(node != null) {
              array[i++] = node.value;
              node = node.link;
          }
          return array;
      }
  }
  ```

- **Example: ProcessFile**
  ```java
  import java.io.File;
  import java.io.FileNotFoundException;
  import java.util.Scanner;

  public class ProcessFile {
      public static void main(String[] args) throws FileNotFoundException {
          LinkedList list = new LinkedList();
          Scanner in = new Scanner(new File("dickens-tale-of-two-cities.txt"));
          while (in.hasNextLine()) {
              list.add(in.nextLine());
          }

          String[] array = list.toArray();
          System.out.printf("read %d lines\n", list.getSize());
          for (int i = 0; i < array.length; i++)
              System.out.println(array[i]);
      }
  }
  ```

- **Issues in Version 1:**
  - **Reverse Order:**
    - Nodes added at `head` result in reversed order in `toArray()`.

  - **Solution:**
    - Use a `tail` pointer.
    - Insert nodes at `tail` to maintain order.

### **Stacks**
- **Abstract Data Type (ADT):** Last In, First Out (LIFO)
- **Operations:**
  - `push(element)`: Add an element to the top.
  - `pop()`: Remove the top element.
  - `isEmpty()`: Check if the stack is empty.

- **Uses:**
  - RPN expression evaluation.
  - Java Virtual Machine (JVM) stack frames.
  - Managing local variables in method execution.
  - Undo operations.

- **Implementation:**
  - **LinkedListStack:**
    ```java
    public class LinkedListStack implements Stack {
        private class Node {
            int value;
            Node link;
        }

        private Node head = null;

        public void push(int x) {
            Node n = new Node();
            n.value = x;
            n.link = head;
            head = n;
        }

        public int pop() {
            if (isEmpty())
                throw new RuntimeException("Can't pop empty stack");
            int value = head.value;
            head = head.link;
            return value;
        }

        public boolean isEmpty() {
            return head == null;
        }
    }
    ```

  - **Array-based Stack:**
    ```java
    public class ArrayStack implements Stack {
        private int[] array;
        private int size;
        private static final int CAPACITY = 100;

        public ArrayStack() {
            array = new int[CAPACITY];
            size = 0;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        public void push(int value) {
            if (size == array.length)
                throw new RuntimeException("Stack overflow");
            array[size++] = value;
        }

        public int pop() {
            if (isEmpty())
                throw new RuntimeException("Can't pop empty stack");
            return array[--size];
        }
    }
    ```

- **Java Utilities:**
  - **Basic Stack:** `java.util.Stack`
  - **Generalized Stack:** `java.util.Deque`
    - Supports both stack and queue operations.

### **Queues**
- **Abstract Data Type (ADT):** First In, First Out (FIFO)
- **Operations:**
  - `add(element)`: Add an element to the end.
  - `remove()`: Remove the front element.
  - `peek()`: View the front element without removing.

- **Uses:**
  - Printer job scheduling.
  - CPU task scheduling (threads/processes).
  - Network packet management.
  - Producer/consumer scenarios.

- **Implementation:**
  - **LinkedListQueue:**
    ```java
    public class LinkedListQueue implements Queue {
        private class Node {
            int value;
            Node link;

            Node(int value) {
                this.value = value;
            }
        }

        private Node head = null;
        private Node tail = null;
        private int size = 0;

        public boolean isEmpty() {
            return head == null;
        }

        public void add(int value) {
            Node node = new Node(value);
            if (isEmpty()) {
                head = tail = node;
            } else {
                tail.link = node;
                tail = node;
            }
        }

        public int remove() {
            if (isEmpty())
                throw new RuntimeException("Can't remove from empty queue");
            int value = head.value;
            head = head.link;
            if (head == null)
                tail = null;
            return value;
        }

        public int peek() {
            if (isEmpty())
                throw new RuntimeException("Can't peek empty queue");
            return head.value;
        }
    }
    ```

### **Generic Classes**
- **Purpose:**
  - Enable the creation of classes that can operate with any data type.
  - Avoid code duplication for different types.

- **Syntax:**
  - Use `<T>` to denote a type parameter.
  - Example:
    ```java
    ArrayList<String> list = new ArrayList<String>();
    ArrayList<Integer> intList = new ArrayList<Integer>();
    ```

- **Example Implementation:**
  ```java
  public class GenericArrayList<T> {
      private T[] values;
      private int size;

      public GenericArrayList() {
          values = (T[]) new Object[10];
          size = 0;
      }

      public T get(int i) {
          return values[i];
      }

      public void set(int i, T s) {
          values[i] = s;
      }

      public void add(T item) {
          if (size >= values.length)
              reallocate();
          values[size++] = item;
      }

      private void reallocate() {
          T[] newvalues = (T[]) new Object[values.length * 2];
          for (int i = 0; i < size; i++)
              newvalues[i] = values[i];
          values = newvalues;
      }

      public int getSize() {
          return size;
      }
  }
  ```

### **HashMap**
- **Definition:**
  - Stores values referenced by unique keys.
  - Also known as a "dictionary" or "associative array."

- **Characteristics:**
  - Maps keys to values.
  - Keys and values can be of any specified types.

- **Syntax:**
  ```java
  HashMap<K, V> map = new HashMap<K, V>();
  ```

- **Example Usage:**
  ```java
  HashMap<String, Tree> map = new HashMap<String, Tree>();
  map.put("elm", new Tree("elm", 34.5));
  map.put("maple", new Tree("maple", 14.2));
  Tree t = map.get("elm");
  ```

### **Java Library Examples**
- **ArrayList**
- **Stack** (`java.util.Stack`)
- **Queue** (`java.util.Queue` interface)
- **Deque** (`java.util.Deque` interface)
  - Implements both stack and queue operations.
- **LinkedList**
  - Implements `Stack`, `Queue`, and `Deque`.
- **HashMap**

### **Core Concepts**
- **Abstract Data Type (ADT):**
  - Defines behavior without specifying implementation.
  - Users interact with the data type through its interface without knowing internal workings.
  - Provides flexibility to implementers to optimize or change internals without affecting users.

- **Data Access:**
  - Focus on how data is accessed (e.g., via methods like `add`, `remove`), not on the implementation details.

### **Summary of Operations Across Structures**

| **Data Structure** | **Primary Operations**                     | **Alternative Names**        |
|--------------------|--------------------------------------------|------------------------------|
| **Stack**          | `push`, `pop`, `peek`                      | `push`, `pop`, `top`         |
| **Queue**          | `add`, `remove`, `peek`                    | `enqueue`, `dequeue`, `front`|
| **Deque**          | `addFirst`, `removeFirst`, `peekFirst`; `addLast`, `removeFirst`, `peekFirst` | Double-ended queue |

### **Additional Notes**
- **Reallocation in ArrayList:**
  - Essential for dynamic resizing.
  - Doubling the array size ensures amortized constant time for `add` operations.

- **Linked List Advantages:**
  - Efficient insertions and deletions (O(1) time) at known positions.
  - Flexible memory usage compared to arrays.

- **HashMap Efficiency:**
  - Provides average O(1) time complexity for insertions, deletions, and lookups.
  - Utilizes hashing to distribute keys uniformly across buckets.

- **Generics in Java:**
  - Enhance type safety by allowing classes and methods to operate on objects of various types while providing compile-time type checking.
  - Prevents runtime `ClassCastException` by ensuring that only the specified type is used.

- **Concurrency Considerations:**
  - While not deeply covered in these notes, ensure understanding of how data structures behave in multi-threaded environments, especially regarding thread safety and synchronization.

### **Study Tips**
- **Understand Core Operations:** Focus on what each data structure is intended for and how their operations (add, remove, get) are implemented and utilized.
- **Compare and Contrast:** Be able to discuss the advantages and disadvantages of using ArrayLists versus LinkedLists in different scenarios.
- **Implement From Scratch:** Practice writing your own implementations of these data structures to solidify understanding.
- **Use Java Libraries:** Familiarize yourself with Java’s built-in implementations and understand when to apply each.
- **Generic Programming:** Ensure clarity on how generics work in Java and their benefits in creating reusable and type-safe code.
- **Application Scenarios:** Relate each data structure to real-world applications or common programming problems to enhance retention and understanding.
### Primitive Types
#### Real Number Types
- **Subsets of Real Numbers in Java**
  - Two primary types based on bit size:
    - `float`: 32 bits (single precision)
    - `double`: 64 bits (double precision)
  - **Popularity**
    - `double` is the most commonly used real number type.

#### Operations on Real Types
- **Basic Mathematical Operations**
  - Addition (`+`), Subtraction (`-`), Multiplication (`*`), Division (`/`)
- **Math Class Functions**
  - `Math.pow(base, exponent)`
  - `Math.log10(number)`
  - Trigonometric functions, logarithms, etc.
  - Comprehensive list available in Java API documentation.

#### Expressions
- **Building Expressions**
  - Combine variables (e.g., `x`, `y`) and literals (e.g., `3`, `27`) using operators (`+`, `-`).
- **Operator Precedence**
  - Multiplication and division are evaluated before addition and subtraction.
  - Example:
    ```java
    x = b + c * d - a / b / d;
    // Equivalent to:
    x = ((b + (c * d)) - ((a / b) / d));
    ```

#### Precedence (Highest to Lowest)
1. **Unary Operators**
   - `+expr`, `-expr`
2. **Multiplicative Operators**
   - `*`, `/`, `%`
3. **Additive Operators**
   - `+`, `-`
4. **Shift Operators**
   - `<<`, `>>`, `>>>`
5. **Bitwise Operators**
   - `&`, `^`, `|`
6. **Logical Operators**
   - `&&`, `||`
7. **Assignment Operator**
   - `=`
- **Reference for Complete List**
  - [Java Operators Tutorial](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html)

#### Type Promotion
- **Mixing Value Types**
  - Allowed in expressions; Java promotes types to prevent data loss.
- **Promotion Rules**
  - `short` → `int`
  - `float` → `double`
  - Integers to reals (e.g., `int` → `double`)
- **Examples**
  - `3 + 5.0` → `3.0 + 5.0` = `8.0`
  - `1 / 2.0` → `1.0 / 2.0` = `0.5`
- **Relation to Casting**
  - Promotion acts as an implicit form of casting.

### Casting
#### Casting Types
- **Upcasting**
  - From narrower to wider types (more bits).
  - Examples:
    - `short` → `int`
    - `float` → `double`
    - `int` → `double`
- **Downcasting**
  - From wider to narrower types (fewer bits).
  - Examples:
    - `int` → `short`
    - `double` → `float`
    - `double` → `int`

#### Casting Rules
- **Upcasting**
  - Safe; no data loss.
  - Handled automatically by Java (implicitly promoted).
  - Example:
    ```java
    double x = 1 / 2.0; // x = 0.5
    ```
- **Downcasting**
  - Risk of precision loss.
  - Not allowed automatically by Java.
  - Requires explicit cast by the programmer.

#### Cast Operator
- **Purpose**
  - Instructs the Java compiler to convert an expression to a specified type.
- **Syntax**
  - Place type name in parentheses before the expression.
  - Example:
    ```java
    int x;
    double y = 12.6487;
    x = y; // Error: loss of precision
    x = (int) y; // Allowed
    x = (int) (y / 3.0); // Also allowed
    ```

### Primitive Type: `char`
#### Overview
- **Definition**
  - Represents individual characters and symbols in a `String`.
- **Encoding**
  - Each `char` is a number corresponding to a character (e.g., `'A'` = 65).
- **Storage**
  - Java uses 16 bits per `char` (range: 0 to 65,535).

#### Historical Growth of `char` Values
- **ASCII Standard**
  - Initially 128 characters (7 bits).
- **Latin-1 Extension (Obsolete)**
  - Expanded to 256 characters (8 bits), including non-English characters.
- **Unicode 1 Extension (Obsolete)**
  - Increased to 65,535 characters (16 bits), encompassing various global scripts.
- **Current and Future Unicode**
  - **Unicode 15.1 (Sep 2022)**
    - 161 scripts, 149,813 characters.
  - **Unicode 16.0 (Expected Sep 2024)**
    - 154,998 characters, including new emojis.
  - **Encoding Beyond 65,535**
    - Requires using a `String` with two `char` values to represent characters beyond the basic multilingual plane.

#### `char` Literals
- **Single Characters**
  - Enclosed in single quotes.
  - Examples: `'A'`, `'a'`, `'x'`, `'0'`, `'3'`, `'!'`, `'&'`
- **Escape Sequences**
  - Also enclosed in single quotes.
  - Examples:
    - `'\t'` (tab)
    - `'\n'` (newline)
    - `'\''` (single quote)
    - `'\\'` (backslash)
    - `'\uXXXX'` (Unicode hexadecimal value)

#### Operations on `char`
- **String Operations**
  - Upcast to `String` for printing and concatenation.
  - Examples:
    - `System.out.println('A');` → prints `A`
    - `"Hello" + '!'` → `"Hello!"`
- **Arithmetic Operations**
  - Treated as integers.
  - Examples:
    - `'a' + 0` → `97`
    - `'z' - 'a'` → `25`
- **Character Class Methods**
  - Additional operations via methods in `Character` class.

#### Useful `Character` Methods
- `Character.isDigit(char value)`
- `Character.isLetter(char value)`
- `Character.isLetterOrDigit(char value)`
- `Character.isLowerCase(char value)`
- `Character.isUpperCase(char value)`
- `Character.isWhiteSpace(char value)`
- `Character.toLowerCase(char value)`
- `Character.toUpperCase(char value)`

### Primitive Type: `boolean`
- **Values**
  - `true`, `false`
- **Operations**
  - **Logical Operators**
    - `&&` (AND)
    - `||` (OR)
    - `^` (XOR)
    - `!` (NOT)
  - **Usage**
    - Common in conditional statements (e.g., `if` statements).
- **Creation**
  - Via comparison operators.
  - Examples:
    - `x < y`, `x <= y`, `x == y`, `x != y`, `x > y`, `x >= y`
    - Results of logical operations.
- **Note on Reference Types**
  - `==` and `!=` can compare references (addresses) for objects, not their internal values.

### Reference Types
#### Overview
- **Extensibility**
  - Can be created by the programmer.
- **Variable Declaration**
  - Allocates space for a reference to an object, not the object itself.
- **Definition**
  - Based on class declarations.
- **Value Creation**
  - Instances created using the `new` operator.
- **Operations**
  - Defined and implemented by class methods.

#### Declarations and Reference Types
- **Variable Allocation**
  - Declaration allocates space for the reference only.
  - Example:
    ```java
    Wheel w; // Allocates space for reference 'w', object not created
    ```
- **Default Value**
  - `null`
- **Null Reference Usage**
  - Using an uninitialized reference leads to a `NullPointerException`.
  - Example:
    ```java
    Wheel w;
    w.getRadius(); // Causes NullPointerException
    ```

#### Constructors and Fields
- **Constructor**
  - Special method to create an object.
  - Invoked by the `new` operator.
  - Example:
    ```java
    new Wheel(15); // Calls Wheel(double radius) constructor
    ```
- **Fields (Instance Variables)**
  - Variables within a class definition.
  - Part of the object’s state.
  - Initialized by constructor using `this`.
    ```java
    this.radius = radius;
    ```

### Important Reference Type: `String`
- **Built-in Class**
  - No import needed.
  - Supports string literals (e.g., `"hello"`).
- **Object Nature**
  - Instances (including literals) are objects.
  - Can be created with or without `new` operator.
  - Examples:
    ```java
    String greeting = "Hello";
    String greeting = new String("Hello");
    ```
- **Variable Handling**
  - `String` variables hold references to `String` objects.

#### Local Variable Type Inference
- **Standard Declaration**
  ```java
  Wheel w = new Wheel(15.75);
  String school = new String("Purdue");
  ```
- **Using `var`**
  ```java
  var w = new Wheel(15.75);
  var school = new String("Purdue");
  ```
- **Equivalence**
  - Both forms are functionally identical; `var` infers the type automatically.

### Operations on Strings
- **Concatenation**
  - Using `+` operator.
- **String Methods**
  - Numerous methods defined in the `String` class for manipulation and querying.
- **Immutability**
  - Strings cannot be altered once created.
  - Operations result in new `String` objects.

### Comparing Strings
- **Using `==`**
  - Compares object references (memory addresses), not content.
  - Two distinct `String` objects with identical characters are `==` false.
- **Using `equals` Method**
  - Compares the actual content of the strings.
  - Example:
    ```java
    s1.equals(s2);
    ```

### Formatting Strings
- **Template Strings**
  - Combine regular characters with format specifiers.
  - Common specifiers:
    - `%s`: String
    - `%d`: Integer (`byte`, `short`, `int`, `long`)
    - `%f`: Float (`float`, `double`)
- **Example**
  ```java
  System.out.printf("%s! %d or %f", "Hi", 42, 3.14159);
  // Output: Hi! 42 or 3.14159
  ```
- **Width Specifications**
  - `%10s`: Pad string on left to total 10 characters.
  - `%-10s`: Pad string on right to total 10 characters.
  - `%12d`: Pad integer on left to total 12 characters.
  - `%10.3f`: Float with 3 decimals, total width 10.
  - `%.2f`: Float with 2 decimals, dynamic width.
- **Reference**
  - Detailed formatting options available in Java `Formatter` documentation.

### The `final` Keyword
- **Purpose**
  - Modifier that prevents variable modification after initialization.
- **Usage**
  - Applied to variable declarations.
- **Examples**
  - **Example 1: Constant Variable**
    ```java
    final int SIZE = 100;
    SIZE = 50; // Error: cannot assign a value to final variable
    ```
  - **Example 2: Immutable Constant**
    ```java
    Math.PI = 3.1; // Error: cannot modify final field PI
    ```

### Wrapper Classes and Useful Methods
- **Wrapper Classes for Primitive Types**
  - `Byte`
  - `Short`
  - `Integer`
  - `Long`
  - `Float`
  - `Double`
  - `Character`
  - `Boolean`
- **Purpose**
  - Provide object representations for primitive types.
  - Enable usage of primitives in contexts requiring objects (e.g., collections).

### String to Numeric Value
- **Parsing Strings to Numbers**
  - Conversion of `String` to numerical data types.
- **Common Methods**
  - `Integer.parseInt("4000")` → `int` value `4000`.
  - `Double.parseDouble("66.23457")` → `double` value `66.23457`.
- **Exception Handling**
  - `NumberFormatException` must be handled to catch invalid formats.

### Minimum and Maximum Values
- **Integer Values**
  - `Integer.MAX_VALUE` → Maximum `int` value.
  - `Integer.MIN_VALUE` → Minimum `int` value.
- **Double Values**
  - `Double.MAX_VALUE` → Maximum `double` value.
  - `Double.MIN_VALUE` → Minimum `double` value.
- **Additional Values**
  - Refer to Java documentation or textbook for other primitive type boundaries (`Byte`, `Short`, `Long`, `Float`, `Character`, `Boolean`).
### Scope of Variables
- **Scope Definition**: Area in the code where a variable is accessible.
- **Basic Rule**: A variable is usable from its declaration point to the end of the enclosing block.
- **Redeclaration Restriction**: Cannot declare a variable again while it is still in scope.
- **Special Case**:
  - Instance and class variables can be hidden by method parameters or local variables.
  - Use `this.field` to access the hidden field.

#### Example: `Scope2` Class
```java
public class Scope2 {
    int x;
    String name;

    Scope2(int x, String aName) {
        this.x = x;   // Initializes instance variable x
        name = aName; // Initializes instance variable name without using 'this'
    }

    void doit() {
        int x = 10;      // Local variable x hides instance variable x
        this.x = x;      // Assigns local x to instance x using 'this'
    }

    public static void main(String[] args) {
        Scope2 sc1 = new Scope2(12, "Fred");
        Scope2 sc2 = new Scope2(25, "Ralph");
    }
}
```

### The `this` Keyword
- **Reserved Word**: Cannot be used as a variable name.
- **Usage Context**: Only within non-static methods or constructors.
- **Reference**: Points to the current object instance.
- **Purpose**:
  - Access fields or methods of the current object.
  - Disambiguate between instance variables and parameters or local variables.

### Designing a Class
1. **Non-Static Fields (Instance Variables)**:
   - Represent attributes specific to each object.
   - Examples: `wheelDiameter`, `treeCircumference`, `puzzleMatrix`.

2. **Static Fields (Class Variables)**:
   - Shared across all instances of the class.
   - Examples: Constants, total counts, accumulative variables.

3. **Non-Static Methods**:
   - Operate on instance variables.
   - Perform actions specific to an object.
   - Examples: `computeDiameter()`, `computeSolution()`.

4. **Static Methods**:
   - Operate on static variables or do not depend on instance variables.
   - Utility functions or entry points.
   - Examples: `readPuzzle()`, `readWords()`, `computeSqrt()`, `main()` method.

### Modeling Trees with Static Variables
- **Objective**: Track the total number of `Tree` objects created.

#### `Tree` Class
```java
public class Tree {
    double circumference;
    static int numberOfTrees = 0;

    Tree(double circumference) {
        this.circumference = circumference;
        numberOfTrees += 1; // Increment total trees count
    }

    double getRadius() {
        return circumference / (2 * Math.PI);
    }

    static int getNumberOfTrees() {
        return numberOfTrees;
    }
}
```

#### `TreeMaker` Class
```java
public class TreeMaker {
    public static void main(String[] args) {
        while (Math.random() < 0.9) { // Loop until random number >= 0.9
            Tree t = new Tree(Math.random() * 100); // Create Tree with random circumference
            System.out.printf("tree has radius %.3f\n", t.getRadius());
        }
        System.out.printf("created %d trees\n", Tree.getNumberOfTrees()); // Print total trees
    }
}
```

### Extent vs. Scope
- **Scope**:
  - Where a variable is visible.
  - Example:
    ```java
    while (...) {
        int i = 0;
        i++;
        System.out.println(i);
    }
    ```
  - Variable's lifetime matches its scope; value lost when block exits.

- **Extent**:
  - Duration a value is kept.
  - **Variable**: Extent equals scope.
  - **Object**: Exists until no references point to it.

#### Example:
```java
String s = new String("Purdue");
String t = s;
s = new String("Indiana State");
t = new String("Ball State");
```
- `s` initially references "Purdue", then "Indiana State".
- `t` initially references "Purdue" via `s`, then "Ball State".

### Passing References by Value
- **Parameter Passing**: Always by value in Java.
- **Object References**:
  - The value passed is the reference (address) to the object.
  - **Cannot** modify the original reference variable.
  - **Can** modify the object's internal state.

#### Example: `Danger` Class
```java
public class Danger {
    static void modify(Wheel wagon) {
        wagon.radius = 22.6; // Modifies the Wheel object's radius
    }

    public static void main(String[] args) {
        Wheel w = new Wheel(17.5);
        System.out.println(w.getRadius()); // Outputs initial radius
        modify(w);
        System.out.println(w.getRadius()); // Outputs modified radius
    }
}
```

### Overloading Constructors and Methods
- **Signature**: Combination of method name and parameter types.
- **Rules**:
  - Each method/constructor must have a unique signature within the class.
  - Same method names allowed if parameter lists differ.
  - Return type is **not** part of the signature.

#### Valid Overloads:
```java
double getPayment(int months, double interestRate)
double getPayment(int years)
double getPayment()
double getPayment(int owner, String address)
```

#### Invalid Overload:
```java
double calc(double a, int b) // Same as another method but different return type
```

- **Overloading Purpose**: Provide different ways to perform similar operations based on input parameters.

#### Example: `Palindrome` Class
```java
public class Palindrome {
    static boolean isPalindrome(String s) {
        if (s == null || s.length() <= 1)
            return true;

        while (s.length() > 1) {
            char first = s.charAt(0);
            char last = s.charAt(s.length() - 1);
            if (first != last)
                return false;
            s = s.substring(1, s.length() - 1);
        }
        return true;
    }

    static boolean isPalindrome(int x) {
        return isPalindrome(Integer.toString(x));
    }
}
```

### `this()` in Constructors
- **Usage**: Invoke one constructor from another within the same class.
- **Placement**: Must be the first statement in the constructor.
- **Mechanism**: Java matches argument types to select the appropriate constructor.

#### Example: `PurdueStudent` Class
```java
public class PurdueStudent {
    boolean hasName;
    String name;
    int puid;

    // Constructor with int
    PurdueStudent(int puid) {
        this.puid = puid;
        hasName = false;
    }

    // Constructor with String and int
    PurdueStudent(String name, int puid) {
        this(puid); // Calls the int constructor
        this.name = name;
        hasName = true;
    }

    void printStudent() {
        if (hasName)
            System.out.println(name + ": " + puid);
        else
            System.out.println("(no name): " + puid);
    }

    public static void main(String[] args) {
        PurdueStudent p1 = new PurdueStudent(1010337138);
        PurdueStudent p2 = new PurdueStudent("Drake", 1123441245);

        p1.printStudent(); // Outputs: (no name): 1010337138
        p2.printStudent(); // Outputs: Drake: 1123441245
    }
}
```

### Encapsulation
- **Definition**: Bundling data (fields) and methods that operate on the data within one unit (class).
- **Purpose**:
  1. **Information Hiding**: Prevents external entities from accessing internal implementation details.
  2. **Controlled Access**: Restricts modification of fields to maintain object integrity.

#### Java Access Modifiers
- **Modifiers (Least to Most Restrictive)**:
  1. `public`: Accessible from any other class.
  2. `protected`: Accessible within the same package and subclasses.
  3. [default] (Package-private): Accessible only within the same package.
  4. `private`: Accessible only within the defining class.

- **Best Practices**:
  - **Public Methods**:
    - Accessible to all.
    - Should protect internal state through defensive programming.
  - **Private Fields**:
    - Prevent unexpected changes.
    - Only accessible via methods within the class.
  - **Public Constants**:
    - Can be public if declared as `final` to ensure immutability.

#### Accessor and Mutator Methods
- **Accessor (Getter)**:
  - Naming Convention: `getFieldName()`
  - Purpose: Provide read-only access to private fields.
  - Example:
    ```java
    public double getRadius() {
        return radius;
    }
    ```

- **Mutator (Setter)**:
  - Naming Convention: `setFieldName(Type value)`
  - Purpose: Allow controlled modification of private fields.
  - Example:
    ```java
    public void setRadius(double r) {
        if (r > 0 && r <= 1000)
            radius = r;
    }
    ```

#### Example: Improved `Wheel` Class
```java
public class Wheel {
    private double radius;

    public Wheel(double radius) {
        this.radius = radius;
    }

    public double getCircumference() {
        return 2 * Math.PI * radius;
    }

    public double getArea() {
        return Math.PI * radius * radius;
    }

    public double getRadius() {
        return radius;
    }

    public void setRadius(double r) {
        if (r > 0 && r <= 1000)
            radius = r;
    }
}
```

#### Example Usage: `Transportation` Class
```java
public class Transportation {
    public static void main(String[] args) {
        Wheel w = new Wheel(17.5);
        double circ = w.getCircumference();

        // double rad = w.radius; // Not allowed: radius is private
        double rad = w.getRadius(); // Allowed via accessor

        // w.radius = 15.4; // Not allowed: radius is private
        w.setRadius(15.4); // Allowed via mutator
    }
}
```

### Summary of Key Concepts
- **Variable Scope and Extent**: Understanding where variables are accessible and how long their values persist.
- **`this` Keyword**: Essential for distinguishing between instance variables and parameters or local variables.
- **Class Design**: Differentiating between static and non-static fields/methods based on shared or instance-specific data.
- **Encapsulation and Access Modifiers**: Protecting object integrity by controlling access to class members.
- **Method and Constructor Overloading**: Enhancing flexibility and reusability by allowing multiple methods/constructors with the same name but different parameters.
- **Passing References**: Grasping how objects are manipulated through references passed by value in method calls.

These notes encapsulate the foundational principles of object-oriented programming in Java, focusing on class design, encapsulation, and method overloading — essential for effective problem-solving and application development.
**CS18000: Problem Solving and Object-Oriented Programming**

**Arrays**

### **Methods and Classes**

#### **Encapsulation** _(Included on Midterm 1)_
- **Definition:** Information hiding or "need to know" principle
- **Purpose:**
  - **Implementation Hiding:** Allows changes without affecting other programmers
  - **State Protection:** Prevents modification of certain fields or methods that could lead to inconsistent states

**Example: Calendar Appointment**
```java
public class PurdueStudent {
    // Other fields omitted
    private int birthMonth;
    private int birthDay;
    private int birthYear;

    public void setBirthdate(int mo, int day, int yr) {
        // Validate all three components together
        // Example: setBirthdate(2, 31, 2005) shouldn’t succeed
    }
}
```

---

### **Java Access Modifiers**
- **Applicable To:** Members (fields and methods)
- **Controls:** Access from methods in other classes
- **Hierarchy (Least to Most Restrictive):**
  1. **public:** No restrictions; accessible by any other method
  2. **protected**
  3. **[default]** (no modifier)
  4. **private:** Accessible only within the class

**Conventional Wisdom:**
- **Methods:**
  - Make `public` to allow universal access
  - Write defensively to protect internal state
- **Fields:**
  - Make `private` to prevent unexpected changes
  - Ensure only class methods can modify fields
- **Constants:**
  - Use `public final` as they cannot be changed

---

### **Accessor and Mutator Methods**
- **Purpose:** Provide access to `private` fields
- **Naming Convention:**
  - **Accessor:** `get...` (e.g., `getRadius()`)
  - **Mutator:** `set...` (e.g., `setRadius(double r)`)
- **Functionality:**
  - **Accessor Methods:** Allow read-only access
  - **Mutator Methods:** Allow controlled modification

**Example: Wheel Class**
```java
public class Wheel {
    private double radius;

    public Wheel(double radius) {
        this.radius = radius;
    }

    public double getCircumference() {
        return 2 * Math.PI * radius;
    }

    public double getArea() {
        return Math.PI * radius * radius;
    }

    public double getRadius() {
        return radius;
    }

    public void setRadius(double r) {
        if (r > 0 && r <= 1000)
            radius = r;
    }
}
```

**Using Accessor and Mutator Methods**
```java
public class Transportation {
    public static void main(String[] args) {
        Wheel w = new Wheel(17.5);
        double circ = w.getCircumference();
        // double rad = w.radius; // Not allowed
        double rad = w.getRadius();
        // w.radius = 15.4; // Not allowed
        w.setRadius(15.4);
    }
}
```

---

### **Arrays**

#### **Concepts**
- **Problem with Multiple Variables:**
  - Inefficient for handling large datasets (e.g., multiple temperature readings)
- **Solution:** Use data structures to handle collections of data as single units
  - **Data Structures:** Arrays, lists, etc.
  - **Aggregate Data Types:** Combined data types that store multiple elements

#### **Characteristics of Data Structures**
- **Contents:**
  - **Homogeneous:** All elements are of the same type
  - **Heterogeneous:** Elements are of different types
- **Size:**
  - **Static:** Fixed size once initialized
  - **Dynamic:** Can grow or shrink during runtime
- **Element Access:**
  - **Sequential Access:** Access elements in a linear order
  - **Random Access:** Access elements at any position directly

#### **Arrays in Java**
- **Definition:** A list of values, all of the same type
- **Properties:**
  - **Homogeneous:** All elements must be of the same type
  - **Static:** Fixed size upon creation
  - **Random Access:** Direct access to any element via index
  - **Reference Types:** Arrays are objects; they store references to their elements
- **Analogy:** A `String` is similar to an array of characters

#### **Array Initialization**
- **Default Values:**
  - **Integer Types:** 0
  - **Real Types:** 0.0
  - **Reference Types:** `null`
- **Compile-time Initialization:** Arrays can be initialized when declared
  - **Example:**
    ```java
    char[] vowels = { 'a', 'e', 'i', 'o', 'u' };
    int[] days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    ```
  - **Note:** Initialization must occur at the time of declaration

#### **Declaring an Array Variable**
- **Syntax:**
  ```java
  type_name[] variable_name;
  ```
  - **Example:** `String[] args;`
- **Components:**
  - **type_name:** Any primitive or reference type
  - **variable_name:** Standard Java identifier

#### **Creating an Array Object**
- **Syntax:**
  ```java
  new type_name[size];
  ```
- **Example:**
  ```java
  String[] students = new String[10];
  // or using var
  var students = new String[10];
  ```
- **Components:**
  - **type_name:** Any primitive or reference type
  - **size:** An integer expression determining the array size

#### **Accessing an Array Element**
- **Syntax:**
  ```java
  array_object_reference[index];
  ```
- **Example:**
  ```java
  args[0];
  args[i];
  ```
- **Components:**
  - **array_object_reference:** Variable or expression referencing the array
  - **index:** Integer expression representing the element's position

#### **Array Picture Examples**
1. **Integer Array:**
   ```java
   int[] list = new int[5];
   ```
   - **Indices:** 0 to 4
   - **Default Values:** 0
   - **Reference:** `list[3]` accesses the fourth element

2. **String Array:**
   ```java
   String[] names = new String[5];
   ```
   - **Indices:** 0 to 4
   - **Default Values:** `null`
   - **Reference:** `names[3]` accesses the fourth element

---

### **A Familiar Example**

#### **Main Method Parameter as Array**
- **Declaration:**
  ```java
  public static void main(String[] args) { }
  ```
- **Initialization:** `args` is populated with space-separated command-line arguments
  - **Example Command:**
    ```
    > java Calculate add 5 17.25
    ```
  - **Equivalent Initialization:**
    ```java
    String[] args = new String[3];
    args[0] = "add";
    args[1] = "5";
    args[2] = "17.25";
    ```
- **Properties:**
  - **args.length:** Number of arguments passed

#### **Code Example: Calculate Class**
```java
public class Calculate {
    public static void main(String[] args) {
        for (int i = 0; i < args.length; i++)
            System.out.printf("args[%d] = %s\n", i, args[i]);
    }
}
```
- **Functionality:** Iterates through `args` array and prints each argument with its index

---

### **Problem: WordList**

#### **Objective:**
- **Create `WordList` Class:**
  - Reads words from a file into an array
- **Method `computeHistogram`:**
  - Computes the number of words of each length in the `WordList`

#### **Requirements:**
- **Array Variables:**
  - Main word list
  - Histogram counts
- **Allocation:**
  - Choose suitable maximum lengths
  - Allocate arrays accordingly

---

### **Solution: WordList Class**

#### **Step 1: WordList Structure**
```java
import java.util.Scanner;

public class WordList {
    final static int MAXWORDS = 600000; // Maximum number of words
    final static int MAXHIST = 50;      // Maximum word length for histogram

    private String[] words;
    private int size;

    public WordList(Scanner in) {
        words = new String[MAXWORDS];
        size = 0;
        while (in.hasNext()) {
            words[size++] = in.next();
        }
    }
}
```
- **Fields:**
  - `words`: Array to store words
  - `size`: Current number of words
- **Constructor:**
  - Takes `Scanner` object as input
  - Initializes `words` array with `MAXWORDS` size
  - Reads words from `Scanner` and populates `words` array

#### **Step 2: Testing in Main Method**
```java
public static void main(String[] args) {
    Scanner scan = new Scanner(System.in);
    WordList w = new WordList(scan);
    System.out.printf("read %d words\n", w.getSize());
}
```
- **Actions:**
  - Create `Scanner` object
  - Instantiate `WordList` with `Scanner`
  - Print number of words read using `getSize()`

#### **Step 3: Creating Histogram**
```java
public int[] computeHistogram() {
    int[] histogram = new int[MAXHIST];
    for (int i = 0; i < size; i++)
        histogram[words[i].length()]++;
    return histogram;
}

public static void main(String[] args) {
    // Previous code
    int[] wordLengths = w.computeHistogram();
    for (int i = 1; i < MAXHIST; i++)
        if (wordLengths[i] > 0)
            System.out.printf("%2d: %5d\n", i, wordLengths[i]);
}
```
- **Method `computeHistogram`:**
  - Initializes `histogram` array with `MAXHIST` size
  - Iterates through `words` array
  - Increments histogram count based on word length
  - Returns `histogram` array
- **Main Method:**
  - Calls `computeHistogram`
  - Prints histogram results where count > 0

---

### **Final WordList Structure**
```java
import java.util.Scanner;

public class WordList {
    final static int MAXWORDS = 600000;
    final static int MAXHIST = 50;

    private String[] words;
    private int size;

    public WordList(Scanner in) {
        words = new String[MAXWORDS];
        size = 0;
        while (in.hasNext()) {
            words[size++] = in.next();
        }
    }

    public int getSize() {
        return size;
    }

    public int[] computeHistogram() {
        int[] histogram = new int[MAXHIST];
        for (int i = 0; i < size; i++)
            histogram[words[i].length()]++;
        return histogram;
    }

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        WordList w = new WordList(scan);
        System.out.printf("read %d words\n", w.getSize());

        int[] wordLengths = w.computeHistogram();
        for (int i = 1; i < MAXHIST; i++)
            if (wordLengths[i] > 0)
                System.out.printf("%2d: %5d\n", i, wordLengths[i]);
    }
}
```
- **Functionality:**
  - Reads words from input
  - Stores words in `words` array
  - Computes and prints histogram of word lengths

---

### **Array Initialization Details**
- **Default Initialization:**
  - **int[]:** `0`
  - **double[]:** `0.0`
  - **Reference Types (e.g., String[]):** `null`
- **Compile-time Initialization:**
  - Must occur during declaration
  - **Example:**
    ```java
    char[] vowels = { 'a', 'e', 'i', 'o', 'u' };
    int[] days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    ```

---

**End of Notes**
## Dynamic Data Structures

### Definitions
- **Data Structure**: A way to organize, store, and retrieve information in a program.
- **Dynamic Data Structure**: A data structure whose memory use can grow and shrink as necessary to store the information being maintained.

### ArrayList
- **Description**: Similar to an array but can grow as elements are added.
- **Implementation Strategies**:
  - **Fixed-sized Arrays**: Use underlying fixed-size arrays.
  - **Abstraction**: Encapsulate the array within a class.
  - **Accessor and Mutator Methods**: Provide methods to interact with the data.

#### Implementing an ArrayList
- **Encapsulation**: Hide implementation details inside the `ArrayList` class.
- **Underlying Array**: Utilize a fixed-size array to store elements.
- **Tracking Elements**:
  - **Actual Number of Elements (`size`)**: Number of elements currently stored.
  - **Capacity**: Size of the underlying array.
- **Methods**:
  - **Getter**: `get(int index)` to retrieve an element.
  - **Setter**: `set(int index, String value)` to replace an element.
  - **Add**: `add(String element)` to append elements.
  - **Reallocate**: Method to double the array size when capacity is exceeded.

#### Example: ArrayList Implementation
```java
public class ArrayList {
    private String[] strings;
    private int size;

    public ArrayList() {
        strings = new String[10];
        size = 0;
    }

    public String get(int i) {
        return strings[i];
    }

    public void set(int i, String s) {
        strings[i] = s;
    }

    public void add(String string) {
        if (size >= strings.length)
            reallocate();
        strings[size++] = string;
    }

    private void reallocate() {
        String[] newstrings = new String[strings.length * 2];
        for (int i = 0; i < size; i++)
            newstrings[i] = strings[i];
        strings = newstrings;
    }
}
```

#### Limitations of ArrayList
- **Single Type**: Holds only one data type (e.g., Strings). To store multiple types (ints, Trees), separate classes or generics are required.
- **Space and Time Efficiency**:
  - **Memory Wastage**: Doubling the array size can lead to unused space.
  - **Reallocation Overhead**: Copying elements to a new array is time-consuming.
- **Alternative**: Linked List for more efficient insertions and deletions.

### Singly-Linked List
- **Structure**: Ordered sequence of nodes where each node contains a value and a single link (pointer to the next node).
- **Characteristics**:
  - **Head**: Points to the first node.
  - **Tail** (optional): Points to the last node for efficient additions at the end.
  - **Arbitrary Memory Location**: Nodes can be scattered in memory.

#### Linked List Operations
- **Insertion**:
  - **At Head**:
    1. Create a new node.
    2. Set the new node's next to the current head.
    3. Update head to the new node.
  - **At Tail** (with tail pointer):
    1. Create a new node.
    2. Link current tail to the new node.
    3. Update tail to the new node.
- **Deletion**:
  1. Search for the node to delete while keeping track of the previous node.
  2. Update the previous node's next to skip the deleted node.
  3. Reclaim memory used by the deleted node.
- **Searching**:
  - Start at head and traverse node by node.
  - Only possible in one direction due to single link in each node.

#### Example: LinkedList Class Version 1
```java
public class LinkedList {
    private Node head;
    private int size;

    private class Node {
        String value;
        Node link;

        Node(String value) {
            this.value = value;
            size++;
        }
    }

    public LinkedList() {
        head = null;
        size = 0;
    }

    public void add(String s) {
        Node node = new Node(s);
        node.link = head;
        head = node;
    }

    public int getSize() {
        return size;
    }

    public String[] toArray() {
        String[] array = new String[size];
        int i = 0;
        Node node = head;
        while(node != null) {
            array[i++] = node.value;
            node = node.link;
        }
        return array;
    }
}
```

#### Problem with Version 1
- **Reverse Order**: Most recently inserted node is first in the list.
- **Solution**:
  - **Tail Pointer**: Keep track of the end of the list.
  - **Insert at Tail**: Maintain insertion order.

#### Example: LinkedList Class Version 2
```java
public class LinkedList {
    private Node head;
    private Node tail;
    private int size;

    private class Node {
        String value;
        Node link;

        Node(String value) {
            this.value = value;
            size++;
        }
    }

    public LinkedList() {
        head = tail = null;
        size = 0;
    }

    public void add(String s) {
        Node n = new Node(s);
        if (head == null)
            head = n;
        if (tail != null)
            tail.link = n;
        tail = n;
    }

    // getSize and toArray methods remain unchanged
}
```

### Example: ProcessFile Using LinkedList
```java
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class ProcessFile {
    public static void main(String[] args) throws FileNotFoundException {
        LinkedList list = new LinkedList();
        Scanner in = new Scanner(new File("dickens-tale-of-two-cities.txt"));
        while (in.hasNextLine()) {
            list.add(in.nextLine());
        }

        String[] array = list.toArray();
        System.out.printf("read %d lines\n", list.getSize());
        for (int i = 0; i < array.length; i++)
            System.out.println(array[i]);
    }
}
```

### Abstract Data Type (ADT)
- **Description**: Defines behavior without specifying implementation.
- **User Abstraction**: Users interact with methods without knowing internal workings.
- **Flexibility**: Allows implementers to change internal structures without affecting users.

### Common ADTs
#### Stack
- **Type**: Last In, First Out (LIFO)
- **Model**: Stack of plates.
- **Operations**:
  - `push(element)`: Add element to top.
  - `pop()`: Remove element from top.
  - `isEmpty()`: Check if stack is empty.
- **Uses**:
  - RPN expression evaluation.
  - Java Virtual Machine (JVM) for managing local variables and method execution.
  - Undo operations in applications.

#### Queue
- **Type**: First In, First Out (FIFO)
- **Model**: Line of people.
- **Operations**:
  - `enqueue(element)` / `put(element)`: Add element to end.
  - `dequeue()` / `get()`: Remove element from front.
  - `peek()` / `front()`: View front element without removing.
  - `isEmpty()`: Check if queue is empty.
- **Uses**:
  - Print job management.
  - Thread/process scheduling.
  - Network packet transmission.
  - Producer/consumer problem solutions.

### Example: RPN Evaluator
```java
public class Evaluator {
    public static int evaluate(String s) {
        Stack stack = new LinkedListStack();
        String[] tokens = s.split(" ");
        for (String token : tokens) {
            if (token.matches("[0-9]+"))
                stack.push(Integer.parseInt(token));
            else { // operator
                int op2 = stack.pop();
                int op1 = stack.pop();
                switch(token) {
                    case "+": stack.push(op1 + op2); break;
                    case "-": stack.push(op1 - op2); break;
                    case "*": stack.push(op1 * op2); break;
                    case "/": stack.push(op1 / op2); break;
                    default: throw new RuntimeException("unknown operator");
                }
            }
        }
        return stack.pop();
    }

    public static void main(String[] args) {
        String s = "3 5 * 5 - 3 5 + * 2 /";
        System.out.printf("%s = %d\n", s, evaluate(s));
    }
}
```

#### Stack Interface
```java
public interface Stack {
    boolean isEmpty();     // true if there are no elements on the stack
    void push(int value);  // push element on the top of the stack
    int pop();             // remove element from the top of the stack
}
```

#### LinkedListStack Implementation
```java
public class LinkedListStack implements Stack {
    private class Node {
        int value;
        Node link;
    }

    private Node head = null;

    public void push(int x) {
        Node n = new Node();
        n.value = x;
        n.link = head;
        head = n;
    }

    public int pop() {
        if (isEmpty())
            throw new RuntimeException("Can't pop empty stack");
        int value = head.value;
        head = head.link;
        return value;
    }

    public boolean isEmpty() {
        return head == null;
    }
}
```

### Stack Implementation with Array
- **Storage**: Use a static array or dynamic array like `ArrayList`.
- **Tracking**: Maintain a `size` variable to track current stack size.
- **Operations**:
  - `isEmpty()`: Check if `size == 0`.
  - `push(value)`: `array[size++] = value`.
  - `pop()`: `return array[--size]`.
- **Error Handling**:
  - **Empty Stack**: Handle underflow when popping.
  - **Overflow**: Handle when pushing onto a full stack.

### Stacks in Java Utils Package
- **Basic Stack**: `java.util.Stack`
  - [Java Stack Documentation](http://docs.oracle.com/javase/8/docs/api/java/util/Stack.html)
- **Generalized Stack**: `java.util.Deque`
  - [Java Deque Documentation](http://docs.oracle.com/javase/8/docs/api/java/util/Deque.html)
  - **Deque**: Double-ended queue providing methods for both stack and queue operations.

### Queue Interface
```java
public interface Queue {
    boolean isEmpty();    // true if there are no elements in the queue
    void add(int value);  // add element to the end of the queue
    int remove();         // remove element from front of the queue
    int peek();           // “peek” at front element
}
```

### LinkedListQueue Implementation
```java
public class LinkedListQueue implements Queue {
    private class Node {
        int value;
        Node link;

        Node(int value) {
            this.value = value;
        }
    }

    private Node head = null;
    private Node tail = null;

    public boolean isEmpty() {
        return head == null;
    }

    public void add(int value) {
        Node node = new Node(value);
        if (isEmpty()) {
            head = tail = node;
        } else {
            tail.link = node;
            tail = node;
        }
    }

    public int remove() {
        if (isEmpty())
            throw new RuntimeException("Can’t remove from empty queue");
        int value = head.value;
        head = head.link;
        if (head == null)
            tail = null;
        return value;
    }

    public int peek() {
        if (isEmpty())
            throw new RuntimeException("Can’t peek empty queue");
        return head.value;
    }
}
```

### Same Concepts, Many Names
- **Stack**:
  - Operations: `push`, `pop`, `top` or `peek`.
- **Queue**:
  - Operations: `put`, `get`, `peek` or `enqueue`, `dequeue`, `front`.
- **Deque**:
  - Operations for stack-like behavior: `addFirst`, `removeFirst`, `peekFirst`.
  - Operations for queue-like behavior: `addLast`, `removeFirst`, `peekFirst`.

### Generic Classes
- **Purpose**:
  - Implement data structures once and use them with different data types.
- **Syntax**: Use `<T>` notation to indicate a type parameter.
- **Examples**:
  ```java
  Stack<Integer> s = new Stack<Integer>();
  ArrayList<String> list = new ArrayList<String>();
  ```

#### Example: Generic ArrayList
```java
public class ArrayList<Ty> {
    private Ty[] values;
    private int size;

    public ArrayList() {
        values = (Ty[]) new Object[10];
        size = 0;
    }

    public Ty get(int i) {
        return values[i];
    }

    public void set(int i, Ty s) {
        values[i] = s;
    }

    public void add(Ty item) {
        if (size >= values.length)
            reallocate();
        values[size++] = item;
    }

    private void reallocate() {
        Ty[] newvalues = (Ty[]) new Object[values.length * 2];
        for (int i = 0; i < size; i++)
            newvalues[i] = values[i];
        values = newvalues;
    }
}
```
- **Note**: Java does not allow generic arrays. Use an array of `Object` and cast to `Ty` as needed.

### HashMap
- **Description**: Stores "values" referenced by a "key". Known as a "dictionary" or "associative array".
- **Generic Types**: `HashMap<K, V>`
  - **K**: Type of the key.
  - **V**: Type of the value.
- **Example**:
  ```java
  HashMap<String, Tree> map = new HashMap<String, Tree>();
  map.put("elm", new Tree("elm", 34.5));
  map.put("maple", new Tree("maple", 14.2));
  Tree t = map.get("elm");
  ```

### Java Library Examples
- **ArrayList**: Dynamic array implementation.
- **Stack**, **Queue**, **Deque**: Interfaces and classes for stack and queue operations.
- **LinkedList**: Implements `Stack`, `Queue`, `Deque`.
- **HashMap**: Key-value mapping for efficient data retrieval.

---
---

### Interface Examples

#### Building a Game
- **Problem:** Implement a turn-based game where players can pick up valuable objects.
- **Requirements:**
  - Multiple players, each with its own strategy.
  - Rules enforced by a game controller.
- **Use of Java Interfaces:**
  - Each player class implements the `Player` interface.
  - The game controller expects parameters of type `Player`.
- **Main Program Flow:**
  1. Create player objects from classes.
  2. Initialize the game controller with player objects.
  3. Start the game controller.
  4. Print results.

#### Fibonacci Generator
- **Objective:** Write a class to generate the Fibonacci sequence.
- **Sequence Definition:** Each value is the sum of the two previous values (e.g., 1, 1, 2, 3, 5, 8, 13, 21, …).
- **Class Specifications:**
  - **Constructor:** Takes an `int n` specifying the number of values to generate.
  - **Methods:** Provides `hasNext()` and `next()` to generate the `n` values.

---

### Game Program Class Diagram
- **Classes and Interfaces:**
  - `Player` (interface)
    - `Player1` (strategy 1)
    - `Player2` (strategy 2)
  - `Main` (startup)
  - `Game` (rules and logic)
- **Relationships:**
  - `Game` creates instances of `Player`.
  - `Player` implementations are used by `Game`.

---

### Player Interface
```java
interface Player {
    void makeMove();
    void getItems();
}
```

#### Implementing Classes

**Dragon Class**
```java
public class Dragon implements Player {
    public void makeMove() { /* implementation */ }
    public void getItems() { /* implementation */ }
    // Other methods...
}
```

**Butterfly Class**
```java
public class Butterfly implements Player {
    public void makeMove() { /* implementation */ }
    public void getItems() { /* implementation */ }
    // Other methods...
}
```

#### Main Class
```java
public class Main {
    public static void main(String[] args) {
        Dragon bob = new Dragon();
        Butterfly ann = new Butterfly();
        Game game = new Game(bob, ann);
        game.play();
        System.out.println("game over");
    }
}
```

#### Game Class
```java
public class Game {
    private Player p1;
    private Player p2;

    Game(Player p1, Player p2) {
        this.p1 = p1;
        this.p2 = p2;
    }

    void play() {
        p1.makeMove();
        p2.makeMove();
        p1.getItems();
        p2.getItems();
        // Additional game logic...
    }
}
```

---

### Fibonacci Generator Implementation

#### Fibonacci Class
```java
import java.util.Iterator;
import java.lang.Iterable;

public class Fibonacci implements Iterator<Integer>, Iterable<Integer> {
    private int n; // Number of Fibonacci numbers to generate
    private int i; // Count of numbers generated so far
    private int f1, f2; // Last two Fibonacci numbers generated

    public Fibonacci(int n) {
        this.n = n;
        this.i = 0;
        this.f1 = this.f2 = 1;
    }

    // Iterable interface method
    public Iterator<Integer> iterator() {
        return this;
    }

    // Iterator interface methods
    public boolean hasNext() {
        return i < n;
    }

    public Integer next() {
        if (i == 0 || i == 1) {
            i++;
            return 1;
        }
        int t = f1 + f2;
        f1 = f2;
        f2 = t;
        i++;
        return t;
    }

    public static void main(String[] args) {
        Iterator<Integer> i1 = new Fibonacci(25);
        while (i1.hasNext()) {
            System.out.printf("%d ", i1.next());
        }
        System.out.printf("\n");

        Iterable<Integer> i2 = new Fibonacci(30);
        for (Integer num : i2) {
            System.out.printf("%d ", num);
        }
        System.out.printf("\n");
    }
}
```

- **Variables:**
  - `n`: Total Fibonacci numbers to generate.
  - `i`: Counter for numbers generated.
  - `f1`, `f2`: Store the last two Fibonacci numbers.
  - `t`: Temporary variable for calculation.

---

### Two Standard Java Interfaces

#### Iterator (Obsolete – Use Generics)
```java
interface Iterator {
    boolean hasNext();
    Object next();
    default void remove() { /* ... */ }
}

interface Iterable {
    Iterator iterator();
}
```

#### Iterator with Generics (Simplified)
```java
interface Iterator<E> {
    boolean hasNext();
    E next();
    default void remove() { /* ... */ }
}

interface Iterable<E> {
    Iterator<E> iterator();
}
```

---

### Java for-each Loop
```java
for (Tree t : list) {
    // Loop body
}
```
- **Requirements:**
  - The `list` must implement the `Iterable` interface.
  - Must have a method returning an `Iterator` over the collection elements.

---

### Exception Class Hierarchy
- **Top Level:** `Exception`
  - **Subclasses:**
    - `IOException`
      - `FileNotFoundException`
    - `RuntimeException`
      - `ArithmeticException`
      - `NullPointerException`
      - `IndexOutOfBoundsException`
    - `YourException` (Custom Exception)

---

### Problem: Class Relationships
- **Scenario:** Managing personnel at a university.
- **Base Class:** `Person` (stores general information).
- **Derived Classes:**
  - `Student`: Includes grades or classes taken.
  - `Staff`: Includes salary and job title.
  - `Professor`: Includes salary and rank.

---

### Person Class Hierarchy
```
Person
├── Student
└── Employee
    ├── Professor
    ├── Staff
    └── Contractor
```

---

### Person Class
```java
public class Person {
    private String name;
    private String address;

    public Person(String name, String address) {
        this.name = name;
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}
```

---

### Student Class (Initial Approach)
```java
public class Student {
    private String name;
    private String address;
    private String[] classes;
    private String[] grades;

    public Student(String name, String address) {
        this.name = name;
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public String[] getClasses() {
        return classes;
    }

    public void setClasses(String[] classes) {
        this.classes = classes;
    }
    // Additional methods...
}
```
- **Issue:** Redundant with `Person` class.

---

### Inheritance in Java
- **Purpose:** Avoid duplicating members (fields and methods) across classes.
- **Mechanism:** One class can extend another, inheriting fields and methods.
- **Terminology:**
  - **Subclass:** The class that inherits.
  - **Superclass:** The class being inherited from.

---

### Example of Inheritance
- **Class Person:**
  - Fields: `name`, `address`
  - Methods: Accessors and mutators
- **Class Student extends Person:**
  - Inherits all fields and methods from `Person`.
  - Adds: `classes`, `grades`
  - Additional accessors and mutators.
- **Class Professor extends Person:**
  - Inherits all fields and methods from `Person`.
  - Adds: `rank`, `salary`
  - Additional accessors and mutators.
- **Design Principle:**
  - Common fields and methods are placed in `Person`.
  - Specific fields and methods are in respective subclasses.

---

### Student Subclass Implementation
```java
public class Student extends Person {
    private String[] classes;
    private String[] grades;

    public Student(String name, String address, String[] classes, String[] grades) {
        super(name, address);
        this.classes = classes;
        this.grades = grades;
    }

    public String[] getClasses() {
        return classes;
    }

    public void setClasses(String[] classes) {
        this.classes = classes;
    }
}
```
- **Key Points:**
  - **extends Person:** Inherits from `Person`.
  - **super(name, address):** Calls superclass constructor to initialize inherited fields.
  - **Unique Fields:** `classes`, `grades`.

---

### Subclass Only Contains Differences
- **Hierarchy Representation:**
  ```
  Person
  ├── Student
  ├── Employee
  │   ├── Professor
  │   ├── Staff
  │   └── Contractor
  ```

---

### Methods in Classes and Subclasses
```java
Student s = new Student(...);
String[] classes = s.getClasses(); // Found in Student
String name = s.getName();         // Found in Person
double gpa = s.getGPA();          // Assuming defined in Student

Student diya = new Student(...);
String name = diya.getName();      // getName() in Person

Person fred = new Student(...);
String name = fred.getName();      // getName() in Person
```
- **Polymorphism:**
  - A `Student` object can be assigned to variables of type `Student`, `Person`, or `Object`.
  - Methods defined in `Person` can be called on both `Student` and `Person` references.

---

### Object Class in Java
- **Hierarchy Root:** `Object` is the root of all classes.
- **Implicit Extension:** Classes not explicitly extending another class inherit from `Object`.
- **Inheritance Rules:**
  - Single inheritance: A class can extend only one superclass.
  - Multiple interfaces: A class can implement multiple interfaces.
- **Comparison with C++:** C++ supports multiple inheritance; Java does not.

---

### Subclass Object
- **Fields Include:**
  - Fields from `Object` class.
  - Fields from `Person` class.
  - Fields from `Student` class.
- **Example Fields:**
  ```
  // Fields defined in Object
  // Fields defined in Person
  name
  address
  // Fields defined in Student
  classes
  grades
  ```

---

### Object Class Methods

#### clone()
- **Function:** Creates a copy of the object.
- **Usage Requirements:**
  - Class must implement `Cloneable`.
  - Default `clone()` in `Object` performs a shallow copy.
  - Recommended to override and implement a custom `clone()` method.

#### equals(Object e)
- **Function:** Compares the object for equality.
- **Default Behavior:** Checks reference equality (`==`).
- **Customization:**
  - Override to define logical equality.
  - Must preserve the parameter type as `Object`.

#### toString()
- **Function:** Returns a string representation of the object.
- **Usage:** Called by methods like `printf` when a `String` is needed.
- **Customization:** Override to provide a descriptive string representation.

---

### Constructor Chaining
- **Definition:** Ensures all constructors in the inheritance chain initialize the object properly.
- **Enforcement in Java:**
  - Implicit calls to superclass constructors are inserted by Java.
  - Programmers can override this behavior with explicit calls.

#### Constructor Rules
- **Mandatory:** Every class must have at least one constructor.
- **First Statement:** Must call another constructor using `this(...)` or `super(...)`.

#### Default Constructors
- **Behavior:**
  - If no constructors are provided, Java supplies a default constructor.
  - Example:
    ```java
    public ClassName() {
        super();
    }
    ```
  - `super();` invokes the no-argument constructor of the superclass.

#### Default Chaining
- **When a Constructor is Provided:**
  - Java inserts `super();` at the beginning to enforce constructor chaining.

#### Explicit Chaining
- **Custom Calls:**
  - Explicitly call a superclass constructor using `super(arguments)`.
  - Useful for passing arguments to initialize superclass fields.
  - Example in `Student` class:
    ```java
    public Student(String name, String address, String[] classes, String[] grades) {
        super(name, address);
        this.classes = classes;
        this.grades = grades;
    }
    ```

#### Rules for `super()` and `this()`
- **Usage:**
  - `this(...)` calls another constructor within the same class.
  - `super(...)` calls a constructor in the superclass.
- **Restrictions:**
  - Cannot use both `this(...)` and `super(...)` in the same constructor.
  - Must be the first statement in the constructor.
- **Implicit Calls:**
  - If neither is specified, Java automatically calls `super()`.

#### Constructor Complications
- **Base Class Without Parameterless Constructor:**
  - Derived class must explicitly call a superclass constructor with appropriate arguments.
  - Failure to do so results in a syntax error.

---

### Wheel and Tire Class Example

#### Without Explicit `super(...)` Call
```java
public class Wheel {
    private double radius;

    public Wheel(double radius) {
        this.radius = radius;
    }
}

public class Tire extends Wheel {
    private double width;

    public Tire(double radius, double width) {
        // super(radius); // Missing
        this.width = width;
    }
}
```
- **Issue:** Java inserts `super();` implicitly.
- **Result:** Syntax error because `Wheel` lacks a no-argument constructor.

#### With Explicit `super(...)` Call
```java
public class Wheel {
    private double radius;

    public Wheel(double radius) {
        this.radius = radius;
    }
}

public class Tire extends Wheel {
    private double width;

    public Tire(double radius, double width) {
        super(radius); // Explicit call
        this.width = width;
    }
}
```
- **Outcome:** Correct initialization by calling `Wheel`'s constructor with `radius`.

---

### Terminology in Inheritance
- **Relationship Definitions:**
  - `Student` extends `Person`.
  - `Student` is a subclass of `Person`.
  - `Person` is a superclass of `Student`.
  - `Person` is the parent class; `Student` is the child class.
  - `Person` is the base class; `Student` is the derived class.
- **Conceptual Understanding:**
  - Subclass can have more attributes/methods than superclass.
  - Think of it as superset/subset: Objects in `Student` are a subset of `Person` objects.

---

### Classes and Subclasses in Practice

#### Method Location
```java
Student s = new Student(...);
String[] classes = s.getClasses(); // Student
String name = s.getName();         // Person
double gpa = s.getGPA();          // Student

Student t = s;
Student t = s.clone();             // Object (if clone is overridden)
```

#### Object Type Assignments
```java
Student diya = new Student(...);
String name = diya.getName();      // Person's method

Person fred = new Student(...);
String name = fred.getName();      // Person's method
```
- **Polymorphism:** `getName()` from `Person` can be called on both `Student` and `Person` references.

---

### Object Class Essential Points
- **Root of All Classes:** Every class in Java implicitly extends `Object`.
- **Inheritance Limitation:** Java only allows single inheritance (one superclass), unlike C++ which allows multiple inheritance.
- **Methods:**
  - `clone()`: Requires `Cloneable`; performs shallow copy by default.
  - `equals(Object e)`: Default checks `==`; override for logical equality.
  - `toString()`: Returns string representation; override for descriptive output.

---

### Summary of Key Concepts
- **Interfaces:** Define contracts for classes to implement specific methods.
- **Inheritance:** Facilitates code reuse and hierarchical relationships between classes.
- **Polymorphism:** Enables objects to be treated as instances of their superclass.
- **Constructor Chaining:** Ensures proper initialization across class hierarchies.
- **Object Class Methods:** Provide fundamental behaviors like cloning, equality checks, and string representations.

---

### Practical Implications for Exam Preparation
- **Understand Interface Implementation:**
  - How to define and implement interfaces.
  - Usage in enforcing consistent behaviors across different classes.
- **Master Inheritance Hierarchies:**
  - How subclasses extend and inherit from superclasses.
  - Proper use of `super()` and `this()` in constructors.
- **Grasp Object Class Methods:**
  - When and how to override `clone()`, `equals()`, and `toString()`.
- **Constructor Rules and Chaining:**
  - Ensuring all superclass constructors are properly called.
  - Handling cases where superclasses lack parameterless constructors.
- **Polymorphism and Type Assignments:**
  - Assigning subclass objects to superclass references.
  - Understanding method accessibility based on reference type.

Stay focused on how each concept interrelates within object-oriented programming to effectively solve problems and design robust systems.
# CS18000: Problem Solving and Object-Oriented Programming

## Video 1: Algorithms, Abstraction, and Number Systems

### Problem Solving
- **Examples**:
  - **Assemble a bookcase**: Follow step-by-step directions.
  - **Bake a cake**: Use a detailed recipe.
- **Algorithm**:
  - A step-by-step series of instructions to solve a problem.
  - Must be **correct**, **complete**, and **terminate**.
- **Abstraction**:
  - Creating a general concept from specific examples.
  - Simplifies complex systems by focusing on essential details.

### Von Neumann Architecture
- **Overview**:
  - Fundamental structure of most modern computers.
  - Named after computer pioneer John von Neumann.
- **Essential Components**:
  1. **Input/Output Devices (I/O)**:
     - Enable user interaction (e.g., keyboard, mouse, display).
  2. **Memory**:
     - Stores data and programs (instructions).
  3. **Central Processing Unit (CPU)**:
     - Executes instructions and processes data.
- **Data Flow**:
  - CPU fetches data and instructions from memory.
  - Executes computations and stores results back in memory.
  - I/O devices send and receive data to/from the CPU.

## Memory and Storage Sizes
- **Byte**:
  - **Size**: 8 bits
  - **Binary**: \(2^0 = 1\) byte
  - **Practical**: A single character
- **Kilobyte (KB)**:
  - **Size**: 1,024 bytes
  - **Binary**: \(2^{10} \approx 10^3\)
  - **Practical**: A paragraph of text
- **Megabyte (MB)**:
  - **Size**: 1,024 KB
  - **Binary**: \(2^{20} \approx 10^6\)
  - **Practical**: A minute of MP3 music
- **Gigabyte (GB)**:
  - **Size**: 1,024 MB
  - **Binary**: \(2^{30} \approx 10^9\)
  - **Practical**: A half hour of video
- **Terabyte (TB)**:
  - **Size**: 1,024 GB
  - **Binary**: \(2^{40} \approx 10^{12}\)
  - **Practical**: ~80% of a human’s memory capacity

## Number Systems

### Positional Numbering
- **Definition**:
  - Value of a digit depends on its position relative to the decimal point.
- **Base**:
  - Common bases: 2 (binary), 8 (octal), 10 (decimal), 16 (hexadecimal).
- **Position Multiplier**:
  - Each position represents a power of the base.

### Examples
- **Decimal**:
  - \(352 = 3 \times 10^2 + 5 \times 10^1 + 2 \times 10^0 = 300 + 50 + 2\)
- **Binary**:
  - \(1110 = 1 \times 2^3 + 1 \times 2^2 + 1 \times 2^1 + 0 \times 2^0 = 8 + 4 + 2 + 0 = 14\)
- **Hexadecimal**:
  - \(3F = 3 \times 16^1 + F \times 16^0 = 48 + 15 = 63\) (F = 15)

### Conversions
- **Algorithm to Convert Decimal to Any Base**:
  1. Divide the number by the target base.
  2. Prepend the remainder to the result string.
  3. Replace the number with the quotient.
  4. Repeat until the quotient is zero.
- **Example**:
  - Convert 42 to base 2:
    - \(42 \div 2 = 21\), remainder **0**
    - \(21 \div 2 = 10\), remainder **1**
    - \(10 \div 2 = 5\), remainder **0**
    - \(5 \div 2 = 2\), remainder **1**
    - \(2 \div 2 = 1\), remainder **0**
    - \(1 \div 2 = 0\), remainder **1**
    - **Result**: 101010

## Video 2: Storing Integers

### Finite Precision
- **Bit Representation**:
  - Numbers stored using bits (base 2).
- **Organization**:
  - **Bits** → **Bytes** (8 bits) → **Words** (4 bytes = 32 bits or 8 bytes = 64 bits).
- **Integer Representation**:
  - Limited to integers that fit within the allocated bits.
  - Handling negative numbers is essential.

### Interpreting Bits
- **Unsigned vs. Signed Interpretation**:
  - **Unsigned N-bit**:
    - Range: \(0\) to \(2^N - 1\).
  - **Signed N-bit (Two’s Complement)**:
    - Range: \(-2^{N-1}\) to \(2^{N-1} - 1\).
- **Sign Bit**:
  - Leftmost bit indicates sign:
    - **0**: Positive
    - **1**: Negative
- **Two’s Complement Representation**:
  - **Positive Numbers**: Leading 0s up to word size.
  - **Negative Numbers**:
    1. Convert the positive value to binary.
    2. Flip all bits (0 ↔ 1) to get one’s complement.
    3. Add one to obtain two’s complement.
- **Example**:
  - Convert -42 to binary using 8-bit word:
    1. 42 in binary: 00101010
    2. One’s complement: 11010101
    3. Two’s complement: 11010110

### Useful Consequences (Summary)
- **Largest Signed Positive Number in N bits**:
  - \(2^{N-1} - 1\)
  - Example (8 bits): \(01111111 = 127\)
- **Largest Negative Number in N bits**:
  - \(-2^{N-1}\)
  - Example (8 bits): \(10000000 = -128\)

### What Could Go Wrong?
- **Overflow**:
  - Sum of two positive numbers exceeds maximum positive value.
  - Example: \(127 + 1\) in 8 bits.
- **Underflow**:
  - Difference of two numbers exceeds minimum negative value.
  - Example: \(-128 - 1\) in 8 bits.
- **Java Behavior**:
  - Java silently ignores overflow and underflow.

## Video 3: Wheel Class

### Object-Oriented Programming (OOP) Concepts
- **Class**:
  - Template for creating objects (instances).
  - **Examples**: Wheel, Robot, Car, Chair.
  - Contains **variables** (attributes) and **methods** (operations).
- **Variable**:
  - Names and stores a quantity.
  - **Examples**: radius, name, speed, color.
- **Method**:
  - Defines an operation on a class or object.
  - **Examples**: getArea, speak, accelerate, eject.

### Wheel Class Example
```java
public class Wheel {
    // Attributes
    double radius;
    String material;

    // Constructors
    Wheel(double radius, String material) {
        this.radius = radius;
        this.material = material;
    }

    Wheel(double radius) {
        this.radius = radius;
        this.material = "unknown";
    }

    // Accessor Methods
    double getCircumference() {
        return 2 * Math.PI * radius;
    }

    double getArea() {
        return Math.PI * radius * radius;
    }

    double getRadius() {
        return radius;
    }

    String getMaterial() {
        return material;
    }

    // Mutator Methods
    void setRadius(double radius) {
        this.radius = radius;
    }

    void setMaterial(String material) {
        this.material = material;
    }

    void setRadiusAndMaterial(double radius, String material) {
        this.radius = radius;
        this.material = material;
    }

    // Main Method
    public static void main(String[] args) {
        // Local Variables
        double area, circ, rad;
        String mat;

        // Object Creation
        Wheel bicycle = new Wheel(27.5, "rubber");
        Wheel wagon = new Wheel(54.75);

        // Modify Object
        wagon.setMaterial("wood");

        // Access Methods
        circ = bicycle.getCircumference();
        area = bicycle.getArea();
        rad = bicycle.getRadius();
        mat = wagon.getMaterial();

        // Modify Attributes
        bicycle.setRadius(32.0);
        bicycle.setMaterial("polyethylene");
        wagon.setRadiusAndMaterial(88.35, "aluminum");
    }
}
```
- **Attributes**:
  - `double radius`: Stores the radius of the wheel.
  - `String material`: Stores the material of the wheel.
- **Constructors**:
  - `Wheel(double radius, String material)`: Initializes both `radius` and `material`.
  - `Wheel(double radius)`: Initializes `radius` and sets `material` to "unknown".
- **Accessor Methods**:
  - `getCircumference()`: Returns circumference using \(2\pi r\).
  - `getArea()`: Returns area using \(\pi r^2\).
  - `getRadius()`: Returns the radius.
  - `getMaterial()`: Returns the material.
- **Mutator Methods**:
  - `setRadius(double radius)`: Sets a new radius.
  - `setMaterial(String material)`: Sets a new material.
  - `setRadiusAndMaterial(double radius, String material)`: Sets both radius and material.
- **Main Method**:
  - Creates instances `bicycle` and `wagon`.
  - Modifies `wagon`'s material.
  - Retrieves and stores properties of `bicycle` and `wagon`.
  - Updates properties of both objects.

### Methods and Headers
- **Method Definition**:
  - Executed using object name, method name, and arguments.
  - Example: `wagon.setRadiusAndMaterial(88.35, "aluminum");`
- **Method Header Structure**:
  - `return-type name(parameters) { ... }`
- **Return Types**:
  - Methods can return a value (e.g., `double`, `String`) or nothing (`void`).
- **Parameters**:
  - Methods can have zero or multiple parameters.
- **Method Selection**:
  - Java selects the method that matches the argument types provided.
  - Example: `setRadiusAndMaterial(double, String)` is chosen for arguments `88.35` and `"aluminum"`.
- **Constructor Usage**:
  - Example: `Wheel wagon = new Wheel(54.75);` uses constructor with a single `double` argument.

## Software Development

### Software Development Lifecycle
1. **Understand the problem**
2. **Design a solution**
3. **Implement the solution**
4. **Test the solution**
5. **Maintenance**

### How is Software Written?
- **Programming Languages**:
  - **High-Level Language**: Contains complex statements (e.g., Java, Python).
  - **Assembly Language**: Comprises very simple instructions.
  - **Machine Language**: Binary code (1s and 0s).
- **Compilers and Interpreters**:
  - **Compiler**: Translates high-level code to machine language before execution.
  - **Interpreter**: Executes high-level code directly, translating on-the-fly.
- **Integrated Development Environments (IDEs)**:
  - Tools for editing, compiling, executing, and debugging programs.
  - Examples: IntelliJ IDEA, Eclipse.

### Program Translation
- **High-Level Language to Machine Language**:
  - **C Example**:
    - Code:
      ```c
      #include <stdio.h>
      int main() {
          printf("Hello!");
          return 0;
      }
      ```
    - **Compiler**: Translates to machine-specific binary code.
  - **Python Example**:
    - Code:
      ```python
      print("Hello!")
      ```
    - **Interpreter**: Executes directly on CPU.
  - **Java Example**:
    - Code:
      ```java
      public class HelloWorld {
          public static void main(String[] args) {
              System.out.println("Hello!");
          }
      }
      ```
    - **Compiler**: Translates to bytecode.
    - **JIT Compiler**: Converts bytecode to machine language at runtime.

## Tools for Abstraction

### Object-Oriented Programming (OOP)
- **Class**:
  - Template for creating objects.
  - Defines attributes (variables) and behaviors (methods).
  - **Examples**: Wheel, Robot, Car, Chair.
- **Variable**:
  - Stores data within a class.
  - **Examples**: radius, name, speed, color.
- **Method**:
  - Defines operations on objects or classes.
  - **Examples**: getArea(), speak(), accelerate(), eject().

## Class vs. Program

### Class
- Blueprint for objects.
- Contains attributes and methods.
- Example: `Wheel` class.

### Program
- Contains at least one class with a `main` method.
- **Execution**:
  - Begins at the `main` method.
  - Often ends after `main` completes.
- **Command Line Usage**:
  - **Editing**: Using IDEs or text editors.
  - **Compiling**: `javac` command.
  - **Running**: `java` command.
  - **Viewing Bytecode**: `javap -c` command.
- **Examples**:
  - `Robot.java`
  - `Calculator.java`

## Wheel Class (Simplified)
```java
public class Wheel {
    double radius;

    Wheel(double radius) {
        this.radius = radius;
    }

    double getCircumference() {
        return 2 * Math.PI * radius;
    }

    double getArea() {
        return Math.PI * radius * radius;
    }

    double getRadius() {
        return radius;
    }
}
```
- **Components**:
  - **Attribute**: `double radius`.
  - **Constructor**: Initializes `radius`.
  - **Methods**:
    - `getCircumference()`: Calculates circumference.
    - `getArea()`: Calculates area.
    - `getRadius()`: Returns radius.

## Example Java Programs

### Robot.java
```java
public class Robot {
    void speak(String message) {
        System.out.println(message);
    }

    public static void main(String[] args) {
        Robot r = new Robot();
        r.speak("hello world");
    }
}
```
- **Functions**:
  - `speak(String message)`: Prints the message.
  - `main`: Creates a `Robot` instance and calls `speak`.

### Calculator.java
```java
import java.util.Scanner;

public class Calculator {
    int add(int x, int y) {
        return x + y;
    }
    int subtract(int x, int y) {
        return x - y;
    }
    public static void main(String[] args) {
        Calculator c = new Calculator();
        Scanner scanner = new Scanner(System.in);
        int x = scanner.nextInt();
        int y = scanner.nextInt();
        System.out.println(c.add(x, y));
        System.out.println(c.subtract(x, y));
    }
}
```
- **Functions**:
  - `add(int x, int y)`: Returns sum of `x` and `y`.
  - `subtract(int x, int y)`: Returns difference of `x` and `y`.
  - `main`:
    - Creates `Calculator` instance.
    - Reads two integers from input.
    - Prints sum and difference.

## Java Basics

### Program Structure
- **Top-Level Class**:
  - Name matches file name (e.g., `Robot` in `Robot.java`).
- **Methods**:
  - One or more methods per class.
  - **Main Method**: `public static void main(String[] args)` – entry point.
- **Input and Output**:
  - **Input**: `Scanner` class.
  - **Output**: `System.out.println(...)`.

### Syntax Details
- **Comments**:
  - Single-line: `// comment`
  - Multi-line: `/* comment */`
- **Whitespace**:
  - Ignored except to separate tokens.
- **Semicolons (`;`)**:
  - End or separate statements.
- **Curly Braces (`{}`)**:
  - Group statements.
- **Reserved Words**:
  - Cannot be used as identifiers (variables, methods, classes).
- **Import Statements**:
  - Access other classes (e.g., `import java.util.Scanner;`).

### System Class
- **Standard Streams**:
  - `System.in`: Input stream (e.g., keyboard).
  - `System.out`: Output stream (e.g., display).
- **Redirection**:
  - In command-line systems, can redirect `System.in` and `System.out` from/to files or other programs.

### Parsing Input with Scanner
```java
Scanner s = new Scanner(System.in);
String name = s.nextLine();
int i = s.nextInt();
double d = s.nextDouble();
```
- **Usage**:
  - Create `Scanner` object to read from `System.in`.
  - Methods:
    - `nextLine()`: Reads a full line of text.
    - `nextInt()`: Reads an integer.
    - `nextDouble()`: Reads a double.

## Java Formatting Notes
- **Naming Conventions**:
  - **Variables**: `lowerCamelCase` (e.g., `radius`, `materialType`).
  - **Classes**: `UpperCamelCase` (e.g., `Wheel`, `Calculator`).
  - **Symbolic Constants**: `UPPER_CASE` (e.g., `MAX_SIZE`).
- **Brace Placement**:
  - Opening curly brace `{` at the end of the line.
- **Indentation**:
  - Use consistent indentation (e.g., 4 spaces).
- **Documentation**:
  - Complete documentation available on the course website.

## How to Read an Assignment

### Create a Class
- **Directive**: “Create a class Henway …”
- **Steps**:
  1. Create a file named `Henway.java`.
  2. Start with the basic template:
     ```java
     public class Henway {
     }
     ```
  3. **Note**: Capitalization matters (case-sensitive).
  4. **Compile**: Should compile without errors.
  5. **Run**: May produce an error if no `main` method is defined.

### Write a Java Program
- **Directive**: “Write a Java program named Henway …”
- **Steps**:
  1. Create a file named `Henway.java`.
  2. Start with the program template:
     ```java
     public class Henway {
         public static void main(String[] args) {
             // Program execution begins here
         }
     }
     ```
  3. **Note**: Capitalization matters.
  4. **Compile and Run**: Should compile and run without errors, no output if no print statements present.

### Read from Standard Input
- **Directive**: “Read from standard input…”
- **Steps**:
  1. **Import Scanner**:
     - Add at the beginning of the file (before `public class`):
       ```java
       import java.util.Scanner;
       ```
  2. **Initialize Scanner in `main`**:
     ```java
     Scanner scanner = new Scanner(System.in);
     ```
  3. **Read Input**:
     - To read an integer and store in variable `x`:
       ```java
       int x = scanner.nextInt();
       ```


#### **Repetition Constructs in Java**
- **For Loop**
- **Do-While Loop**
- **Nested Loops and Other Examples**

---

### **1. WhileDefinite Loop**

**Problem:**
- Print “hello” 10 times using a `while` loop.
- Demonstrates using a `while` loop for definite iteration.

**Solution:**
```java
public class WhileDefinite {
    public static void main(String[] args) {
        int n = 0;
        while (n < 10) {
            System.out.printf("hello (#%d)\n", n);
            n++;
        }
    }
}
```

**Loop Components:**
- **Initialization (`e1`):** `int n = 0;`
  - Executed once before the loop starts.
- **Test (`e2`):** `n < 10;`
  - Evaluated before each iteration; if `true`, the loop continues.
- **Update (`e3`):** `n++;`
  - Executed after each iteration.

**Equivalent For Loop:**
```java
for (int n = 0; n < 10; n++) {
    System.out.printf("hello (#%d)\n", n);
}
```

---

### **2. Definite Iteration: For Loop**

**General Form:**
```java
for (e1; e2; e3) {
    statements;
}
```
- **Sequence of Actions:**
  1. **Initialize (`e1`):** Executed once at loop start.
  2. **Test (`e2`):** Boolean condition evaluated before each iteration.
  3. **Execute Body:** If `e2` is `true`.
  4. **Update (`e3`):** Executed after the loop body.
  5. **Repeat:** Return to step 2.

**Details:**
- **Initialization (`e1`):**
  - Can be omitted.
  - Typically a variable declaration and initialization, e.g., `int i = 0;`
  - Multiple declarations separated by commas, e.g., `int i = 0, j = 0;`
- **Termination (`e2`):**
  - Boolean expression controlling loop continuation.
  - If `false`, exit loop.
- **Update (`e3`):**
  - Can be omitted.
  - May consist of multiple expressions, e.g., `i++, j--`

**Common Practices:**
- **Looping `n` Times:**
  ```java
  for (int i = 0; i < n; i++) {
      statements;
  }
  ```
  - Counts from `0` to `n-1`.
  - Suitable for 0-based indexing in arrays and strings.

- **Example: Printing Characters in a String**
  ```java
  String s = "hello there world";
  for (int i = 0; i < s.length(); i++) {
      System.out.printf("s.charAt(%d) = '%c'\n", i, s.charAt(i));
  }
  ```

---

### **3. Infinite Loop Example**

**Definition:**
- A loop that runs indefinitely without a terminating condition.

**Example:**
```java
for (;;) {
    // Infinite loop
    System.out.println("XINU is not UNIX is not UNIX is not UNIX");
}
```
- **Characteristics:**
  - No initialization, test, or update expressions.
  - Must include a break condition inside the loop body to exit.

---

### **4. Enhanced For Loop (For-Each Loop)**

**Usage:**
- Iterate through elements of Collections and arrays.

**Declaration:**
```java
int[] numbers = {1,2,3,4,5,6,7,8,9,10};

for (int item : numbers) {
    System.out.println("Count is: " + item);
}
```

**Advantages:**
- Improved readability.
- Eliminates the need for index variables.
- Recommended by Oracle for most use cases.

**Example Class:**
```java
class EnhancedForDemo {
    public static void main(String[] args) {
        int[] numbers = {1,2,3,4,5,6,7,8,9,10};
        for (int item : numbers) {
            System.out.println("Count is: " + item);
        }
    }
}
```

---

### **5. Do-While Loop**

**Syntax:**
```java
do {
    statements;
} while (boolean-expression);
```

**Execution Flow:**
1. Execute statements in the body.
2. Evaluate `boolean-expression`.
3. If `true`, repeat from step 1.

**Use Case:**
- When the loop body must execute at least once regardless of the condition.

---

### **6. Problem: Prompting the User for an Even Number**

**Requirements:**
- Write a program `Prompter` that:
  - Prompts the user for an even number.
  - Continues prompting until an even number is provided.
  - Provide alternate implementations using `do-while` and `while` loops.

**Solution 1: Prompter1 (Using Do-While)**
```java
import java.util.Scanner;

public class Prompter1 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n;
        do {
            System.out.printf("Please enter an even number: ");
            n = in.nextInt();
        } while (n % 2 == 1);
        System.out.printf("Thank you for entering the even number %d\n", n);
    }
}
```
- **Logic:**
  - Prompts user at least once.
  - Continues until `n` is even (`n % 2 == 0`).

**Solution 2: Prompter2 (Using While with Sentinel)**
```java
import java.util.Scanner;

public class Prompter2 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = 0;
        boolean done = false;
        while (!done) {
            System.out.printf("Please enter an even number: ");
            n = in.nextInt();
            if (n % 2 == 0)
                done = true;
            else
                System.out.printf("The number %d is not even.\n", n);
        }
        System.out.printf("Thank you for entering the even number %d\n", n);
    }
}
```
- **Logic:**
  - Uses a sentinel (`done`) to control loop.
  - Provides feedback if input is not even.

---

### **7. Problem: Palindrome Checker**

**Objective:**
- Implement `boolean isPalindrome(String s)` in class `Palindrome`.
- Determine if `s` is a palindrome (reads the same backward as forward).
- Approach 2: Use a `for` loop.

**Strategy:**
- Iterate through the first half of the string.
- Compare each character to its corresponding character from the end.
- Terminate early if a mismatch is found.

**Solution:**
```java
boolean isPalindrome(String s) {
    if (s == null)
        return true;

    for (int i = 0; i < s.length() / 2; i++) {
        if (s.charAt(i) != s.charAt(s.length() - 1 - i))
            return false;
    }
    return true;
}
```
- **Steps:**
  1. **Null Check:**
     - If `s` is `null`, return `true` (assuming `null` as a palindrome).
  2. **Iteration:**
     - Loop from `i = 0` to `i < s.length() / 2`.
  3. **Comparison:**
     - Compare `s.charAt(i)` with `s.charAt(s.length() - 1 - i)`.
     - If not equal, return `false`.
  4. **Completion:**
     - If all corresponding characters match, return `true`.

---

### **8. Common Loop Mistakes**

1. **Infinite Loop**
   - **Cause:** Loop condition never becomes `false`.
   - **Example:**
     ```java
     public class InfiniteLoop {
         public static void main(String[] args) {
             int n = 1;
             while (n < 100) {
                 System.out.printf("n = %d\n", n);
                 // Missing: n++;
             }
         }
     }
     ```
   - **Fix:** Ensure the loop variable is updated appropriately.

2. **Almost Infinite Loop**
   - **Cause:** Loop condition is reached only after many iterations or due to incorrect update.
   - **Example:**
     ```java
     public class AlmostInfiniteLoop {
         public static void main(String[] args) {
             // Countdown to blast off
             for (int i = 10; i > 0; i--)
                 System.out.printf("%d\n", i);
             System.out.printf("BLAST OFF!\n");
         }
     }
     ```
   - **Note:** This example actually correctly counts down; an almost infinite loop would have a condition that takes too long to be met.

3. **Fencepost Errors**
   - **Cause:** Off-by-one errors in loop boundaries.
   - **Example:**
     ```java
     public class FencePostError {
         public static void main(String[] args) {
             for (int i = 0; i <= 5; i++)
                 System.out.printf("print this line 5 times (%d)\n", i);
         }
     }
     ```
   - **Issue:** The loop runs 6 times (`i` from 0 to 5).

4. **Skipped Loops**
   - **Cause:** Incorrect loop condition that prevents the loop from executing.
   - **Example:**
     ```java
     import java.util.Scanner;

     public class SkippedLoop {
         public static void main(String[] args) {
             Scanner in = new Scanner(System.in);
             int number = 0;
             int sum = 0;

             // Read ints from user until zero, then print sum
             while (number > 0) {
                 sum += number;
                 number = in.nextInt();
             }
             System.out.printf("sum = %d\n", sum);
         }
     }
     ```
   - **Issue:** Initial `number` is `0`, so loop condition `number > 0` is `false`. User input is never processed.

5. **Misplaced Semicolons**
   - **Cause:** Accidental semicolon after loop condition creates an empty loop body.
   - **Example:**
     ```java
     public class MisplacedSemicolon {
         public static void main(String[] args) {
             int i = 10;
             while (--i >= 0); {
                 System.out.printf("message #%d\n", i);
             }
         }
     }
     ```
   - **Issue:** The semicolon after `while` creates an empty loop. The print statement executes once after the loop.

---

### **9. Nested Loops**

**Concept:**
- Placing one loop inside another.
- The inner loop runs completely for each iteration of the outer loop.

**Example:**
```java
public class Nested {
    public static void main(String[] args) {
        for (int i = 0; i < 5; i++)
            for (int j = 0; j < 5; j++)
                System.out.printf("i = %d, j = %d\n", i, j);
    }
}
```

**Output:**
```
i = 0, j = 0
i = 0, j = 1
i = 0, j = 2
i = 0, j = 3
i = 0, j = 4
i = 1, j = 0
i = 1, j = 1
...
i = 4, j = 4
```
- **Total Iterations:** 25 (5 outer * 5 inner)

---

### **10. Problem: Draw Divisor Pattern**

**Objective:**
- Print an `N x N` table.
- Entry at row `i` and column `j` has an `*` if:
  - `i` divides `j` **or**
  - `j` divides `i`.
- **Example for N = 5:**
  ```
     1  2  3  4  5
  1  *  *  *  *  *
  2  *  *     *
  3  *         *
  4  *  *     *
  5  *         *
  ```

**Solution:**
```java
public class DivisorPattern {
    public static void main(String[] args) {
        int N = Integer.parseInt(args[0]);

        // Print header
        System.out.printf("   ");
        for (int i = 1; i <= N; i++)
            System.out.printf("%3d", i);
        System.out.printf("\n");

        // Print table rows
        for (int i = 1; i <= N; i++) {
            System.out.printf("%3d", i);
            for (int j = 1; j <= N; j++) {
                if (i % j == 0 || j % i == 0)
                    System.out.printf("  *");
                else
                    System.out.printf("   ");
            }
            System.out.printf("\n");
        }
    }
}
```
- **Steps:**
  1. **Header Row:**
     - Print numbers from `1` to `N`.
  2. **Table Body:**
     - For each row `i` from `1` to `N`:
       - Print row header `i`.
       - For each column `j` from `1` to `N`:
         - If `i` divides `j` or `j` divides `i`, print `*`.
         - Else, print space.

---

### **11. Problem: Convert Integer to Binary**

**Objective:**
- Create a class `Converter` with method `String convertToBinary(int n)`.
- Converts integer `n` to its binary equivalent as a `String` of `0`s and `1`s.
- Use a `while` loop.

**Solution:**
```java
public class Converter {
    String convertToBinary(int n) {
        String result = "";

        // Handle special cases
        if (n < 0)
            return null; // Failure for negative numbers
        if (n == 0)
            return "0";

        // Convert to binary
        while (n > 0) {
            if (n % 2 == 0)
                result = "0" + result;
            else
                result = "1" + result;
            n = n / 2;
        }
        return result;
    }
}
```
- **Logic:**
  1. **Special Cases:**
     - If `n` is negative, return `null`.
     - If `n` is `0`, return `"0"`.
  2. **Conversion Loop:**
     - While `n > 0`:
       - Determine least significant bit using `n % 2`.
       - Prepend `0` or `1` to `result`.
       - Divide `n` by `2` (integer division).
  3. **Return Result:**
     - The binary representation as a `String`.

---

### **Summary of Key Concepts**

- **Loop Constructs:**
  - **For Loop:** Best for definite iterations with known boundaries.
  - **While Loop:** Suitable when the number of iterations is not known beforehand.
  - **Do-While Loop:** Ensures the loop body executes at least once.
  - **Enhanced For Loop:** Simplifies iteration over collections and arrays.

- **Loop Components:**
  - **Initialization (`e1`):** Setup before looping begins.
  - **Test (`e2`):** Condition to continue looping.
  - **Update (`e3`):** Modification after each iteration.

- **Common Loop Errors:**
  - **Infinite Loops:** Conditions never met.
  - **Fencepost Errors:** Off-by-one in loop boundaries.
  - **Skipped Loops:** Conditions prevent any iteration.
  - **Misplaced Semicolons:** Empty loop bodies due to syntax errors.

- **Nested Loops:**
  - Placing one loop inside another to handle multidimensional data or complex iterations.

- **Problem-Solving with Loops:**
  - Utilize loops to handle repetitive tasks like printing patterns, validating user input, or processing strings.

---

### **Study Tips**
- **Understand Loop Mechanics:**
  - Know the flow of each loop type.
  - Be able to translate between `for`, `while`, and `do-while` loops.

- **Practice Common Problems:**
  - Implement solutions like prompting for input, checking palindromes, converting numbers, and drawing patterns.

- **Identify and Avoid Common Mistakes:**
  - Carefully check loop conditions and update statements.
  - Be mindful of loop boundaries to prevent fencepost errors.

- **Utilize Enhanced For Loops Appropriately:**
  - Use when iterating over collections or arrays for cleaner and more readable code.

- **Analyze Sample Code:**
  - Break down example programs to understand how loops control program flow.

---
### CS18000: Problem Solving and Object-Oriented Programming

#### Local Variable Type Inference
- **Standard Declaration:**
  ```java
  Wheel w = new Wheel(15.75);
  String school = new String("Purdue");
  ```
  - Explicitly specifies the type (`Wheel`, `String`) for each variable.
- **Using `var`:**
  ```java
  var w = new Wheel(15.75);
  var school = new String("Purdue");
  ```
  - `var` enables Java to infer the type based on the assigned value.
  - Both declarations are **equivalent** to their explicit counterparts.
  - Enhances code readability and reduces verbosity.

#### Sequential Execution
- **Definition:**
  - Statements are executed **one after another** in the order they appear.
- **Example:**
  ```java
  Statement1;
  Statement2;
  // ...
  StatementN;
  ```
- **Exception Handling:**
  - If a statement causes an **exception**, the program terminates unless handled.
- **Control Flow:**
  - Described as "**Control flows sequentially**."

#### Control Structures
- **Sequential as Default:**
  - Fast and common but **limited** for complex logic.
- **Keywords to Alter Control Flow:**
  - **Conditional:** `if`, `switch`
  - **Looping:** `while`, `for`
  - **Control Transfer:** `break`, `continue`, `return`
- **Method Calls:**
  - Control jumps to the **start of a called method** and **returns** after execution.

#### Decision Making
- **Example Scenarios:**
  1. **Routine Decision:**
     - *If* it is a weekday **and** not on vacation, *then* get up early.
  2. **Nested Decisions:**
     - *If* there's a basketball game **and** Purdue is playing, cheer for Purdue.
     - *Else if* IU is playing, cheer for their opponent.

#### Primitive Type: `boolean` (Review)
- **Values:**
  - `true`, `false`
- **Creation via Comparison Operators:**
  - `<`, `<=`, `==`, `!=`, `>`, `>=`
  - **Note:** For reference types, `==` and `!=` compare **references** (addresses), not **values**.
- **Logical Operations:**
  - **AND:** `&&`
  - **OR:** `||`
  - **XOR:** `^`
  - **NOT:** `!`

#### Reference Type: `String` (Review)
- **Built-In Class:**
  - No need to import; supported natively in Java.
- **String Literals:**
  - Example: `"hello"`
- **Object Nature:**
  - Instances (including literals) are objects.
  - Created using the `new` operator:
    ```java
    String greeting = "Hello"; // Equivalent to:
    String greeting = new String("Hello");
    ```
- **Variables Hold References:**
  - String variables store **references** to `String` objects.

#### Comparing Strings
- **Using `==`:**
  - Compares **object references** (memory addresses).
  - Two different `String` objects with identical content result in `false`.
- **Proper Comparison:**
  - Use the `.equals()` method to compare **string values**:
    ```java
    if (s1.equals(s2)) {
        // Strings have the same content
    }
    ```

#### Abstracting Conditions
- **Example Implementations:**
  1. **Early Wake-Up:**
     ```java
     if (isWeekday && !onVacation)
         getUpEarly();
     ```
  2. **Cheering Logic:**
     ```java
     if (gameOn("basketball") && playing("Purdue"))
         cheerFor("Purdue");
     else if (gameOn("basketball") && playing("IU"))
         cheerFor(opponent("IU"));
     ```

#### Basic Forms of the `if` Statement
- **Single Condition:**
  ```java
  if (booleanExpression)
      statementIfTrue;
  ```
- **With `else`:**
  ```java
  if (booleanExpression)
      statementIfTrue;
  else
      statementIfFalse;
  ```

#### Blocks and Braces
- **Grouping Statements:**
  - Use `{}` to group multiple statements into a single block.
- **Usage Examples:**
  - Method bodies:
    ```java
    public void method() {
        // multiple statements
    }
    ```
  - Control structures:
    ```java
    if (condition) {
        // multiple statements
    } else {
        // multiple statements
    }
    ```

#### Block Forms of the `if` Statement
- **With Braces:**
  ```java
  if (booleanExpression) {
      // statements if true
  }

  if (booleanExpression) {
      // statements if true
  } else {
      // statements if false
  }
  ```

#### The `final` Keyword
- **Purpose:**
  - **Modifier** used in variable declarations to prevent reassignment.
- **Usage:**
  ```java
  final int SIZE = 100;
  SIZE = 50; // Compilation Error: cannot assign a value to a final variable

  final double PI = Math.PI;
  PI = 3.1; // Compilation Error
  ```
- **Constants:**
  - Commonly used for constants to ensure their values remain unchanged.

#### Formatting Strings
- **Format Specifiers:**
  - `%s` : String
  - `%d` : Integer (`byte`, `short`, `int`, `long`)
  - `%f` : Floating-point (`float`, `double`)
- **Example:**
  ```java
  System.out.printf("%s! %d or %f", "Hi", 42, 3.14159);
  // Output: Hi! 42 or 3.141590
  ```
- **Width Specifications:**
  - `%10s` : Pad string on **left** to make it 10 characters.
  - `%-10s` : Pad string on **right** to make it 10 characters.
  - `%12d` : Pad integer on **left** to make it 12 characters.
  - `%10.3f` : Format number with 3 decimals; total width 10.
  - `%.2f` : Format with 2 decimals; width determined by number size.
- **Reference:**
  - Detailed formatting options available in Java's `Formatter` documentation.

---

### Programming Problems and Solutions

#### Problem: SecretWord
- **Objective:**
  - Create a program that reads a user-input word and prints a message if it matches a predefined "secret word."
- **Key Concepts:**
  - User input handling
  - String comparison
  - Conditional statements

#### Solution: SecretWord
- **Code Implementation:**
  ```java
  import java.util.Scanner;

  public class SecretWord {
      final static String SECRET = "awesome";

      public static void main(String[] args) {
          Scanner in = new Scanner(System.in);
          String word = in.next();

          if (word.equals(SECRET))
              System.out.printf("You have said the secret word: '%s'\n", SECRET);

          in.close(); // Good practice to close the scanner
      }
  }
  ```
- **Explanation:**
  - **Scanner:** Utilized to capture user input.
  - **Constant `SECRET`:** Declared as `final static` to prevent modification.
  - **Input Retrieval:** `in.next()` reads the next token from the input.
  - **Comparison:** `.equals()` method ensures value-based comparison.
  - **Output:** `printf` displays the confirmation message if matched.

#### Problem: Absolute Value
- **Objective:**
  - Write a program that converts the value of an integer variable `x` to its absolute value using an `if` statement.
- **Key Concepts:**
  - Conditional logic
  - Variable manipulation
  - Input/output operations

#### Solution: Absolute Value
- **Code Implementation:**
  ```java
  import java.util.Scanner;

  public class AbsVal {
      public static void main(String[] args) {
          Scanner in = new Scanner(System.in);
          int x = in.nextInt();

          System.out.printf("BEFORE: x = %d\n", x);
          if (x < 0)
              x = -x;
          System.out.printf("AFTER: x = %d\n", x);

          in.close(); // Good practice to close the scanner
      }
  }
  ```
- **Explanation:**
  - **Scanner:** Reads integer input from the user.
  - **Conditional Check:** If `x` is less than 0, negate `x` to obtain its absolute value.
  - **Output:** Displays the value of `x` before and after conversion.

#### Problem: Quadratic
- **Objective:**
  - Write a method `printRoots(double a, double b, double c)` that finds and prints the roots of a quadratic equation, including imaginary roots.
- **Key Concepts:**
  - Mathematical computation
  - Handling real and imaginary roots
  - Method creation and usage

#### Solution: Quadratic
- **Code Implementation:**
  ```java
  public class Quadratic {
      void printRoots(double a, double b, double c) {
          double d = b * b - 4 * a * c;

          if (d < 0) {
              double realPart = -b / (2 * a);
              double imaginaryPart = Math.sqrt(-d) / (2 * a);
              System.out.printf("%.2f+%.2fi and %.2f-%.2fi are imaginary roots of %.2fx^2 + %.2fx + %.2f\n",
                                realPart, imaginaryPart, realPart, imaginaryPart, a, b, c);
          } else {
              double root1 = (-b + Math.sqrt(d)) / (2 * a);
              double root2 = (-b - Math.sqrt(d)) / (2 * a);
              System.out.printf("%.2f and %.2f are real roots of %.2fx^2 + %.2fx + %.2f\n",
                                root1, root2, a, b, c);
          }
      }

      public static void main(String[] args) {
          Quadratic q = new Quadratic();
          q.printRoots(3, 4, 5);    // Imaginary roots
          q.printRoots(2, 4, -30);  // Real roots
          q.printRoots(12, 5, 3);   // Real roots
      }
  }
  ```
- **Explanation:**
  - **Discriminant (`d`):** Determines the nature of the roots.
    - **Negative `d`:** Imaginary roots.
    - **Non-negative `d`:** Real roots.
  - **Imaginary Roots Calculation:**
    - Real part: `-b / (2a)`
    - Imaginary part: `√(-d) / (2a)`
  - **Real Roots Calculation:**
    - `(-b + √d) / (2a)`
    - `(-b - √d) / (2a)`
  - **Output:** Formatted to display roots with two decimal places.

#### Problem: DaisyDriveIn
- **Objective:**
  - Write a method `double computePay(double hours)` that calculates pay based on the following:
    - **More than 20 hours:**
      - $15/hour for the first 20 hours.
      - $20/hour for each additional hour.
    - **20 hours or fewer:**
      - $12/hour.
- **Key Concepts:**
  - Conditional logic
  - Method creation and return values
  - Payroll computation

#### Solution: DaisyDriveIn
- **Code Implementation:**
  ```java
  public class DaisyDriveIn {
      double computePay(double hours) {
          if (hours > 20)
              return 15.00 * 20 + (hours - 20) * 20.00;
          else
              return hours * 12.00;
      }

      public static void main(String[] args) {
          DaisyDriveIn d = new DaisyDriveIn();
          double pay;

          pay = d.computePay(20);    // Expected: 240.00
          System.out.printf("Pay for 20 hours: $%.2f\n", pay);

          pay = d.computePay(21);    // Expected: 320.00
          System.out.printf("Pay for 21 hours: $%.2f\n", pay);

          pay = d.computePay(9.5);   // Expected: 114.00
          System.out.printf("Pay for 9.5 hours: $%.2f\n", pay);

          pay = d.computePay(9.1);   // Expected: 109.20
          System.out.printf("Pay for 9.1 hours: $%.2f\n", pay);
      }
  }
  ```
- **Explanation:**
  - **Method `computePay`:**
    - **Condition:** Checks if `hours` exceed 20.
    - **Pay Calculation:**
      - **>20 hours:** `15.00 * 20 + (hours - 20) * 20.00`
      - **≤20 hours:** `hours * 12.00`
  - **Main Method:**
    - Creates an instance of `DaisyDriveIn`.
    - Computes pay for different hour inputs.
    - Uses `printf` to display pay with two decimal places.

---

### Additional Concepts

#### Final Keyword
- **Usage in Variables:**
  - Declared with `final` to prevent reassignment.
  - Examples:
    ```java
    final int SIZE = 100;
    SIZE = 50; // Error: cannot assign a value to final variable SIZE

    final double PI = 3.14159;
    PI = 3.1; // Error: cannot assign a value to final variable PI
    ```
- **Immutability:**
  - `final` ensures the variable's value remains constant after initialization.

#### Primitive vs. Reference Types
- **Primitive Types:**
  - Hold **actual values**.
  - Examples: `int`, `double`, `boolean`, `char`.
- **Reference Types:**
  - Hold **references** (memory addresses) to objects.
  - Examples: `String`, custom objects (`Wheel`, etc.).
- **Comparison Operators:**
  - `==` and `!=` for reference types compare **addresses**, not **values**.
  - Use `.equals()` for value-based comparison in objects like `String`.

#### Logical Operators
- **AND (`&&`):**
  - Returns `true` only if both operands are `true`.
- **OR (`||`):**
  - Returns `true` if at least one operand is `true`.
- **XOR (`^`):**
  - Returns `true` if exactly one operand is `true`.
- **NOT (`!`):**
  - Inverts the boolean value.

#### Method Structure
- **Declaration:**
  ```java
  returnType methodName(parameters) {
      // method body
  }
  ```
- **Example:**
  ```java
  double computePay(double hours) {
      if (hours > 20)
          return 15.00 * 20 + (hours - 20) * 20.00;
      else
          return hours * 12.00;
  }
  ```
- **Access Modifiers:**
  - `public`, `private`, `protected`, or default (package-private).

#### Using Scanner for Input
- **Instantiation:**
  ```java
  Scanner in = new Scanner(System.in);
  ```
- **Methods:**
  - `next()`: Reads the next token (word) as `String`.
  - `nextInt()`: Reads the next token as `int`.
  - `nextDouble()`: Reads the next token as `double`.
- **Best Practices:**
  - Close the scanner after use to free resources:
    ```java
    in.close();
    ```

#### Exception Handling (Brief Overview)
- **Potential Exception Points:**
  - Input mismatches when reading with `Scanner`.
- **Basic Structure:**
  ```java
  try {
      // code that may throw an exception
  } catch (ExceptionType e) {
      // handling code
  }
  ```
- **Program Termination:**
  - Unhandled exceptions cause the program to terminate abruptly.

---

### Summary of Key Points
- **Variable Declaration:**
  - Use `var` for type inference when type is clear.
  - Use `final` to declare immutable variables.
- **Control Flow:**
  - Understand and utilize `if`, `else`, `switch`, loops (`for`, `while`).
  - Use logical operators to combine conditions.
- **Data Types:**
  - Distinguish between primitive and reference types.
  - Use `.equals()` for comparing object values.
- **Methods:**
  - Encapsulate reusable logic within methods.
  - Ensure correct return types and parameter usage.
- **Input/Output:**
  - Utilize `Scanner` for input.
  - Use `System.out.printf` for formatted output.
- **Problem Solving:**
  - Break down problems into smaller tasks.
  - Implement conditional logic to handle different scenarios.
  - Test methods with various inputs to ensure correctness.
